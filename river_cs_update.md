引子
    一直有同学想让我总结一下公司在Unity代码热更新方面的积累，正好最近有一款新游上线，虽然是款新游戏但由于用的是外部项目继承过来的一套框架，项目代码是C#  + Lua混编，有很大一部分C#逻辑(包括大量MonoBehaviour)，项目每次改C#都需要攒一个月的修改量然后强更一次，每次强更都会流失10%的用户，同时项目面临大推，想彻底解决这个问题。由于用的不是我们自己原来的框架，且也没有那么多人力和时间进行大规模改造，所以之前的C#热更方案应用不上。最终我们花了1个半月，在项目组一行业务代码没改的情况下，使用自研的一套方案成功解决，且已上线后大推稳定无事故。借此机会我也介绍一下代码热更新在咱们公司的演进过程。
背景    
    移动平台代码热更新（此处"热"字不那么准确，现在大部分更新都是重启或者重新Loading更新，较真地说应该是“冷”更新，本文不咬文嚼字，以行业内惯性说法为准）是目前游戏开发中始终绕不过去的一个话题，特别是对于快速迭代开发的团队，代码热更新的形态和完善程度决定了线上环境出问题时的响应速度以及用户体验。基于游戏引擎的脚本环境其实现难度可谓天差地别，比如Cocos Creator(CC)，选择使用js(ts)作为其脚本语言，且引擎内置了热更新解决方案，所以代码更新对于使用CC的团队来说从来不是一个技术难题(当然，像微信小游戏这种除外)；而对于Unity来说，花样突然就多了起来，各种技术解决方案层出不穷，Lua系： slua, ulua, xlua等等， js(ts)系:JSBinding, puerts等,  C#系: L#, ILRuntime，InjectFix, HybridCLR(huatuo)等，甚至于最后还从开源版本衍生出了商业化方案(HybridCLR专业版，旗舰版)。
    如果某项技术值得这么多人前赴后继地去钻研，要不就是它确实很有价值，要不就是没有一个能适用于所有项目的完美方案，价值不用多说了，为什么就没有完美方案呢？这里面有平台限制，也有历史包袱，甚至也有商业考量。时间拉回到8年之前，彼时Unity还只使用mono作为其C#代码的运行时环境(且只提供32位版本)，由于mono并没有提供可用的解释器，再加上iOS对于app的内存执行权限有严格限制，导致C#(CIL)在移动平台需要针对操作系统选择不同的执行方式：
1. Android：JIT执行(运行时生成对应平台的原生指令)，
2. iOS:  AOT执行(在编译的时候提前生成对应平台的原生指令)。
对于1来说C#代码更新完全不是问题，但是2却直接把C#代码更新的路给堵死了，所以Unity在C#代码更新这一块天然就存在残疾，Android你可以有很多办法更新(自行编译mono, mono hook等)，但iOS就是拦在前面的那座大山，于是C#再搭配另一种脚本语言写逻辑这种方式应运而生，当然还有一些团队依然坚守全C#，毕竟Android还可以更新。好景不长，2015年1月Unity推出了il2cpp, 这是一种AOT技术，原理是把C#编译生成的IL代码转成c++然后再编译成各个平台的原生指令，Unity声称它的推出能解决很多问题，比如mono许可证问题，性能，多平台维护性，AppStore64位支持要求(2015.2)，GooglePlay64位支持要求(2019.8)等，但它唯一不能解决的就是C#更新，且直接让本就残疾的C#更新直接废掉，随着两大商店陆续要求各个app支持64位，而Unity只有il2cpp才能出64位app，这下连Android都没法用之前的老套路轻松更新C#了。那如果还想更新C#除了市面上的那些开源框架还有哪些办法呢？
江娱第一代C#更新方案
    2017年底的时候mono释出了第一个生产环境可用的解释器版本(https://www.mono-project.com/news/2017/11/13/mono-interpreter/), 同时支持64位以及和AOT代码混合执行，那么意味着此时mono在iOS上具备了更新代码的基础，且它的许可证变成了MIT, 我天真的以为Unity会有所跟进，然而两年之后Unity依然没有动静，看得出他们对于mono这套机制是不想再维护了完全醉心于il2cpp了(当然我觉得他们的决定没什么毛病)。既然官方不给力那咱们自己来，当时的想法比较简单，反正市面上其他的方案都是工程里再嵌一个解释器或者VM，我能不能直接在il2cpp里再嵌一个新版本的mono？然后尽可能多的把C#都放到这个mono里去执行，于是在2019年底我们的第一代C#热更方案FM_Mono应运而生，知乎上有个哥们儿21年也提出了类似思路，不过它的方案比较激进，连UnityEngine.dll也想放到mono来执行，我看22年之后他就再没更新过了，我们的方案是偏保守的，虽然嵌入的mono也是用C#写代码，但是主工程的C#和脚本工程的C#实际是类型隔离的，比如主工程的System.Array在脚本工程里是Host.System.Array，跟脚本工程的System.Array是两个类型，只是提供的接口一样，但是对业务开发没有太多影响，他们只是using的命名空间不一样，且跨域调用的时候会有隐式转换，这样可以降低整套方案的复杂性，大致原理如下：
原理：
[图片]
添加图片注释，不超过 140 字（可选）
功能：
- 静态导出
- 反射调用
- Struct参数跨域调用无GC
- 完整的P/Invoke支持
- 主工程和脚本工程互传Delegate
- 多线程
- 编辑器调试+Profiler, 真机远程调试
- 脚本域异常支持完整方法栈
限制：
- 跨域不支持泛型方法
- 跨域泛型类需要特化
- 跨域接口和抽象类需要显式声明导出
- 主工程不得持有脚本工程对象(delegate除外)
- 模拟器支持不稳定
    这套方案的总体思路是主工程的代码尽量薄(只有最基础的framework代码)，基本所有的逻辑都放到脚本域，脚本域代码在Android上使用jit执行代码，在iOS上使用AOT+interpreter的混合模式，此方案在Android上性能应该是吊打其他方案了，在iOS上解释器性能跟Hybrid社区版对半开(数值计算性能是Hybrid社区版的2倍以上，跨域调用只有Hybrid的60%-80%），缺点是必须放弃MonoBehaivour和主工程相关dll的更新，且需要生成跨域绑定代码。目前从2019年底江娱第一个Unity项目到现在陆续迭代了五个项目且都上线验证过，所有项目的崩溃率都能控制到0.4%以下，是目前公司内最稳定的一套C#更新方案
江娱第二代C#更新方案
    引子里说了，23年9月底我们接手了一款新项目，项目最开始应该是全C#开发的，但是为了热更新把所有UI和主城相关的逻辑全都改成了lua，并使用xlua进行集成，我估计最开始设计者的思路就是一步步迭代，慢慢把所有业务迁移到lua，性能比较敏感的部分留在C#, 但是理想很丰满，现实很骨感，这个迭代似乎在某个点停住了(快速迭代公司常有的事😊)，带来的结果就是还有相当一部分业务是放在C#这边的，要让这种项目无感支持所有C#的热更新，在当前时间点市面上能选择的方案就只有HybridCLR一个选项，开始我比较天真地以为直接无脑上它就OK了，但是调研结果着实有点劝退：这个项目是基于Unity2019.4开发，且对性能很敏感，因为C#这块xlua wrapper跟逻辑代码耦合比较严重，没办法把这块单独放到AOT模块里，意味着接了C#更新后lua跨域交互性能也会极速下降，而针对2019版本Hybrid只提供社区版，要享受高性能的商业化版本至少得升级到2020(造化弄人，24年初Hybrid商业版本已经支持2019，你看你们不早弄又损失一个客户吧)。说实话要花钱我觉得都是小事，但是在那个时间点既要改造项目支持C#热更，为了性能还要升级引擎，这个时间和风险项目组是绝对无法承受的。
    还能有什么办法更新C#？
    首先il2cpp的运行时代码是开源的，我扫了一下眼il2cpp跟Unity引擎的交互，完全是通过200多个导出接口来进行交互，很多接口跟mono的embed接口如出一辙，一个想法在我脑中很自然地就蹦出来，对于Unity来说他只依赖于il2cpp的导出接口，而不关心具体实现，如果我把il2cpp整个换掉，用mono来模拟是不是就能更新C#了？当然这个想法是有根据的，一是所有il2cpp类型在头文件里都没暴露具体实现，对于Unity来说就是一个指针而已，而是从工程角度出发32位mono现在还在支持中，对于Unity来说il2cpp和mono提供一套相对统一的接口肯定在工程上是最合适的方式。而且这个方案对业务完全无感，Android性能不用担心了，iOS也可以通过运行时调整AOT策略来规避一些性能问题(程序启动后如果某个dll是包内的则走AOT，热更下来的则走解释执行，当用户自动覆盖更新后所有的dll又都变成AOT，后续还会提供Hybrid类似的混合执行技术)。实践证明我的想法完全没问题，基本所有接口都可以完美模拟，模拟完后的结构如下：
[图片]
添加图片注释，不超过 140 字（可选）
    当然模拟只是第一步，如果直接用最新版的mono去适配的话，可能一跑起来就崩了，为什么，因为Unity对于il2cpp是有潜规则的，Unity强依赖于bdwgc，它默认从il2cpp拿到的对象指针都是不可移动不会变化的。但是最新版的mono默认已经是SGen GC，它对于对象的管理是可移动的，所以还得把mono的gc换成跟Unity版本一致的bdwgc(这块也是开源的，可以在Unity GitHub找到), 剩下的过程就简单了，只需要保证200多个接口的结果一致，然后再把Unity il2cpp构建过程一换(此处省略几百字😊)就完美搞定了，最终耗时1个半月。当然，基于Hybrid社区版改造的工作我们也没停止，一直是双管齐下，直到这个自研方案最后上线的那天我们依然用Hybrid的方案做着保底备份。
功能：
- 所有il2cpp支持的功能
- Profiler和Debug
- 解释执行出异常时也能拿到执行栈
- 可以不配置裁剪，因为没有il2cpp转换那部分了，不会有二进制代码膨胀问题
- 支持增量GC
限制：
- MonoBehaviour热更不能修改或删除序列化字段(Unity自己的限制)
- 新增的MonoBehaviour不能放到新的dll里(Unity自己的限制)
- Burst相关代码热更后会走正常的mono执行(Android jit, iOS解释执行, 这也是跟Burst机制有关)
- 对于新增的P/Invoke接口需要自己加版本判断按需处理（正常就应该这样）
- iOS上mono和bugly对于signal的handler有冲突，主要是bugly太流氓，所以我们iOS上用的Firebase, Android上用的bugly，不过这个可以改，但我就是看不惯bugly的流氓
- iOS上更新完后需要退出进程再启动才能更新，这个也在改造中，Android可以软重启
是否受Unity版本影响比较大：
  并不会，只需要针对各个版本做一些接口调整而已
接入是否很复杂：
一个UPM包引入一下就搞定了，运行时有dll需要更新时只需要把新的dll复制到指定路径重启后就可以更新
是否会开源：
    正在考虑