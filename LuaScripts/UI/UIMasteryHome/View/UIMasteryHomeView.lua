---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2023/3/8 15:28
---

local UIMasteryHome = BaseClass("UIMasteryHome", UIBaseView)
local base = UIBaseView
local UIMasteryPoint = require "UI.UIMastery.Component.UIMasteryPoint"
local UIMasteryNode = require "UI.UIMasteryHome.Component.UIMasteryNode"
local UIMasteryLine = require "UI.UIMasteryHome.Component.UIMasteryLine"
local UIMasteryTip = require "UI.UIMastery.Component.UIMasteryTip"
local UIMasteryPage = require "UI.UIMastery.Component.UIMasteryPage"
local Localization = CS.GameEntry.Localization
local Touch = CS.BitBenderGames.TouchWrapper

local back_path = "SafeArea/Back"
local title_path = "SafeArea/Title"
local point_path = "SafeArea/UIMasteryPoint"
local bg_path = "Bg"
local root_path = "Root"
local line_root_path = "Root/LineRoot"
local node_root_path = "Root/NodeRoot"
local tip_path = "UIMasteryTip"
local page_path = "SafeArea/UIMasteryPage"
local pageTemp_path = "SafeArea/UIMasteryPageTemp"
local tempTips_path = "SafeArea/UIMasteryPageTemp/Txt_TempTips"
local tempTitle_path = "SafeArea/UIMasteryPageTemp/Txt_TempTitle"

local ScreenWidth = Screen.width / Screen.height * 750
local ScreenHeight = 750

local function ToLineKey(groupA, groupB)
    if groupA < groupB then
        return groupA .. "_" .. groupB
    else
        return groupB .. "_" .. groupA
    end
end

local function OnCreate(self)
    base.OnCreate(self)
    self:DataDefine()
    self:ComponentDefine()
end

local function OnDestroy(self)
    self:ComponentDestroy()
    self:DataDestroy()
    base.OnDestroy(self)
end

local function OnEnable(self)
    base.OnEnable(self)
    self:ReInit()
end

local function OnDisable(self)
    base.OnDisable(self)
end

local function ComponentDefine(self)
    self.back_btn = self:AddComponent(UIButton, back_path)
    self.back_btn:SetOnClick(function()
        SoundUtil.PlayEffect(SoundAssets.Music_Effect_Button)
        self:OnCloseClick()
    end)
    self.title_text = self:AddComponent(UIText, title_path)
    self.point = self:AddComponent(UIMasteryPoint, point_path)
    self.page = self:AddComponent(UIMasteryPage,page_path)
    self.root_go = self:AddComponent(UIBaseContainer, root_path)
    self.line_root_go = self:AddComponent(UIBaseContainer, line_root_path)
    self.node_root_go = self:AddComponent(UIBaseContainer, node_root_path)
    self.event_trigger = self:AddComponent(UIEventTrigger, bg_path)
    self.event_trigger:OnPointerDown(function(eventData)
        self:OnPointerDown(eventData)
    end)
    self.event_trigger:OnDrag(function(eventData)
        self:OnDrag(eventData)
    end)
    self.event_trigger:OnBeginDrag(function(eventData)
        self:OnBeginDrag(eventData)
    end)
    self.event_trigger:OnEndDrag(function(eventData)
        self:OnEndDrag(eventData)
    end)
    self.tip = self:AddComponent(UIMasteryTip, tip_path)
    self.pageTemp = self:AddComponent(UIBaseContainer,pageTemp_path)
    self._tempTips_txt = self:AddComponent(UIText,tempTips_path)
    self._tempTitle_txt = self:AddComponent(UIText,tempTitle_path)
    self._tempTips_txt:SetLocalText(111039)
end

local function ComponentDestroy(self)
    self.back_btn = nil
    self.title_text = nil
    self.point = nil
    self.root_go = nil
    self.line_root_go = nil
    self.node_root_go = nil
    self.event_trigger = nil
    self.tip = nil
    local rootRt = self.pageTemp.rectTransform
    DOTween.Kill(rootRt)
    rootRt:Set_localScale(1, 1, 0)
end

local function DataDefine(self)
    self.isDebug = false
    self.config = nil
    self.home = 0
    self.timer = nil
    self.lineReqs = {} -- Dict<key, InstanceRequest>
    self.lines = {} -- Dict<key, UIMasteryLine>
    self.nodeReqs = {} -- Dict<group, InstanceRequest>
    self.nodes = {} -- Dict<group, UIMasteryNode>
    self.lastTouches = {} -- List<{ fingerId, pos }>
    self.nodeRect = { xMin = 0, yMin = 0, xMax = 0, yMax = 0 } -- 节点最小外接矩形
    self.selectGroups = {}
    self.arrowGroup = 0
    self.createQueue = {} -- Queue<function>
    self.onClose = nil
end

local function DataDestroy(self)
    self.isDebug = nil
    self.config = nil
    self.home = nil
    if self.timer then
        self.timer:Stop()
        self.timer = nil
    end
    self.lineReqs = nil
    self.lines = nil
    self.nodeReqs = nil
    self.nodes = nil
    self.lastTouches = nil
    self.nodeRect = nil
    self.selectGroups = nil
    self.arrowGroup = nil
    self.createQueue = nil
    self.onClose = nil
end

local function OnAddListener(self)
    base.OnAddListener(self)
    self:AddUIListener(EventId.MasteryLearn, self.OnMasteryLearn)
    self:AddUIListener(EventId.MasteryReset, self.OnMasteryReset)
    self:AddUIListener(EventId.MasteryUpdate, self.RefreshPage)
    self:AddUIListener(EventId.MasteryChangePlan, self.Refresh)
    self:AddUIListener(EventId.MasteryChangeName, self.ChangePageName)
    self:AddUIListener(EventId.UpdateGiftPackData, self.OnBuyPackage)
end

local function OnRemoveListener(self)
    self:RemoveUIListener(EventId.MasteryLearn, self.OnMasteryLearn)
    self:RemoveUIListener(EventId.MasteryReset, self.OnMasteryReset)
    self:RemoveUIListener(EventId.MasteryUpdate, self.RefreshPage)
    self:RemoveUIListener(EventId.MasteryChangePlan, self.Refresh)
    self:RemoveUIListener(EventId.MasteryChangeName, self.ChangePageName)
    self:RemoveUIListener(EventId.UpdateGiftPackData, self.OnBuyPackage)
    base.OnRemoveListener(self)
end

local function OnBuyPackage(self)
    self.page:Refresh(true)
end

local function OnPointerDown(self, eventData)
    self.tip:Hide()
    self:SelectGroups({})
end

local function OnDrag(self, eventData)
    if Touch.TouchCount == 1 then
        self:MoveRoot(eventData.delta * self.config.moveSensitivity)
    end
end

local function OnBeginDrag(self, eventData)
    self.tip:Hide()
    self:SelectGroups({})
end

local function OnEndDrag(self, eventData)
    
end

local function HideTips(self)
    self.tip:Hide()
    self:SelectGroups({})
end

local function ReInit(self)
    self.home, self.arrowGroup, self.tempPage, self.onClose = self:GetUserData()
    self.isDebug = CS.CommonUtils.IsDebug()
    self.config = DataCenter.MasteryManager:GetHomeViewConfig()
    self.title_text:SetLocalText(MasteryHomeTitle[self.home])
    self.point:Refresh()
    self.page:Refresh()
    self:CreateAllNodesAndLines()
    self.tip:Hide()
    self:SelectGroups({})
    self.root_go.transform.localScale = Vector3.one * self.config.scaleInit
    if self.arrowGroup then
        self:LookAtNode(self.arrowGroup)
    else
        self.root_go.transform.localPosition = Vector3.zero
    end

    if self.timer == nil then
        self.timer = TimerManager:GetInstance():GetTimer(0.05, self.TimerAction, self, false, false, false)
        self.timer:Start()
    end
    if self.tempPage then
        self.pageTemp:SetActive(true)

        local rootRt = self.pageTemp.rectTransform
        DOTween.Kill(rootRt)
        rootRt:Set_localScale(0, 1, 0)
        rootRt:DOScale(Vector3.New(1, 1, 0), 0.3):SetEase(CS.DG.Tweening.Ease.InOutCubic)
        
        local name = DataCenter.MasteryManager:GetPageName(self.tempPage)
        if name == "" then
            self._tempTitle_txt:SetLocalText(111038,Localization:GetString("110704",self.tempPage))
        else
            self._tempTitle_txt:SetLocalText(111038,name)
        end
    else
        self.pageTemp:SetActive(false)
    end
end

local function RefreshPage(self)
    self.page:Refresh()
    local tempPlanIndex = DataCenter.MasteryManager:GetTempPlanIndex()
    if tempPlanIndex and tempPlanIndex ~= 0 and tempPlanIndex ~= DataCenter.MasteryManager:GetCurPlanIndex() then
        self.pageTemp:SetActive(true)
        local name = DataCenter.MasteryManager:GetPageName(tempPlanIndex)
        if name == "" then
            self._tempTitle_txt:SetLocalText(111038,Localization:GetString("110704",tempPlanIndex))
        else
            self._tempTitle_txt:SetLocalText(111038,name)
        end
    else
        self.pageTemp:SetActive(false)
    end
end

local function ChangePageName(self)
    self.page:UpdateName()
end

local function Refresh(self,refreshType)
    local tempPlanIndex = DataCenter.MasteryManager:GetTempPlanIndex()
    local curPlanIndex = DataCenter.MasteryManager:GetCurPlanIndex()
    if tempPlanIndex and tempPlanIndex ~= 0 and tempPlanIndex ~= curPlanIndex then
        self.tempPage = tempPlanIndex
    else
        self.tempPage = nil
    end
    self.point:Refresh()
    self.page:Refresh(refreshType)
    for _, node in pairs(self.nodes) do
        node:Refresh()
    end
    for _, line in pairs(self.lines) do
        line:Refresh()
    end
    if self.tempPage  and self.tempPage ~= curPlanIndex then
        self.pageTemp:SetActive(true)

        local rootRt = self.pageTemp.rectTransform
        DOTween.Kill(rootRt)
        rootRt:Set_localScale(0, 1, 0)
        rootRt:DOScale(Vector3.New(1, 1, 0), 0.3):SetEase(CS.DG.Tweening.Ease.InOutCubic)
        
        local name = DataCenter.MasteryManager:GetPageName(self.tempPage)
        if name == "" then
            self._tempTitle_txt:SetLocalText(111038,Localization:GetString("110704",self.tempPage))
        else
            self._tempTitle_txt:SetLocalText(111038,name)
        end
    else
        self.pageTemp:SetActive(false)
    end
end

local function TimerAction(self)
    if #self.createQueue > 0 then
        local firstInfo = table.remove(self.createQueue, 1)
        local toCreateList = { firstInfo }
        while #self.createQueue > 0 do
            local info = self.createQueue[1]
            if --[[info.type == firstInfo.type and]] info.depth == firstInfo.depth then
                table.insert(toCreateList, info)
                table.remove(self.createQueue, 1)
            else
                break
            end
        end
        for _, info in ipairs(toCreateList) do
            if info.type == "node" then
                self:CreateNode(info.group)
            elseif info.type == "line" then
                self:CreateLine(info.group, info.nextGroup)
            end
        end
    end
end

local function Update(self)
    self:UpdateTouch()
    
    if self.isDebug then
        local scrollDelta = CS.UnityEngine.Input.GetAxis("Mouse ScrollWheel")
        if math.abs(scrollDelta) > 0.01 then
            self:ScaleRoot(scrollDelta * self.config.scaleSensitivity)
            self.tip:Hide()
        end
    end
end

local function UpdateTouch(self)
    local touches = Touch.Touches
    local curTouches = {}
    local isSameFingers = true
    for i = 0, Touch.TouchCount - 1 do
        local curTouch = {}
        curTouch.fingerId = touches[i].FingerId
        curTouch.pos = touches[i].Position
        table.insert(curTouches, curTouch)
        
        local found = false
        for _, lastTouch in ipairs(self.lastTouches) do
            if lastTouch.fingerId == curTouch.fingerId then
                found = true
                break
            end
        end
        if not found then
            isSameFingers = false
        end
    end
    if #self.lastTouches == 2 and #curTouches == 2 then
        local lastCenter = (self.lastTouches[1].pos + self.lastTouches[2].pos) / 2
        local lastDis = Vector3.Distance(self.lastTouches[1].pos, self.lastTouches[2].pos)
        local curCenter = (curTouches[1].pos + curTouches[2].pos) / 2
        local curDis = Vector3.Distance(curTouches[1].pos, curTouches[2].pos)
        local centerDelta = curCenter - lastCenter
        local disDelta = curDis - lastDis
        self:ScaleRoot(disDelta * self.config.scaleSensitivity * 0.01)
        self:MoveRoot(centerDelta * self.config.moveSensitivity)
    end
    
    self.lastTouches = curTouches
end

local function ClampRoot(self)
    local scale = self.root_go.transform.localScale.x
    local pos = self.root_go.transform.localPosition
    local xMin = -self.nodeRect.xMax * scale + ScreenWidth / 2 - self.config.movePadding
    local xMax = -self.nodeRect.xMin * scale - ScreenWidth / 2 + self.config.movePadding
    local yMin = -self.nodeRect.yMax * scale + ScreenHeight / 2 - self.config.movePadding
    local yMax = -self.nodeRect.yMin * scale - ScreenHeight / 2 + self.config.movePadding
    pos.x = xMin < xMax and Mathf.Clamp(pos.x, xMin, xMax) or 0
    pos.y = yMin < yMax and Mathf.Clamp(pos.y, yMin, yMax) or 0
    self.root_go.transform.localPosition = pos
end

local function MoveRoot(self, delta)
    local pos = self.root_go.transform.localPosition
    pos.x = pos.x + delta.x
    pos.y = pos.y + delta.y
    self.root_go.transform.localPosition = pos
    self:ClampRoot()
end

local function ScaleRoot(self, delta)
    local scale = self.root_go.transform.localScale.x
    local pos = self.root_go.transform.localPosition
    pos = pos / scale
    scale = Mathf.Clamp(scale + delta, self.config.scaleMin, self.config.scaleMax)
    pos = pos * scale
    self.root_go.transform.localScale = Vector3.one * scale
    self.root_go.transform.localPosition = pos
    self:ClampRoot()
end

local function CreateAllNodesAndLines(self)
    self:ClearAllLines()
    self:ClearAllNodes()
    self.nodeRect = { xMin = 0, yMin = 0, xMax = 0, yMax = 0 }
    local _, rootGroups = DataCenter.MasteryManager:GetGroupsByHome(self.home)
    local queue = {}
    local depthDict = {}
    local visitedDict = {}
    for _, group in ipairs(rootGroups) do
        depthDict[group] = 1
        table.insert(queue, group)
    end
    self.createQueue = {}
    while #queue > 0 do
        local group = table.remove(queue, 1)
        if not visitedDict[group] then
            local depth = depthDict[group]
            visitedDict[group] = true
            table.insert(self.createQueue, {
                type = "node",
                group = group,
                depth = depth,
            })
            local template = DataCenter.MasteryManager:GetTemplate(group)
            local pos = template.tempData:getValue("pos")
            local posX = pos[1]
            local posY = pos[2]
            if posX ==nil or posX<=0 then
                posX = 1
            end
            if posY ==nil or posY<=0 then
                posY = 1
            end
            self.nodeRect.xMin = math.min(self.nodeRect.xMin, posX)
            self.nodeRect.yMin = math.min(self.nodeRect.yMin, posY)
            self.nodeRect.xMax = math.max(self.nodeRect.xMax, posX)
            self.nodeRect.yMax = math.max(self.nodeRect.yMax, posY)
            for _, nextGroup in ipairs(template.nexts) do
                table.insert(self.createQueue, {
                    type = "line",
                    group = group,
                    nextGroup = nextGroup,
                    depth = depth,
                })
                depthDict[nextGroup] = depth + 1
                table.insert(queue, nextGroup)
            end
        end
    end
    table.sort(self.createQueue, function(infoA, infoB)
        if infoA.depth ~= infoB.depth then
            return infoA.depth < infoB.depth
        elseif infoA.type ~= infoB.type then
            return infoA.type == "node"
        else
            return infoA.group < infoB.group
        end
    end)
end

local function CreateLine(self, groupA, groupB)
    local key = ToLineKey(groupA, groupB)
    if self.lineReqs[key] then
        return
    end
    self.lineReqs[key] = self:GameObjectInstantiateAsync(UIAssets.UIMasteryLine, function(req)
        if req.isError then
            return
        end
        local template1 = DataCenter.MasteryManager:GetTemplate(groupA, 1)
        local template2 = DataCenter.MasteryManager:GetTemplate(groupB, 1)
        local pos1 = template1.tempData:getValue("pos")
        local pos2 = template2.tempData:getValue("pos")
        
        local posX1 = pos1[1]
        local posY1 = pos1[2]
        if posX1 ==nil or posX1<=0 then
            posX1 = 1
        end
        if posY1 ==nil or posY1<=0 then
            posY1 = 1
        end

        local posX2 = pos2[1]
        local posY2 = pos2[2]
        if posX2 ==nil or posX2<=0 then
            posX2 = 1
        end
        if posY2 ==nil or posY2<=0 then
            posY2 = 1
        end
        local go = req.gameObject
        go.name = "Line_" .. key
        go:SetActive(true)
        go.transform:SetParent(self.line_root_go.transform)
        go.transform:Set_localScale(ResetScale.x, ResetScale.y, ResetScale.z)
        go.transform.localPosition = Vector3.New((posX1 + posX2) / 2, (posY1 + posY2) / 2, 0)
        go.transform.rotation = Quaternion.Euler(0, 0, Mathf.Atan(posY2 - posY1, posX2 - posX1) * 180 / Mathf.PI)
        
        local line = self.line_root_go:AddComponent(UIMasteryLine, go.name)
        line:SetData(groupA, groupB)
        line.rectTransform.sizeDelta = Vector2.New(Vector2.Distance(pos1, pos2), line.rectTransform.sizeDelta.y)
        self.lines[key] = line
    end)
end

local function CreateNode(self, group)
    local template = DataCenter.MasteryManager:GetTemplate(group, 1)
    self.nodeReqs[group] = self:GameObjectInstantiateAsync(UIAssets.UIMasteryNode, function(req)
        if req.isError then
            return
        end
        local go = req.gameObject
        go.name = "Node_" .. group
        go:SetActive(true)
        go.transform:SetParent(self.node_root_go.transform)
        go.transform:Set_localScale(ResetScale.x, ResetScale.y, ResetScale.z)
        go.transform.localPosition = Vector3.New(template.pos.x, template.pos.y, 0)
        
        local node = self.node_root_go:AddComponent(UIMasteryNode, go.name)
        node:SetData(group, self, function()
            self:OnNodeClick(group)
        end)
        node:SetSelected(false)
        self.nodes[group] = node
        
        -- arrow
        if group == self.arrowGroup then
            self:ShowArrowToNode(group)
            self.arrowGroup = 0
        end
    end)
end

local function ClearAllLines(self)
    self.line_root_go:RemoveComponents(UIMasteryLine)
    for _, req in pairs(self.lineReqs) do
        req:Destroy()
    end
    self.lineReqs = {}
    self.lines = {}
end

local function ClearAllNodes(self)
    self.node_root_go:RemoveComponents(UIMasteryNode)
    for _, req in pairs(self.nodeReqs) do
        req:Destroy()
    end
    self.nodeReqs = {}
    self.nodes = {}
end

local function SelectGroups(self, groups)
    for _, group in ipairs(self.selectGroups) do
        if not table.hasvalue(groups, group) then
            local node = self.nodes[group]
            if node then
                node:SetSelected(false)
            end
        end
    end
    for _, group in ipairs(groups) do
        if not table.hasvalue(self.selectGroups, group) then
            local node = self.nodes[group]
            if node then
                node:SetSelected(true)
            end
        end
    end
    self.selectGroups = groups
end

local function LookAtNode(self, group)
    local scale = self.root_go.transform.localScale.x
    local template = DataCenter.MasteryManager:GetTemplate(group)
    local pos = template.tempData:getValue("pos")
    local posX = pos[1]
    local posY = pos[2]
    if posX ==nil or posX<=0 then
        posX = 1
    end
    if posY ==nil or posY<=0 then
        posY = 1
    end
    self.root_go.transform.localPosition = Vector3.New(-posX, -posY, 0) * scale
    self:ClampRoot()
end

local function ShowArrowToNode(self, group)
    local node = self.nodes[group]
    if node then
        local param =
        {
            arrowType = ArrowType.Normal,
            positionType = PositionType.Screen,
            position = node.transform.position,
        }
        DataCenter.ArrowManager:ShowArrow(param)
    end
end

local function OnCloseClick(self)
    if self.onClose then
        self.onClose()
    end
    self.ctrl:CloseSelf()
end

local function OnNodeClick(self, group)
    local node = self.nodes[group]
    if node == nil then
        return
    end

    local template = DataCenter.MasteryManager:GetTemplate(group)
    if template.tempData:getValue("default") == 1 then
        return
    end
    self.page:OnHide()
    self.tip:SetData(group,self.tempPage)
    self.tip:Show(node.transform.position)
    self:SelectGroups({ group })
    SoundUtil.PlayEffect(SoundAssets.Music_Effect_Common_SelectGoods)
end

local function OnMasteryLearn(self, groups)
    self.point:Refresh()
    self.page:UpdateLv()
    for _, group in ipairs(groups) do
        local template = DataCenter.MasteryManager:GetTemplate(group)
        local node = self.nodes[group]
        if node then
            node:Refresh()
        end
        for _, nextGroup in ipairs(template.nexts) do
            local nextNode = self.nodes[nextGroup]
            if nextNode then
                nextNode:Refresh()
            end
            local line = self.lines[ToLineKey(group, nextGroup)]
            if line then
                line:Refresh()
            end
        end
    end
    self:SelectGroups({})
end

local function OnMasteryReset(self)
    self:Refresh()
end

UIMasteryHome.OnCreate = OnCreate
UIMasteryHome.OnDestroy = OnDestroy
UIMasteryHome.OnEnable = OnEnable
UIMasteryHome.OnDisable = OnDisable
UIMasteryHome.ComponentDefine = ComponentDefine
UIMasteryHome.ComponentDestroy = ComponentDestroy
UIMasteryHome.DataDefine = DataDefine
UIMasteryHome.DataDestroy = DataDestroy
UIMasteryHome.OnAddListener = OnAddListener
UIMasteryHome.OnRemoveListener = OnRemoveListener

UIMasteryHome.OnBuyPackage = OnBuyPackage
UIMasteryHome.OnPointerDown = OnPointerDown
UIMasteryHome.OnDrag = OnDrag
UIMasteryHome.OnBeginDrag = OnBeginDrag
UIMasteryHome.OnEndDrag = OnEndDrag
UIMasteryHome.HideTips = HideTips

UIMasteryHome.ReInit = ReInit
UIMasteryHome.Refresh = Refresh
UIMasteryHome.TimerAction = TimerAction
UIMasteryHome.Update = Update
UIMasteryHome.UpdateTouch = UpdateTouch
UIMasteryHome.ClampRoot = ClampRoot
UIMasteryHome.MoveRoot = MoveRoot
UIMasteryHome.ScaleRoot = ScaleRoot
UIMasteryHome.CreateAllNodesAndLines = CreateAllNodesAndLines
UIMasteryHome.CreateLine = CreateLine
UIMasteryHome.CreateNode = CreateNode
UIMasteryHome.ClearAllLines = ClearAllLines
UIMasteryHome.ClearAllNodes = ClearAllNodes
UIMasteryHome.SelectGroups = SelectGroups
UIMasteryHome.LookAtNode = LookAtNode
UIMasteryHome.ShowArrowToNode = ShowArrowToNode

UIMasteryHome.OnCloseClick = OnCloseClick
UIMasteryHome.OnNodeClick = OnNodeClick

UIMasteryHome.OnMasteryLearn = OnMasteryLearn
UIMasteryHome.OnMasteryReset = OnMasteryReset

UIMasteryHome.RefreshPage = RefreshPage
UIMasteryHome.ChangePageName = ChangePageName

return UIMasteryHome