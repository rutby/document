---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1.
--- DateTime: 2021/9/15 16:38
---

local base = UIBaseView--Variable
local UIJigsawAreaView = BaseClass("UIJigsawAreaView", base)--Variable
local Localization = CS.GameEntry.Localization
local JigsawAreaBlockItem = require "UI.UIJigsawArea.Component.JigsawAreaBlockItem"
local UICommonItem = require "UI.UICommonItem.UICommonItem"

local closeBtn_path = "safeArea/Back"
local playArea_path = "MainPanel/playArea"
local jigsawImg_path = "MainPanel/playArea/jigsawImg"
local playContainer_path = "MainPanel/playArea/container"
local blockSr_path = "MainPanel/blockList/scrollView"
local blockContent_path = "MainPanel/blockList/scrollView/Viewport/Content"
local dragingContainer_path = "MainPanel/dragingContainer"
local showBgTrigger_path = "MainPanel/showBgTrigger"
local screenLock_path = "lock"
local stars_path = "MainPanel/stars/star/starFill"
local useTime_path = "MainPanel/useTime"
local beginBtn_path = "MainPanel/btnStart"
local beginBtnTxt_path = "MainPanel/btnStart/btnStartTxt"
local beginBtnCost_path = "MainPanel/btnStart/costObj"
local beginBtnCostTxt_path = "MainPanel/btnStart/costObj/costTxt"
local beginBtnCostNum_path = "MainPanel/btnStart/costObj/itemCount"
local infoBtn_path = "MainPanel/infoBtn"
local starReward_path = "MainPanel/starRewards"
local starRewardLv_path = "MainPanel/starRewards/rewardLv/layout"
local starRewardDesc_path = "MainPanel/starRewards/rewardLv/desc"
local starRewardTime_path = "MainPanel/starRewards/rewardLv/time"
local starRewardBg_path = "MainPanel/starRewardBg"

local SrCellHeightOrig = 150
local blockEdgeOrigW = 128
local blockEdgeOrigH = 123
local MapWidth = 7
local MapHeight = 5

local AreaType = {
    PlayArea = 1,
    SrArea = 2,
    OtherArea = 3,
}

local JigsawChipPath = {
    ["UIactivities_pt_pic_01"] = "Assets/Main/Sprites/UI/UIJigsawPuzzle/ptgulu_%s_%s.png",
    ["UIactivities_pt_pic_02"] = "Assets/Main/Sprites/UI/UIJigsawPuzzle/ptben_%s_%s.png",
    ["UIactivities_pt_pic_03"] = "Assets/Main/Sprites/UI/UIJigsawPuzzle/ptyiji_%s_%s.png",
}

local function OnCreate(self)
    base.OnCreate(self)
    self:ComponentDefine()
    self:DataDefine()
    self:InitUI()
end

local function OnDestroy(self)
    self:DelTimer()
    self:ComponentDestroy()
    self:DataDestroy()
    base.OnDestroy(self)
end

local function ComponentDefine(self)
    self.closeBtnN = self:AddComponent(UIButton, closeBtn_path)
    self.closeBtnN:SetOnClick(function()
        self:OnClickCloseBtn()
    end)
    self.playAreaN = self:AddComponent(UIBaseContainer, playArea_path)
    self.dragingContainerN = self:AddComponent(UIBaseContainer, dragingContainer_path)
    self.playContainerN = self:AddComponent(UIBaseContainer, playContainer_path)
    self.jigsawImgN = self:AddComponent(UIImage, jigsawImg_path)
    self.blockSrN = self:AddComponent(UIScrollRect, blockSr_path)
    self.blockContentN = self:AddComponent(UIBaseContainer, blockContent_path)
    self.showTriggerImgN = self:AddComponent(UIImage, showBgTrigger_path)
    self.showImgTriggerN = self:AddComponent(UIEventTrigger, showBgTrigger_path)
    self.showImgTriggerN:OnPointerDown(function(eventData)
        self:OnPointerDown(eventData)
    end)
    self.showImgTriggerN:OnPointerUp(function(eventData)
        self:OnPointerUp(eventData)
    end)
    self.screenLockN = self:AddComponent(UIBaseContainer, screenLock_path)
    self.screenLockN:SetActive(false)
    self.starsTbN = {}
    for i = 1, 3 do
        local tempPath = stars_path .. i
        local tempStar = self:AddComponent(UIBaseContainer, tempPath)
        table.insert(self.starsTbN, tempStar)
    end
    self.useTimeN = self:AddComponent(UIText, useTime_path)
    self.beginBtnN = self:AddComponent(UIButton, beginBtn_path)
    self.beginBtnN:SetOnClick(function()
        self:OnClickBeginPuzzleBtn()
    end)
    self.beginBtnTxtN = self:AddComponent(UIText, beginBtnTxt_path)
    self.beginBtnTxtN:SetLocalText(110058)
    self.beginBtnCostN = self:AddComponent(UIBaseContainer, beginBtnCost_path)
    self.beginBtnCostTxtN = self:AddComponent(UIText, beginBtnCostTxt_path)
    self.beginBtnCostTxtN:SetLocalText(110058)
    self.beginBtnCostNumN = self:AddComponent(UIText, beginBtnCostNum_path)

    self.infoBtnN = self:AddComponent(UIButton, infoBtn_path)
    self.infoBtnN:SetOnClick(function()
        self:ShowStarRewards(true)
    end)
    self.starRewardN = self:AddComponent(UIBaseContainer, starReward_path)
    self.starRewardN:SetActive(false)
    self.starRewardBgBtnN = self:AddComponent(UIButton, starRewardBg_path)
    self.starRewardBgBtnN:SetActive(false)
    self.starRewardBgBtnN:SetOnClick(function()
        self:ShowStarRewards(false)
    end)
    self.starRewardContainerTbN = {}
    self.starRewardLvTbN = {}
    self.starRewardDescTbN = {}
    self.starRewardTimeTbN = {}
    for i = 1, 3 do
        local tempLvPath = starRewardLv_path .. i
        local lvN = self:AddComponent(UIBaseContainer, tempLvPath)
        table.insert(self.starRewardContainerTbN, lvN)

        local tempDescPath = starRewardDesc_path .. i
        local descN = self:AddComponent(UIText, tempDescPath)
        self.starRewardDescTbN[i] = descN

        local tempTimePath = starRewardTime_path .. i
        local timeN = self:AddComponent(UIText, tempTimePath)
        self.starRewardTimeTbN[i] = timeN
    end
    
    self:InitStarRewards()
end

local function ComponentDestroy(self)
    self.closeBtnN = nil
    self.playAreaN = nil
    self.playContainerN = nil
    self.jigsawImgN = nil
    self.blockSrN = nil
    self.blockContentN = nil
    self.showImgTriggerN = nil
    self.screenLockN = nil
    self.useTimeN = nil
    self.beginBtnN = nil
    self.beginBtnTxtN = nil
end

local function DataDefine(self)
    self.models = {}
    self.blockItems = {}
    self.curDragingIndex = nil
    self.isAdjustingPos = false
    self.groupList = {}
    self.curInAreaType = nil
    self.curCostTime = 0
    self.roundStartTime = 0
    
    self.scaleFactor = UIManager:GetInstance():GetScaleFactor()
    self.srCellHeight = SrCellHeightOrig * self.scaleFactor
    self.blockEdgeW = blockEdgeOrigW * self.scaleFactor
    self.blockEdgeH = blockEdgeOrigH * self.scaleFactor
end

local function DataDestroy(self)
    self.models = nil
    self.blockItems = nil
    self.curDragingIndex = nil
    self.isAdjustingPos = nil
    self.groupList = nil
    self.curInAreaType = nil
    self.curCostTime = nil
    self.roundStartTime = nil
    self.jigsawTemplate = nil
    self.jigsawInfo = nil
    self.srCellHeight = nil
    self.blockEdgeW = nil
    self.blockEdgeH = nil
end

local function Update(self)
    self:DoInUpdate()
end

local function OnAddListener(self)
    base.OnAddListener(self)
    self:AddUIListener(EventId.OnJigsawPuzzleEnd, self.ResetPuzzle)
    
end

local function OnRemoveListener(self)
    self:RemoveUIListener(EventId.OnJigsawPuzzleEnd, self.ResetPuzzle)
    base.OnRemoveListener(self)
end


local function DoInUpdate(self)
    
end

local function InitUI(self)
    local activityId, jigsawId = self:GetUserData()
    self.jigsawTemplate = DataCenter.JigsawPuzzleManager:GetJigsawConf(activityId, jigsawId)
    self.jigsawInfo = DataCenter.JigsawPuzzleManager:GetJigsawInfo(activityId, jigsawId)
    self:ResetPuzzle()
end

local function ResetPuzzle(self)
    self:LockScreen(false)

    self.curDragingIndex = nil
    self.isAdjustingPos = false
    self.groupList = {}
    self.curInAreaType = nil
    self.curCostTime = 0
    self.roundStartTime = 0

    local picName = self.jigsawTemplate.jigsawImg or "UIactivities_pt_pic_01"
    local tempPath = string.format("Assets/Main/TextureEx/UIJigsawPuzzle/%s.png", picName)
    self.jigsawImgN:LoadSprite(tempPath)
    self.jigsawImgN:SetActive(true)
    self.jigsawImgN:SetAlpha(1)

    local tempTime = 9999
    if self.jigsawInfo and self.jigsawInfo.bestScoreS > 0 then
        tempTime = self.jigsawInfo.bestScoreS
    end
    local starNum = DataCenter.JigsawPuzzleManager:GetStarNum(self.jigsawTemplate, tempTime)
    for i, v in ipairs(self.starsTbN) do
        v:SetActive(i <= starNum)
    end

    self.roundStartTime = 0

    local challengedTimes, maxTimes, perCost = DataCenter.JigsawPuzzleManager:GetFreeChallengeTimes(self.jigsawTemplate.activityId)
    self.beginBtnN:SetActive(true)
    if challengedTimes >= maxTimes then
        self.beginBtnTxtN:SetActive(false)
        self.beginBtnCostN:SetActive(true)
        self.beginBtnCostNumN:SetText(perCost)
    else
        self.beginBtnTxtN:SetActive(true)
        self.beginBtnCostN:SetActive(false)
    end
        
    self:DelTimer()
    self.useTimeN:SetActive(false)

    self:SetBlocksDestroy()
end

local function BeginPuzzle(self)
    self.curCostTime = 0
    
    self:InitBlockItems()
    
    self.beginBtnN:SetActive(false)
    self.useTimeN:SetActive(true)

    self.jigsawImgN:SetAlpha(0.5)
    self.jigsawImgN:SetActive(false)

    local curTime = UITimeManager:GetInstance():GetServerTime()
    self.roundStartTime = curTime
    self:AddTimer()
    self:SetRemainTime()
end

local function InitBlockItems(self)
    self.models = {}
    self.blockItems = {}
    
    self.blockList = self:GetBlockList()

    local picName = self.jigsawTemplate.jigsawImg or "UIactivities_pt_pic_01"
    
    local chipPath = JigsawChipPath[picName]
    for i = 1, #self.blockList do
        self.models[i] = self:GameObjectInstantiateAsync(UIAssets.JigsawAreaBlockItem, function(request)
            if request.isError then
                return
            end
            local go = request.gameObject;
            go.gameObject:SetActive(true)
            go.transform:SetParent(self.blockContentN.transform)
            go.transform:DOScale(Vector3.New(0.7, 0.7, 1), 0.1)--:Set_localScale(0.7, 0.7, 1)
            --go.transform:Set_localPosition(0, 0, 0)
            go.name = self.blockList[i]
            local cell = self.blockContentN:AddComponent(JigsawAreaBlockItem,go.name)
            cell:SetItem(self.blockList[i], chipPath)
            self.blockItems[self.blockList[i]] = cell
        end)
    end
end

local function SetBlocksDestroy(self)
    self.blockContentN:RemoveComponents(JigsawAreaBlockItem)
    if next(self.models) then
        for k,v in pairs(self.models) do
            if v ~= nil then
                self:GameObjectDestroy(v)
            end
        end
    end
end


local function AddTimer(self)
    self.TimerAction = function()
        self:SetRemainTime()
    end

    if self.timer == nil then
        self.timer = TimerManager:GetInstance():GetTimer(1, self.TimerAction , self, false,false,false)
    end
    self.timer:Start()
end

local function SetRemainTime(self)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local passedTime = curTime - self.roundStartTime
    self.curCostTime = math.modf(passedTime / 1000)
    self.useTimeN:SetText(UITimeManager:GetInstance():MilliSecondToFmtString(passedTime))
end

local function DelTimer(self)
    if self.timer ~= nil then
        self.timer:Stop()
        self.timer = nil
    end
end

local function GetBlockList(self)
    local retList = {}
    for i = 1, 35 do
        table.insert(retList, i)
    end
    for i = 1, #retList do
        local randNum = math.random(1, 35)
        retList[i], retList[randNum] = retList[randNum], retList[i]
    end
    return retList
end

local function OnDragItem(self, eventData)
    if not self.curDragingIndex then
        self.blockSrN:OnDrag(eventData)
    else
        self:SetBlock2DragingPos(eventData, self.curDragingIndex)
    end
end

local function OnBeginDragItem(self, eventData, tempBlockIndex)
    self.jigsawImgN:SetActive(false)
    self.blockSrN:OnBeginDrag(eventData)
    local tempArea, siblingIndex = self:GetDragingAreaType(eventData, tempBlockIndex)
    self.curInAreaType = tempArea
end

local function OnEndDragItem(self, eventData)
    if self.curDragingIndex then
        local tempArea = self:GetDragingAreaType(eventData, self.curDragingIndex)
        if tempArea ~= AreaType.SrArea then
            self:AutoAdjustBlockPos(eventData, self.curDragingIndex)
        else
            self:TryRemoveFromGroup(self.curDragingIndex)
            self.blockItems[self.curDragingIndex]:SetPosIndex(nil)
        end
    end
    CS.UnityEngine.UI.LayoutRebuilder.ForceRebuildLayoutImmediate(self.blockContentN.transform)
    self:SetDragingBlockIndex(nil)
    self.curInAreaType = nil
    self.blockSrN:OnEndDrag(eventData)

end

local function SetDragingBlockIndex(self, tempBlockIndex)
    self.curDragingIndex = tempBlockIndex
end

local function SetBlock2DragingPos(self, eventData, blockIndex)
    local isInGroup = self:SetGroupBlockDragingPos(eventData, blockIndex)
    
    local tempArea, siblingIndex = self:GetDragingAreaType(eventData, blockIndex)
    if self.curInAreaType ~= tempArea then
        if not self.curInAreaType or self.curInAreaType == AreaType.SrArea then
            if not isInGroup then
                self.blockItems[blockIndex].transform:SetParent(self.playContainerN.transform)
                self.blockItems[blockIndex].transform:DOScale(Vector3.New(1, 1, 1), 0.1)--:Set_localScale(1, 1, 1)
                self.blockItems[blockIndex].transform:SetAsLastSibling()
            else
                local _, groupTb = self:CheckIfBlockInGroup(blockIndex)
                if groupTb then
                    for i, v in ipairs(groupTb) do
                        self.blockItems[v].transform:SetAsLastSibling()
                    end
                end
            end
        elseif tempArea == AreaType.SrArea then
            if not isInGroup then
                self.blockItems[blockIndex].transform:SetParent(self.blockContentN.transform)
                self.blockItems[blockIndex].transform:DOScale(Vector3.New(0.7, 0.7, 1), 0.1)--Set_localScale(0.7, 0.7, 1)
                self.blockItems[blockIndex].transform:SetSiblingIndex(siblingIndex)
            end
        end
    elseif tempArea == AreaType.SrArea then
        self.blockItems[blockIndex].transform:SetSiblingIndex(siblingIndex)
    end
    self.curInAreaType = tempArea
end

local function SetGroupBlockDragingPos(self, eventData, blockIndex)
    local isInGroup, groupTb = self:CheckIfBlockInGroup(blockIndex)
    if isInGroup then
        for i, v in ipairs(groupTb) do
            local tempPosX, tempPosY = self:GetPosByIndexOffset(blockIndex, v, eventData.position.x, eventData.position.y)
            self.blockItems[v]:SetPositionXYZ(tempPosX, tempPosY, eventData.position.z)
            --self.blockItems[v].transform:SetAsLastSibling()
        end
    else
        self.blockItems[blockIndex]:SetPosition(eventData.position)--.x, eventData.position.y, eventData.position.z)
        --self.blockItems[blockIndex].transform:SetAsLastSibling()
    end
    return isInGroup
end

local function GetPosByIndexOffset(self, origIndex, targetIndex, origX, origY)
    local origIndexX = (origIndex - 1) % MapWidth +1
    local origIndexY = math.ceil(origIndex / MapWidth)
    local targetIndexX = (targetIndex - 1) % MapWidth + 1
    local targetIndexY = math.ceil(targetIndex / MapWidth)
    local posX = (targetIndexX - origIndexX) * self.blockEdgeW + origX
    local posY = (targetIndexY - origIndexY) * self.blockEdgeH + origY
    return posX, posY
end

local function CheckIfBlockInGroup(self, blockIndex)
    for i, v in ipairs(self.groupList) do
        if type(v) == "table" then
            for m, n in ipairs(v) do
                if n == blockIndex and #v > 1 then
                    return true, v
                end
            end
        end
    end
    return false
end

local function GetDragingAreaType(self, eventData, tempBlockIndex)
    local retType = AreaType.OtherArea
    local siblingIndex = 0
    local isInSr, tempIndex = self:CheckIfBlockInSr(eventData, tempBlockIndex)
    if isInSr then
        retType = AreaType.SrArea
        siblingIndex = tempIndex
    elseif self:CheckIfBlockInPlayArea(eventData, tempBlockIndex) then
        retType = AreaType.PlayArea
    end
    return retType, siblingIndex
end

local function CheckIfBlockInSr(self, eventData, tempBlockIndex)
    local isInBlockList = false
    local siblingIndex = 0
    --self.blockSrN.rectTransform.rect.

    local srPos = self.blockSrN.transform.position
    local xMin = srPos.x
    local yMin = srPos.y
    local xMax = xMin + self.blockSrN.rectTransform.rect.width * self.scaleFactor
    local yMax = yMin + self.blockSrN.rectTransform.rect.height * self.scaleFactor
    if eventData.position.x > xMin and eventData.position.y > yMin and eventData.position.x < xMax
            and eventData.position.y < yMax then
        isInBlockList = true

        local listPos = self.blockContentN.transform.localPosition.y + math.abs(self.blockSrN.transform.position.y + self.blockSrN.rectTransform.rect.height * self.scaleFactor - eventData.position.y)
        siblingIndex = math.modf((listPos - 5) / self.srCellHeight)
    end

    return isInBlockList, siblingIndex
end

--只要不是在滑动区域 return true
local function CheckIfBlockInPlayArea(self, eventData, tempBlockIndex)
    local playAreaPos = self.playContainerN.transform.position
    local xMin = playAreaPos.x
    local yMin = playAreaPos.y
    local xMax = xMin + self.playContainerN.rectTransform.rect.width * self.scaleFactor
    local yMax = yMin + self.playContainerN.rectTransform.rect.height * self.scaleFactor
    if eventData.position.x > xMin and eventData.position.x < xMax and eventData.position.y > yMin
        and eventData.position.y < yMax then
        return true
    end
    return false
end

local function AutoAdjustBlockPos(self, eventData, tempBlockIndex)
    local tempPointIndex, targetX, targetY = self:GetNearestPlayAreaPosIndex(eventData, tempBlockIndex)
    --local resetLayer = tempBlockIndex == tempPointIndex
    self.blockItems[self.curDragingIndex]:SetPosIndex(tempPointIndex)
    self.blockItems[self.curDragingIndex]:SetPositionXYZ(targetX, targetY)

    local isRightPos = self.curDragingIndex == tempPointIndex
    if isRightPos then
        local oldInGroup, oldGroup = self:CheckIfBlockInGroup(tempBlockIndex)
        if oldInGroup then
            for i, v in ipairs(oldGroup) do
                self.blockItems[v]:PlayCompleteEff()
            end
        else
            self.blockItems[tempBlockIndex]:PlayCompleteEff()
        end
    end
    
    local isInGroup, groupTb = self:CheckIfBlockInGroup(tempBlockIndex)
    if isInGroup then
        local tempIndexX = (tempBlockIndex - 1) % MapWidth + 1
        local tempIndexY = math.ceil(tempBlockIndex / MapWidth)
        for i, v in ipairs(groupTb) do
            local vIndexX = (v - 1) % MapWidth + 1
            local vIndexY = math.ceil(v / MapWidth)
            local xIndexOffset = vIndexX - tempIndexX
            local yIndexOffset = vIndexY - tempIndexY
            local posX = targetX + xIndexOffset * self.blockEdgeW
            local posY = targetY + yIndexOffset * self.blockEdgeH
            self.blockItems[v]:SetPosIndex(v - self.curDragingIndex + tempPointIndex)
            self.blockItems[v]:SetPositionXYZ(posX, posY)
            if isRightPos then
                self.blockItems[v].transform:SetSiblingIndex(0)
            end
        end
    else
        if isRightPos then
            self.blockItems[tempBlockIndex].transform:SetSiblingIndex(0)
        end
    end
    
    self:CheckGroups(tempBlockIndex, tempPointIndex, not isRightPos)
end

local function GetNearestPlayAreaPosIndex(self, eventData, tempBlockIndex)
    local origPos = self.playContainerN.transform.position;
    local xMin = origPos.x
    local yMin = origPos.y
    local xMax = xMin + self.playContainerN.rectTransform.rect.width * self.scaleFactor
    local yMax = yMin + self.playContainerN.rectTransform.rect.height * self.scaleFactor
    
    local xOffsetL, xOffsetR, yOffsetB, yOffsetT = self:GetGroupsOffset(tempBlockIndex)
    xMin = xMin + xOffsetL * self.blockEdgeW
    xMax = xMax - xOffsetR * self.blockEdgeW
    yMin = yMin + yOffsetB * self.blockEdgeH
    yMax = yMax - yOffsetT * self.blockEdgeH
    
    local tempX = eventData.position.x
    local tempY = eventData.position.y
    tempX = tempX < xMin and (xMin + 5) or tempX
    tempX = tempX > xMax and (xMax - 5) or tempX
    tempY = tempY < yMin and (yMin + 5) or tempY
    tempY = tempY > yMax and (yMax - 5) or tempY
    local pointIndexX = math.ceil((tempX - origPos.x) / self.blockEdgeW)
    local pointIndexY = math.ceil((tempY - origPos.y) / self.blockEdgeH)
    local pointIndex =  MapWidth * (pointIndexY - 1) + pointIndexX
    
    local targetPosX = pointIndexX * self.blockEdgeW - (self.blockEdgeW / 2) + origPos.x
    local targetPosY = pointIndexY * self.blockEdgeH - (self.blockEdgeH / 2) + origPos.y
    return pointIndex, targetPosX, targetPosY
end

local function GetGroupsOffset(self, tempBlockIndex)
    local xOffsetL = 0
    local xOffsetR = 0
    local yOffsetB = 0
    local yOffsetT = 0
    
    local blockPointX = (tempBlockIndex - 1) % MapWidth + 1
    local blockPointY = math.ceil(tempBlockIndex / MapWidth)
    
    local isInGroup, groupTb = self:CheckIfBlockInGroup(tempBlockIndex)
    if isInGroup then
        for i, index in ipairs(groupTb) do
            local tempX = (index - 1) % MapWidth + 1
            local tempY = math.ceil(index / MapWidth)
            local tempXOffset = tempX - blockPointX
            local tempYOffset = tempY - blockPointY
            xOffsetL = tempXOffset < xOffsetL and tempXOffset or xOffsetL
            xOffsetR = tempXOffset > xOffsetR and tempXOffset or xOffsetR
            yOffsetB = tempYOffset < yOffsetB and tempYOffset or yOffsetB
            yOffsetT = tempYOffset > yOffsetT and tempYOffset or yOffsetT
        end
    end
    return math.abs(xOffsetL), math.abs(xOffsetR), math.abs(yOffsetB), math.abs(yOffsetT)
end

local function TryRemoveFromGroup(self, tempBlockIndex)
    local stop = false
    for i, v in ipairs(self.groupList) do
        if type(v) == "table" then
            for m, n in ipairs(v) do
                if n == tempBlockIndex then
                    if #v == 1 then
                        table.remove(self.groupList, i)
                    else
                        table.remove(v, m)
                    end
                    stop = true
                    break
                end
            end
        else
            if v == tempBlockIndex then
                table.remove(self.groupList, i)
                stop = true
                break
            end
        end
        if stop then
            break
        end
    end
end

local function CheckGroups(self, blockIndex, pointIndex, needTween)
    local selfGroup = {}
    for i, v in ipairs(self.groupList) do
        if #selfGroup == 0 then
            if type(v) == "table" then
                for m, n in ipairs(v) do
                    if n == blockIndex then
                        selfGroup = v
                        table.remove(self.groupList, i)
                        break
                    end
                end
            else
                if v == blockIndex then
                    selfGroup = {blockIndex}
                    table.remove(self.groupList, i)
                    break
                end
            end
        end
    end
    if #selfGroup == 0 then
        table.insert(selfGroup, blockIndex)
    end

    local neighbors = {}
    local doColorTb = {}
    for p, qBlockIndex in ipairs(selfGroup) do
        local qPointIndex = self.blockItems[qBlockIndex]:GetCurPointIndex()
        for i = #self.groupList, 1, -1 do
            local v = self.groupList[i]
            if type(v) == "table" then
                for m, n in ipairs(v) do
                    local pIndex = self.blockItems[n]:GetCurPointIndex()
                    if self:CheckIfIsNeighBor(n, pIndex, qBlockIndex, qPointIndex) then
                        local nearTb = self:GetNearTb(blockIndex, v)
                        table.insertto(doColorTb, nearTb)
                        table.insertto(neighbors, v)
                        table.remove(self.groupList, i)
                        break
                    end
                end
            else
                local vpIndex = self.blockItems[v]:GetCurPointIndex()
                if self:CheckIfIsNeighBor(v, vpIndex, qBlockIndex, qPointIndex) then
                    table.insert(doColorTb, v)
                    table.insert(neighbors, v)
                    table.remove(self.groupList, i)
                end
            end
        end
    end

    if #doColorTb > 0 then
        table.insert(doColorTb, blockIndex)
    end

    if needTween then
        for i, v in ipairs(doColorTb) do
            self.blockItems[v]:TweenColor()
        end
    end
    
    table.insertto(selfGroup, neighbors)
    table.insert(self.groupList, selfGroup)

    if #self.groupList == 1 and #self.groupList[1] == #self.blockList then
        self:FinishJigsaw()
    end
end

local function GetNearTb(self, pointIndex, fromTb)
    local retT = {}
    for i, v in ipairs(fromTb) do
        local abs = math.abs(pointIndex - v)
        if abs == 1 then
            if (pointIndex % MapWidth == 0 and v == pointIndex + 1)
                or v % MapWidth == 0 and pointIndex == v + 1 then
            else
                table.insert(retT, v)
            end
        elseif abs == MapWidth then
            table.insert(retT, v)
        end
    end
    return retT
end

local function FinishJigsaw(self)
    self:LockScreen(true)
    DataCenter.JigsawPuzzleManager:RequestFinishJigsaw(self.jigsawTemplate.activityId, self.jigsawTemplate.id, self.curCostTime)
end

local function LockScreen(self, lock)
    self.screenLockN:SetActive(lock)
end

local function CheckIfIsNeighBor(self, blockIndexA, pointIndexA, blockIndexB, pointIndexB)
    if blockIndexA - blockIndexB == pointIndexA - pointIndexB then
        local offset = math.abs(blockIndexA - blockIndexB)
        if offset == 1 then
            if (blockIndexA % MapWidth == 0 and blockIndexB == blockIndexA + 1) 
                    or (blockIndexB % MapWidth == 0 and blockIndexA == blockIndexB + 1) then
                return false
            else
                return true
            end
        elseif offset == MapWidth then
            return true
        end
    end
    return false
end

local function OnPointerDown(self, eventData)
    if not self.roundStartTime or self.roundStartTime == 0 then
        return
    end
    self.showTriggerImgN:LoadSprite("Assets/Main/Sprites/UI/UIJigsawPuzzle/UIactivities_pt_eye_1.png")
    if not self.curDragingIndex then
        self.jigsawImgN:SetActive(true)
    end
end

local function OnPointerUp(self, eventData)
    if not self.roundStartTime or self.roundStartTime == 0 then
        return
    end
    self.showTriggerImgN:LoadSprite("Assets/Main/Sprites/UI/UIJigsawPuzzle/UIactivities_pt_eye_0.png")
    self.jigsawImgN:SetActive(false)
end


local function ShowStarRewards(self, isShow)
    self.starRewardBgBtnN:SetActive(isShow)

    if isShow then
        local jigsawInfo = self.jigsawInfo
        self.starRewardN:SetActive(true)
        for i = 1, 3 do
            local tempRewards = jigsawInfo.starRewards[i]
            local tempRewardItems = self.starRewardLvTbN[i]
            for j, v in ipairs(tempRewardItems) do
                if j <= #tempRewards then
                    v:SetActive(true)
                    local reward = tempRewards[j]
                    local newReward = {}
                    newReward.rewardType = reward.type
                    if type(reward.value) == "table" then
                        newReward.itemId = reward.value.id
                        newReward.count = reward.value.num
                    else
                        newReward.count = reward.value
                    end
                    v:ReInit(newReward)
                else
                    v:SetActive(false)
                end
            end
        end

        local tempStar = DataCenter.JigsawPuzzleManager:GetStarNumByTime(self.jigsawTemplate.activityId, self.jigsawTemplate.id, jigsawInfo.bestScoreS)
        for i, v in ipairs(self.starRewardDescTbN) do
            if i <= tempStar then
                v:SetText(Localization:GetString("372354"))
            else
                v:SetText("")
            end
        end

        local jigsawConf = self.jigsawTemplate
        for i, v in ipairs(self.starRewardTimeTbN) do
            if i <= #jigsawConf.starNeedTimeS then
                self.starRewardTimeTbN[i]:SetText(UITimeManager:GetInstance():GetFormattedTime(jigsawConf.starNeedTimeS[i]))
            else
                self.starRewardTimeTbN[i]:SetText("")
            end
        end
    else
        self.starRewardN:SetActive(false)
    end
end


local function InitStarRewards(self)
    self:SetAllCellDestroy()

    self.models = {}
    for i = 1, 3 do
        self.starRewardLvTbN[i] = {}
        for j = 1, 3 do
            self.models[(i - 1) * 3 + j] = self:GameObjectInstantiateAsync(UIAssets.UICommonItem, function(request)
                if request.isError then
                    return
                end
                local go = request.gameObject
                go:SetActive(true)
                go.transform:SetParent(self.starRewardContainerTbN[i].transform)
                go.transform:Set_localScale(0.6, 0.6, 1)
                go.transform:SetAsLastSibling()
                go.name = tostring(j)
                local rewardItem = self.starRewardContainerTbN[i]:AddComponent(UICommonItem, go.name)
                table.insert(self.starRewardLvTbN[i], rewardItem)
            end)
        end
    end
end

local function SetAllCellDestroy(self)
    for i = 1, 3 do
        self.starRewardContainerTbN[i]:RemoveComponents(UICommonItem)
    end
    if self.models~=nil then
        for k,v in pairs(self.models) do
            if v ~= nil then
                self:GameObjectDestroy(v)
            end
        end
    end
end



local function OnClickBeginPuzzleBtn(self)
    DataCenter.JigsawPuzzleManager:RequestBeginChallenge(self.jigsawTemplate.activityId, self.jigsawTemplate.id)
    self:BeginPuzzle()
end

local function OnClickCloseBtn(self)
    self.ctrl:CloseSelf()
end


UIJigsawAreaView.OnCreate = OnCreate 
UIJigsawAreaView.OnDestroy = OnDestroy
UIJigsawAreaView.OnAddListener = OnAddListener
UIJigsawAreaView.OnRemoveListener = OnRemoveListener
UIJigsawAreaView.ComponentDefine = ComponentDefine
UIJigsawAreaView.ComponentDestroy = ComponentDestroy
UIJigsawAreaView.DataDefine = DataDefine
UIJigsawAreaView.DataDestroy = DataDestroy
UIJigsawAreaView.Update = Update

UIJigsawAreaView.DoInUpdate = DoInUpdate
UIJigsawAreaView.InitUI = InitUI
UIJigsawAreaView.ResetPuzzle = ResetPuzzle
UIJigsawAreaView.BeginPuzzle = BeginPuzzle
UIJigsawAreaView.InitBlockItems = InitBlockItems
UIJigsawAreaView.GetBlockList = GetBlockList
UIJigsawAreaView.SetBlocksDestroy = SetBlocksDestroy
UIJigsawAreaView.AddTimer = AddTimer
UIJigsawAreaView.SetRemainTime = SetRemainTime
UIJigsawAreaView.DelTimer = DelTimer
UIJigsawAreaView.OnDragItem = OnDragItem
UIJigsawAreaView.OnBeginDragItem = OnBeginDragItem
UIJigsawAreaView.OnEndDragItem = OnEndDragItem
UIJigsawAreaView.AutoAdjustBlockPos = AutoAdjustBlockPos
UIJigsawAreaView.SetDragingBlockIndex = SetDragingBlockIndex
UIJigsawAreaView.CheckIfBlockInPlayArea = CheckIfBlockInPlayArea
UIJigsawAreaView.SetBlock2DragingPos = SetBlock2DragingPos
UIJigsawAreaView.GetNearestPlayAreaPosIndex = GetNearestPlayAreaPosIndex
UIJigsawAreaView.TryRemoveFromGroup = TryRemoveFromGroup
UIJigsawAreaView.CheckGroups = CheckGroups
UIJigsawAreaView.GetGroupsOffset = GetGroupsOffset
UIJigsawAreaView.SetGroupBlockDragingPos = SetGroupBlockDragingPos
UIJigsawAreaView.CheckIfBlockInGroup = CheckIfBlockInGroup
UIJigsawAreaView.GetDragingAreaType = GetDragingAreaType
UIJigsawAreaView.CheckIfBlockInSr = CheckIfBlockInSr
UIJigsawAreaView.GetPosByIndexOffset = GetPosByIndexOffset
UIJigsawAreaView.CheckIfIsNeighBor = CheckIfIsNeighBor
UIJigsawAreaView.GetNearTb = GetNearTb
UIJigsawAreaView.FinishJigsaw = FinishJigsaw
UIJigsawAreaView.LockScreen = LockScreen
UIJigsawAreaView.OnPointerDown = OnPointerDown
UIJigsawAreaView.OnPointerUp = OnPointerUp
UIJigsawAreaView.ShowStarRewards = ShowStarRewards
UIJigsawAreaView.InitStarRewards = InitStarRewards
UIJigsawAreaView.SetAllCellDestroy = SetAllCellDestroy
UIJigsawAreaView.OnClickCloseBtn = OnClickCloseBtn
UIJigsawAreaView.OnClickBeginPuzzleBtn = OnClickBeginPuzzleBtn

return UIJigsawAreaView
