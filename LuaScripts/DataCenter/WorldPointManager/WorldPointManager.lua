---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Imaginaerum.
--- DateTime: 18/3/2024 下午2:10
---
local WorldBasePointObject = require "DataCenter.WorldPointManager.WorldBasePointObject"
local WorldResObject = require "DataCenter.WorldPointManager.WorldResObject"
local WorldBuildObject = require "DataCenter.WorldPointManager.WorldBuildObject"
local WorldSampleObject = require "DataCenter.WorldPointManager.WorldSampleObject"
local WorldRescueObject = require "DataCenter.WorldPointManager.WorldRescueObject"
local WorldGarbageObject = require "DataCenter.WorldPointManager.WorldGarbageObject"
local WorldHighSpeedCollectObject = require "DataCenter.WorldPointManager.WorldHighSpeedCollectObject"
local WorldExploreObject = require "DataCenter.WorldPointManager.WorldExploreObject"
local WorldHeroDispatchTaskObject = require"DataCenter.WorldPointManager.WorldHeroDispatchTaskObject"
local WorldMonsterObject = require "DataCenter.WorldPointManager.WorldMonsterObject"
local WorldPointManager = BaseClass("WorldPointManager");
local TaskType = {
    Create = 1,
    Remove = 2,
    Points = 3,
    UpdateTitles = 4,
}

local ViewLevelRange ={
    {x=25,y=40},
    {x=70,y=140},
    {x=100000,y=100000},
    {x=100000,y=100000},
}
local LodRequestRange ={
    {x=6,y=6},
    {x=18,y=18},
    {x=100000,y=100000},
    {x=100000,y=100000},
}
local AlliancePointLod = 5;
local SelfPointLod = 8;
local OtherPointLod = 4;

function WorldPointManager:__init()
    self.allViewPoints ={}
    self.AllianceMemberDic = {}
    self.removePointId = {}
    self.dragonPointDic = {}--key:uuid,value = pointIndex
    self.uuidInfoMap = {} --世界点--key:uuid,value = pointIndex
    self.uuidInfoDesertMap = {} --key:uuid,value = pointIndex
    self.messageQueue = {}
    self.time = 0
    self.syncTime = 0
    self.pointMessageArray = {}
    self.allianceMessageArray = {}
    self.removePointIdMessageArray = {}
    self.desertMessageArray = {}
    self.startViewRequest = false
    self.toBuildList = {}
    self.outOfViewPoints = {}
    self.keysToRemove = {}
    self.needDestoryBuild = {}
    self.allObj = {}
    self.lodLv = 1
    self.curCameraTarget = nil
    self.reqPos = nil
    self.lastDelPos = nil 
    self.lastDelSvLod = nil
    self.isInit = false
    self.on_LodChanged = function(msg) self:OnLodChanged(msg) end
    self.on_CameraChange = function(msg) self:OnCameraChange(msg) end
end

function WorldPointManager:__delete()
    self:DestroyAll()
    self.allViewPoints ={}
    self.AllianceMemberDic = {}
    self.removePointId = {}
    self.dragonPointDic = {}--key:uuid,value = pointIndex
    self.uuidInfoMap = {} --世界点--key:uuid,value = pointIndex
    self.uuidInfoDesertMap = {} --key:uuid,value = pointIndex
    self.messageQueue = {}
    self.time = 0
    self.syncTime = 0
    self.pointMessageArray = {}
    self.allianceMessageArray = {}
    self.removePointIdMessageArray = {}
    self.desertMessageArray = {}
    self.startViewRequest = false
    self.toBuildList = {}
    self.outOfViewPoints = {}
    self.keysToRemove = {}
    self.needDestoryBuild = {}
    self.allObj = {}
    self.lodLv = 1
    self.curCameraTarget = nil
    self.reqPos = nil
    self.lastDelPos = nil
    self.lastDelSvLod = nil
    self.isInit = false
end

function WorldPointManager:StartUp()
    self.allViewPoints ={}
    self.AllianceMemberDic = {}
    self.removePointId = {}
    self.dragonPointDic = {}--key:uuid,value = pointIndex
    self.uuidInfoMap = {} --世界点--key:uuid,value = pointIndex
    self.uuidInfoDesertMap = {} --key:uuid,value = pointIndex
    self.messageQueue = {}
    self.time = 0
    self.syncTime = 0
    self.pointMessageArray = {}
    self.allianceMessageArray = {}
    self.removePointIdMessageArray = {}
    self.desertMessageArray = {}
    self.startViewRequest = false
    self.toBuildList = {}
    self.outOfViewPoints = {}
    self.keysToRemove = {}
    self.needDestoryBuild = {}
    self.allObj = {}
    self.lodLv = 1
    self.curCameraTarget = nil
    self.lastDelPos = nil
    self.lastDelSvLod = nil
    self:AddListener()
    self:EnableUpdate()
    self.isInit = true
end
function WorldPointManager:Close()
    self:DestroyAll()
    self.isInit = false
    self:RemoveListener()
    self:DisableUpdate()
    self.allViewPoints ={}
    self.AllianceMemberDic = {}
    self.removePointId = {}
    self.dragonPointDic = {}--key:uuid,value = pointIndex
    self.uuidInfoMap = {} --世界点--key:uuid,value = pointIndex
    self.uuidInfoDesertMap = {} --key:uuid,value = pointIndex
    self.messageQueue = {}
    self.time = 0
    self.syncTime = 0
    self.pointMessageArray = {}
    self.allianceMessageArray = {}
    self.removePointIdMessageArray = {}
    self.desertMessageArray = {}
    self.startViewRequest = false
    self.toBuildList = {}
    self.outOfViewPoints = {}
    self.keysToRemove = {}
    self.needDestoryBuild = {}
    self.allObj = {}
    self.lodLv = 1
    self.curCameraTarget = nil
    self.lastDelPos = nil
    self.lastDelSvLod = nil
end

function WorldPointManager:AddListener()
    EventManager:GetInstance():AddListener(EventId.ChangeCameraLod, self.on_LodChanged)
    --EventManager:GetInstance():AddListener(EventId.WORLD_CAMERA_CHANGE_POINT, self.on_CameraChange)
end

function WorldPointManager:RemoveListener()
    EventManager:GetInstance():RemoveListener(EventId.ChangeCameraLod, self.on_LodChanged)
    --EventManager:GetInstance():RemoveListener(EventId.WORLD_CAMERA_CHANGE_POINT, self.on_CameraChange)
end

function WorldPointManager:EnableUpdate()
    self:DisableUpdate()
    self.__update_handle = function() self:Update() end
    UpdateManager:GetInstance():AddUpdate(self.__update_handle)
end
function WorldPointManager:DisableUpdate()
    if self.__update_handle then
        UpdateManager:GetInstance():RemoveUpdate(self.__update_handle)
        self.__update_handle = nil
    end
end

function WorldPointManager:IsBusy()
    return (UITimeManager:GetInstance():GetServerTime()-self.time) >= 5
end
function WorldPointManager:IsSyncBusy()
    return (UITimeManager:GetInstance():GetServerTime()-self.syncTime) >= 10
end

function WorldPointManager:StartViewRequest()
    self.startViewRequest = true
end
function WorldPointManager:Update()
    if self.isInit ==false then
        return
    end
    self.time = UITimeManager:GetInstance():GetServerTime()
    self:UpdateViewRequest()
    self:ParseServerDataAsync()
    self.syncTime = UITimeManager:GetInstance():GetServerTime()
    self:BuildAsync()
    self:DeleteOutOfView()
end

---request
function WorldPointManager:OnCameraChange(msg)
    self.curCameraTarget = CS.SceneManager.World.CurTarget
end
function WorldPointManager:OnLodChanged(lod)
    if self.lodLv~=lod then
        self.lodLv = lod
        self:UpdateViewRequest(true)
    end
end
function WorldPointManager:UpdateViewRequest(isForce)
    if self.isInit ==false then
        return
    end
    self.curCameraTarget = CS.SceneManager.World.CurTarget
    local svLod = self:GetServerLod(self.lodLv)
    local curTilePos = SceneUtils.WorldToTile(self.curCameraTarget, ForceChangeScene.World)
    if isForce == true then
        self:SendViewRequest(curTilePos,svLod,LuaEntry.Player:GetSelfServerId())
        return
    end
    if self.reqPos ==nil then
        return 
    end
    if self.startViewRequest ==false then
        return
    end
    local deltaX = math.abs(self.reqPos.x-curTilePos.x)
    local deltaY = math.abs(self.reqPos.y-curTilePos.y)
    local range = LodRequestRange[svLod+1]
    local req = (deltaX>range.x) or (deltaY>range.y)
    if req then
        self:SendViewRequest(curTilePos,svLod,LuaEntry.Player:GetSelfServerId())
    end
end
function WorldPointManager:SendViewRequest(tilePos,viewLevel,serverId)
    if viewLevel>2 then
        viewLevel = 2
    end
    tilePos = SceneUtils.ClampTilePos(tilePos)
    local realReqServerId = serverId
    if LuaEntry.Player:IsInSelfServer()==false then
        realReqServerId = LuaEntry.Player:GetCrossServerId()
    end
    local worldId = LuaEntry.Player:GetCurWorldId()
    if LuaEntry.Player.serverType == ServerType.DRAGON_BATTLE_FIGHT_SERVER or LuaEntry.Player.serverType == ServerType.CROSS_THRONE then
        viewLevel = 0
    end
    SFSNetwork.SendMessage(MsgDefines.GetViewLevelWorldInfo,tilePos.x,tilePos.y,0,viewLevel,realReqServerId,worldId)
    self.reqPos = tilePos
end
function WorldPointManager:GetServerLod(lod)
    if lod>=6 then
        return 2
    end
    if lod>=3 then
        return 1
    end
    return 0
end


---messageParse
function WorldPointManager:HandleViewPointsReply(message)
    if message ==nil then
        return
    end
    self:PushMessageQueue(message,TaskType.Points)
end
function WorldPointManager:HandleViewUpdateNotify(message)
    if message ==nil then
        return
    end
    local tp = message["type"]
    if tp == "create" or tp =="change" or tp == "relocate" then
        self:PushMessageQueue(message,TaskType.Create)
    elseif tp == "remove" or tp == "foldUp" then
        self:PushMessageQueue(message,TaskType.Remove)
    end
end
function WorldPointManager:HandleViewTileUpdateNotify(message)
    if message ==nil then
        return
    end
    local tp = message["type"]
    if  tp =="update" then
        self:PushMessageQueue(message,TaskType.UpdateTitles)
    end
end
function WorldPointManager:PopMessageQueue()
    if #self.messageQueue == 0 then
        return nil
    end
    return table.remove(self.messageQueue, 1)
end
function WorldPointManager:PushMessageQueue(message,type)
    if type == TaskType.Points then --world.get 消息返回时删掉所有队列
        self.pointMessageArray = {}
        self.allianceMessageArray = {}
        self.desertMessageArray = {}
        local tempList = {}
        for i=1,#self.messageQueue do
            if self.messageQueue[i].t == TaskType.Remove then
                table.insert(tempList,self.messageQueue[i])
            end
        end
        self.messageQueue = tempList
    end
    table.insert(self.messageQueue,{msg = message,t = type})
end
function WorldPointManager:ParseServerDataAsync()
    local parseFinish,count = self:DoParse()
    if parseFinish == true then
        while #self.messageQueue > 0 do
            local tab = self:PopMessageQueue()
            if tab ~= nil then
                local parseType = tab.t
                local message = tab.msg
                if parseType == TaskType.Points then
                    local pTemp  = message["points"]
                    if pTemp ~=nil then
                        self.pointMessageArray = pTemp
                    end
                    local dTemp = message["deserts"]
                    if dTemp~=nil then
                        self.desertMessageArray = dTemp
                    end
                    local aTemp = message["alInfos"]
                    if aTemp ~=nil then
                        self.allianceMessageArray = aTemp
                    end
                elseif parseType == TaskType.Create then
                    local pTemp  = message["points"]
                    if pTemp ~=nil then
                        self.pointMessageArray = pTemp
                    end
                elseif parseType == TaskType.UpdateTitles then
                    local dTemp = message["deserts"]
                    if dTemp~=nil then
                        self.desertMessageArray = dTemp
                    end
                elseif parseType == TaskType.Remove then
                    self.removePointId = message["pointIds"]
                    for i=1,#self.removePointId do
                        self:AddToDeleteList(self.removePointId[i])
                        self:RemovePointInfo(self.removePointId[i])
                    end
                end
                local beforeTime = UITimeManager:GetInstance():GetServerTime()
                parseFinish,count = self:DoParse()
                if parseFinish == false then
                    Logger.Log("[world point] parse break because useTime>5ms count:"..count)
                    return
                end
                local endTime = UITimeManager:GetInstance():GetServerTime()
                Logger.Log(string.format("[world point] parse %s data  use %s ms",count,(endTime-beforeTime)))
            end
        end
    else
        Logger.Log("[world point] parse break because useTime>5ms count:"..count)
    end
end
function WorldPointManager:DoParse()
    local count = 0
    if #self.pointMessageArray>0 then
        local isRefresh = false
        local isPointRefresh = false
        local curTime = UITimeManager:GetInstance():GetServerTime()
        while #self.pointMessageArray > 0 do
            if self:IsBusy() then
                if isRefresh == true and LuaEntry.Player.serverType == ServerType.DRAGON_BATTLE_FIGHT_SERVER then
                    EventManager:GetInstance():Broadcast(EventId.DragonMapDataRefresh)
                end
                if self.isPointRefresh == true then
                    EventManager:GetInstance():Broadcast(EventId.UPDATE_POINTS_DATA)
                end
                return false,count
            end
            local bytes = table.remove(self.pointMessageArray,1)
            if bytes~=nil then
                local data = PBController.ParsePbFromBytes(bytes, "protobuf.WorldPointInfo")
                if data~=nil then
                    if (data.samplePointInfo ~= nil and data.samplePointInfo.ownerUid ~= LuaEntry.Player.uid)
                            or (data.explorePointInfo ~= nil and data.explorePointInfo.ownerUid ~= LuaEntry.Player.uid)
                            or (data.garbagePointInfo ~= nil and data.garbagePointInfo.ownerUid ~= LuaEntry.Player.uid)
                    then
                        goto continue
                    end
                    if data.pointType == WorldPointType.HERO_DISPATCH then
                        local dispatchMission = PBController.ParsePbFromBytes(data.extraInfo, "protobuf.DispatchMission")
                        if dispatchMission~=nil then
                            if dispatchMission.ownerUid ~= LuaEntry.Player.uid then
                                if  dispatchMission.allianceId~=nil and dispatchMission.allianceId~="" and dispatchMission.allianceId == LuaEntry.Player.allianceId then
                                    if dispatchMission.finishTime<=0 then
                                        goto continue
                                    end
                                else
                                    if dispatchMission.finishTime<=0 or dispatchMission.finishTime>curTime then --非同盟玩家，时间到了才显示
                                        goto continue
                                    end
                                end
                                
                            end
                        end
                    end
                    if data.pointType == WorldPointType.WorldMonster then
                        local monsterInfo = PBController.ParsePbFromBytes(data.extraInfo, "protobuf.WorldPointMonster")
                        if monsterInfo~=nil then
                            if monsterInfo.type == NewMarchType.MONSTER then
                                local marchInfo = PBController.ParsePbFromBytes(monsterInfo.monsterExtraInfo, "protobuf.NormalMonsterInfo")
                                if marchInfo~=nil and marchInfo.eventId~=nil and marchInfo.eventId~="" and monsterInfo.belongUid ~= LuaEntry.Player.uid then
                                    goto continue
                                end
                            end
                        end
                        
                    end
                    if data.serverId>0 and data.serverId~=LuaEntry.Player:GetCurServerId() then
                        goto continue
                    end
                    if data.worldId ~= LuaEntry.Player:GetCurWorldId() then
                        goto continue
                    end
                    if data.pointType == WorldPointType.DRAGON_BUILDING then
                        if isRefresh ==false then
                            local info = self.dragonPointDic[data.uuid]
                            if info~=nil then
                                if WorldBuildUtil.GetPlayerType(info) ~= WorldBuildUtil.GetPlayerType(data) then
                                    isRefresh = true
                                end
                            else
                                isRefresh = true
                            end
                        end
                        self.dragonPointDic[data.uuid] = data.id
                    elseif data.pointType == WorldPointType.SECRET_KEY then
                        if isRefresh ==false then
                            local info = self.dragonPointDic[data.uuid]
                            if info == nil then
                                isRefresh = true
                            end
                        end
                        self.dragonPointDic[data.uuid] = data.id
                    end
                    self:AddPointInfo(data)
                    self:AddToBuildList(data.id)

                    isPointRefresh = true
                end
            end
            count = count+1
            ::continue::
        end
        if isRefresh == true and LuaEntry.Player.serverType == ServerType.DRAGON_BATTLE_FIGHT_SERVER then
            EventManager:GetInstance():Broadcast(EventId.DragonMapDataRefresh)
        end
        if self.isPointRefresh == true then
            EventManager:GetInstance():Broadcast(EventId.UPDATE_POINTS_DATA)
        end
    end
    if #self.desertMessageArray>0 then
        while #self.desertMessageArray > 0 do
            if self:IsBusy() then
                return false,count
            end
            local bytes = table.remove(self.desertMessageArray,1)
            if bytes~=nil then
                local data = PBController.ParsePbFromBytes(bytes, "protobuf.DesertInfo")
                if data~=nil then
                    if data.serverId>0 and data.serverId~=LuaEntry.Player:GetCurServerId() then
                        goto continue
                    end
                    if data.worldId ~= LuaEntry.Player:GetCurWorldId() then
                        goto continue
                    end
                    self:AddDesertInfo(data)
                    self:AddToBuildList(data.id)
                end
            end
            count = count+1
            ::continue::
        end
    end
    if #self.allianceMessageArray>0 then
        local isRefresh = false
        local svLod = self:GetServerLod(self.lodLv)
        while #self.allianceMessageArray > 0 do
            if self:IsBusy() then
                if isRefresh == true and svLod>0 then
                    EventManager:GetInstance():Broadcast(EventId.MiniMapDataRefresh)
                end
                return false,count
            end
            local bytes = table.remove(self.allianceMessageArray,1)
            if bytes~=nil then
                local data = PBController.ParsePbFromBytes(bytes, "protobuf.WorldPointInfo")
                if data~=nil then
                    if data.serverId>0 and data.serverId~=LuaEntry.Player:GetCurServerId() then
                        goto continue
                    end
                    if data.worldId ~= LuaEntry.Player:GetCurWorldId() then
                        goto continue
                    end
                    if data.pointType == WorldPointType.PlayerBuilding then
                        if data.buildInfo~=nil then
                            local ownerUid = data.buildInfo.ownerUid
                            local pType = WorldBuildUtil.GetPlayerType(data)
                            if pType == PlayerType.PlayerSelf or pType == PlayerType.PlayerAlliance or pType == PlayerType.PlayerAllianceLeader then
                                if isRefresh ==false then
                                    local info = self.AllianceMemberDic[data.id]
                                    if info~=nil then
                                        if info.id~=data.id then
                                            isRefresh = true
                                        elseif pType~=WorldBuildUtil.GetPlayerType(info) then
                                            isRefresh = true
                                        end
                                    else
                                        isRefresh = true
                                    end
                                end
                                self.AllianceMemberDic[ownerUid] = data
                            end
                        end
                    end
                end
            end
            count = count+1
            ::continue::
        end
        if isRefresh == true and svLod>0 then
            EventManager:GetInstance():Broadcast(EventId.MiniMapDataRefresh)
        end
    end
    self.pointMessageArray = {}
    self.allianceMessageArray = {}
    self.desertMessageArray = {}
    return true,count
end
function WorldPointManager:GetSelfAllianceList()
    return self.AllianceMemberDic
end
function WorldPointManager:GetDragonPointDic()
    return self.dragonPointDic
end
function WorldPointManager:GetPointInfo(pointIndex)
    if CommonUtil.IsUseLuaWorldPoint()==false then
        return CS.SceneManager.World:GetPointInfo(pointIndex)
    else
        local info = self:GetWorldTileInfo(pointIndex)
        if info~=nil then
            local data = info.pointInfo
            if data~=nil then
                data.PointType = info.pointInfo.pointType ---兼容c#，补一个变量
                data.mainIndex = info.mainIndex
                data.pointIndex = info.pointIndex
            end

            return data
        end
        return nil
    end
end
function WorldPointManager:GetDesertInfo(pointIndex)
    if CommonUtil.IsUseLuaWorldPoint()==false then
        local worldTileInfo = CS.SceneManager.World:GetWorldTileInfo(pointIndex)
        if worldTileInfo ~= nil then
            local desertData = worldTileInfo:GetWorldDesertInfo()
            return desertData
        end
    else
        local info = self:GetWorldTileInfo(pointIndex)
        if info~=nil then
            local data = info.desertInfo
            if data~=nil then
                data.ownerUid = info.desertInfo.uid
                data.mainIndex = info.mainIndex
                data.pointIndex = info.pointIndex
            end
            return data
        end
    end
    return nil
end
function WorldPointManager:GetDesertPointList()
    if CommonUtil.IsUseLuaWorldPoint()==false then 
        local tb = {}
        local dic = CS.SceneManager.World:GetDesertPointList()
        if dic~=nil and dic.Count>0 then
            for k,v in pairs(dic) do
                tb[k]= v
            end
        end
        return tb
    else
        local tb = {}
        for k,v in pairs(self.uuidInfoDesertMap) do
            local info = self:GetWorldTileInfo(v)
            if info~=nil then
                local data = info.desertInfo
                if data~=nil then
                    data.ownerUid = info.desertInfo.uid
                    data.mainIndex = info.mainIndex
                    data.pointIndex = info.pointIndex
                    tb[k] = data
                end
            end
        end
        return tb
    end
    return {}
end
function WorldPointManager:GetPointInfoByUuid(uuid)
    if CommonUtil.IsUseLuaWorldPoint()==false then
        return CS.SceneManager.World:GetPointInfoByUuid(uuid)
    else
        local id = self.uuidInfoMap[uuid]
        if id~=nil then
            local info = self:GetWorldTileInfo(id)
            if info~=nil then
                local data = info.pointInfo
                if data~=nil then
                    data.PointType = info.pointInfo.pointType ---兼容c#，补一个变量
                    data.mainIndex = info.mainIndex
                    data.pointIndex = info.pointIndex
                end
                return data
            end
        end
        return nil
    end
end
function WorldPointManager:GetBuildDataByUuid(uuid)
    local info = DataCenter.WorldPointManager:GetPointInfoByUuid(uuid)
    if info ~= nil then
        local build = nil
        if CommonUtil.IsUseLuaWorldPoint() then
            build = info.buildInfo
            build.mainIndex = info.mainIndex
            build.pointIndex = info.pointIndex
            build.itemId = info.buildInfo.buildId
            build.curHp = info.buildInfo.currentHp
        else
            cast(info, typeof(CS.BuildPointInfo))
            build = info
        end
        return build
    end
    return nil
end
function WorldPointManager:GetBuildDataByPointIndex(pointIndex)
    local info = DataCenter.WorldPointManager:GetPointInfo(pointIndex)
    if info ~= nil then
        local build = nil
        if CommonUtil.IsUseLuaWorldPoint() then
            build = info.buildInfo
            build.mainIndex = info.mainIndex
            build.pointIndex = info.pointIndex
            build.itemId = info.buildInfo.buildId
            build.curHp = info.buildInfo.currentHp
        else
            cast(info, typeof(CS.BuildPointInfo))
            build = info
        end
        return build
    end
    return nil
end
function WorldPointManager:GetResourcePointInfoByIndex(pointIndex)
    if CommonUtil.IsUseLuaWorldPoint() then
        local info = DataCenter.WorldPointManager:GetPointInfo(pointIndex)
        if info ~= nil then
            local data  = nil
            data = info.resourceInfo
            data.mainIndex = info.mainIndex
            data.pointIndex = info.pointIndex
            data.uuid = info.resourceInfo.uuid
            data.gatherMarchUuid = info.resourceInfo.gatherUuid
            data.id = info.resourceInfo.resourceId
            return data
        end
    else
        return CS.SceneManager.World:GetResourcePointInfoByIndex(pointIndex)
    end
    return nil
end
function WorldPointManager:GetSamplePointInfoByIndex(pointIndex)
    if CommonUtil.IsUseLuaWorldPoint() then
        local info = DataCenter.WorldPointManager:GetPointInfo(pointIndex)
        if info ~= nil then
            local data  = nil
            data = info.samplePointInfo
            data.mainIndex = info.mainIndex
            data.pointIndex = info.pointIndex
            return data
        end
    else
        return CS.SceneManager.World:GetSamplePointInfoByIndex(pointIndex)
    end
    return nil
end
function WorldPointManager:GetExplorePointInfoByIndex(pointIndex)
    if CommonUtil.IsUseLuaWorldPoint() then
        local info = DataCenter.WorldPointManager:GetPointInfo(pointIndex)
        if info ~= nil then
            local data  = nil
            data = info.explorePointInfo
            data.mainIndex = info.mainIndex
            data.pointIndex = info.pointIndex
            return data
        end
    else
        return CS.SceneManager.World:GetExplorePointInfoByIndex(pointIndex)
    end
    return nil
end
function WorldPointManager:GetGarbagePointInfoByIndex(pointIndex)
    if CommonUtil.IsUseLuaWorldPoint() then
        local info = DataCenter.WorldPointManager:GetPointInfo(pointIndex)
        if info ~= nil then
            local data  = nil
            data = info.garbagePointInfo
            if data ==nil then
                data = info.samplePointInfo
            end
            data.mainIndex = pointIndex
            data.pointIndex = pointIndex
            return data
        end
    else
        return CS.SceneManager.World:GetGarbagePointInfoByIndex(pointIndex)
    end
    return nil
end
function WorldPointManager:GetWorldTileInfo(pointIndex)
    return self.allViewPoints[pointIndex]
end
function WorldPointManager:AddPointInfo(pi)
    if self.allViewPoints[pi.id] ==nil then
        self.allViewPoints[pi.id] = {}
        self.allViewPoints[pi.id].mainIndex = pi.id
        self.allViewPoints[pi.id].pointIndex = pi.id
    end
    self.allViewPoints[pi.id].pointInfo = pi
    self.allViewPoints[pi.id].pointType = pi.pointType 
    local tilePos = SceneUtils.IndexToTilePos(pi.id,ForceChangeScene.World)
    local sz = WorldBuildUtil.GetBuildTile(pi.id)
    if sz>1 then
        for x = 0,sz-1 do
            for y =0,sz-1 do
                local pos ={}
                pos.x = tilePos.x-x
                pos.y = tilePos.y-y
                if SceneUtils.IsInMap(pos) ==true then
                    local tempIndex = SceneUtils.TilePosToIndex(pos, ForceChangeScene.World)
                    if tempIndex ~= pi.mainIndex then
                        if self.allViewPoints[tempIndex] == nil then
                            self.allViewPoints[tempIndex] = {}
                            self.allViewPoints[tempIndex].mainIndex = pi.id
                            self.allViewPoints[tempIndex].pointIndex = tempIndex
                        end
                        self.allViewPoints[tempIndex].pointInfo = pi
                        self.allViewPoints[pi.id].pointType = pi.pointType
                    end
                end
            end
        end
    end
    if pi.uuid~=0 then
        self.uuidInfoMap[pi.uuid] = pi.id
        self.uuidInfoDesertMap[pi.uuid] = pi.id
    end
end
function WorldPointManager:AddDesertInfo(di)
    if self.allViewPoints[di.id] ==nil then
        self.allViewPoints[di.id] = {}
        self.allViewPoints[di.id].mainIndex = di.id
        self.allViewPoints[di.id].pointIndex = di.id
        self.allViewPoints[di.id].pointType = WorldPointType.Other
    end
    self.allViewPoints[di.id].desertInfo = di
    if di.uuid~=0 then
        self.uuidInfoDesertMap[di.uuid] = di.id
    end
end
function WorldPointManager:RemovePointInfo(pointIndex,forceRemove)
    if self.allViewPoints[pointIndex] == nil then
        return
    end
    local info = self.allViewPoints[pointIndex]
    if info.pointInfo ==nil then
        return
    end
    local mainIndex = info.mainIndex
    local uuid = 0
    if info.pointInfo~=nil then
        uuid = info.pointInfo.uuid
    end
    local tilePos = SceneUtils.IndexToTilePos(mainIndex,ForceChangeScene.World)
    local sz = WorldBuildUtil.GetBuildTile(mainIndex)
    local needCheckShowTileList = {}
    if sz>1 then
        for x = 0,sz-1 do
            for y =0,sz-1 do
                local pos ={}
                pos.x = tilePos.x-x
                pos.y = tilePos.y-y
                if SceneUtils.IsInMap(pos) == true then
                    local tempIndex = SceneUtils.TilePosToIndex(pos, ForceChangeScene.World)
                    if tempIndex ~= mainIndex then
                        if self.allViewPoints[tempIndex] ~= nil then
                            self.allViewPoints[tempIndex].pointInfo = nil
                            if forceRemove == true or self.allViewPoints[tempIndex].desertInfo ==nil then
                                self.allViewPoints[tempIndex] = nil
                            else
                                table.insert(needCheckShowTileList,tempIndex)
                            end
                        end
                    end
                end
            end
        end
    end
    if self.allViewPoints[mainIndex] ~= nil then
        self.allViewPoints[mainIndex].pointInfo = nil
        if forceRemove == true or self.allViewPoints[mainIndex].desertInfo ==nil then
            self.allViewPoints[mainIndex] = nil
        else
            table.insert(needCheckShowTileList,mainIndex)
        end
    end
    self.uuidInfoMap[uuid] =nil
    self.dragonPointDic[uuid] = nil
    for i =1,#needCheckShowTileList do
        local index = needCheckShowTileList[i]
        local t = self.allViewPoints[index]
        if t~=nil then
            if t.desertInfo~=nil or t.pointInfo~=nil then
                self:AddToBuildList(index)
            else
                self.allViewPoints[index] =nil
            end
        end
    end
end
function WorldPointManager:RemoveDesertInfo(pointIndex)
    if self.allViewPoints[pointIndex] == nil then
        return
    end
    local info = self.allViewPoints[pointIndex]
    local desertData = info.desertInfo
    if desertData~=nil then
        if desertData.uuid~=nil then
            self.uuidInfoDesertMap[desertData.uuid] = nil
        end
        info.desertInfo = nil
    end
    if info.desertInfo == nil and info.pointInfo == nil then
        self.allViewPoints[pointIndex] = nil
    end
end


---gameObject
function WorldPointManager:BuildAsync()
    local svLod = self:GetServerLod(self.lodLv)
    local viewLevelRange = ViewLevelRange[svLod+1]
    local count = 0
    local beforeTime = UITimeManager:GetInstance():GetServerTime()
    while #self.toBuildList >0 do
        if self:IsSyncBusy() or count>35 then
            Logger.Log("[world point] BuildAsync break because long  count"..count)
            return
        end
        count = count+1
        local mainIndex = table.remove(self.toBuildList, 1)
        local checkLod = OtherPointLod
        local tileData = self:GetWorldTileInfo(mainIndex)
        if tileData ~= nil then
            local pointInfo = tileData.pointInfo
            if pointInfo~=nil then
                local pType = WorldBuildUtil.GetPlayerType(pointInfo)
                if pointInfo.pointType == WorldPointType.WORLD_ALLIANCE_BUILD or pointInfo.pointType == WorldPointType.DRAGON_BUILDING or pointInfo.pointType == WorldPointType.CROSS_THRONE_BUILD or pointInfo.pointType == WorldPointType.SECRET_KEY or pType == PlayerType.PlayerSelf then
                    checkLod = SelfPointLod
                elseif pType == PlayerType.PlayerAlliance or pType == PlayerType.PlayerAllianceLeader then
                    checkLod = SelfPointLod
                end
            end
            if self.lodLv<=checkLod then
                local obj = self:GetObjectByPoint(mainIndex)
                if obj == nil then
                    local tp = SceneUtils.IndexToTilePos(mainIndex,ForceChangeScene.World)
                    if self:IsOutOfRange(tp,self.reqPos,viewLevelRange) ==false then
                        self:CreateObject(mainIndex)
                    end
                else
                    local objType = obj:GetPointType()
                    if objType~=tileData.pointType then
                        self:DestroyObject(mainIndex)
                    else
                        obj:UpdateGameObject();
                    end
                end
            end
        end
    end
    local endTime = UITimeManager:GetInstance():GetServerTime()
    if count>0 then
        Logger.Log(string.format("[world point] BuildAsync %s data  use %s ms",count,(endTime-beforeTime)))
    end
    
end
function WorldPointManager:AddToBuildList(pointIndex)
    table.insert(self.toBuildList,pointIndex)
    self.outOfViewPoints[pointIndex] = nil
end
function WorldPointManager:GetObjectByPoint(pointIndex)
    return self.allObj[pointIndex]
end
function WorldPointManager:GetObjectByUuid(uuid)
    local info = DataCenter.WorldPointManager:GetPointInfoByUuid(uuid)
    if info~=nil then
        return self:GetObjectByPoint(info.mainIndex)
    end
    return nil
end
function WorldPointManager:CreateObject(pointIndex)
    local info = self:GetWorldTileInfo(pointIndex)
    if info == nil or (info.pointInfo == nil and info.desertInfo == nil ) then
        return
    end
    local pType = info.pointType
    local obj = nil
    if pType == WorldPointType.PlayerBuilding then
        obj = WorldBuildObject.New()
    elseif pType == WorldPointType.WorldResource then
        local resourceInfo = info.pointInfo.resourceInfo
        if resourceInfo == nil or string.IsNullOrEmpty(resourceInfo.eventId) then
            obj =  WorldResObject.New()
        else
            obj =  WorldHighSpeedCollectObject.New()
        end
    elseif pType == WorldPointType.DETECT_EVENT_PVE  or pType == WorldPointType.EXPLORE_POINT then
        obj = WorldExploreObject.New()
    elseif pType == WorldPointType.SAMPLE_POINT or pType == WorldPointType.SAMPLE_POINT_NEW then
        local samplePointInfo = info.pointInfo.samplePointInfo
        if samplePointInfo == nil or string.IsNullOrEmpty(samplePointInfo.eventId) then
            return
        end
        local template = DataCenter.DetectEventTemplateManager:GetDetectEventTemplate(samplePointInfo.eventId)
        if template == nil then
            return
        end
        if template.type == DetectEventType.RESCUE then
            obj =  WorldRescueObject.New()
        else
            obj =  WorldSampleObject.New()
        end
    elseif pType == WorldPointType.GARBAGE then
        obj = WorldGarbageObject.New()
    elseif pType == WorldPointType.HERO_DISPATCH then
        obj = WorldHeroDispatchTaskObject.New()
    elseif pType == WorldPointType.WorldMonster then
        obj = WorldMonsterObject.New()
    else
        obj = WorldBasePointObject.New()
    end
    if obj~=nil then
        obj:InitData(pointIndex,pType)
        obj:CreateGameObject()
        self.allObj[pointIndex] =obj
    end
end
function WorldPointManager:DestroyObject(pointIndex)
    local obj = self.allObj[pointIndex]
    if obj~=nil then
        obj:Destroy()
        self.allObj[pointIndex] = nil
    end
end
function WorldPointManager:IsOutOfRange(pV2,centerV2,rangeV2)
    local deltaX = math.abs(pV2.x-centerV2.x)
    local deltaY = math.abs(pV2.y-centerV2.y)
    if deltaX>=rangeV2.x or deltaY>=rangeV2.y then
        return true
    end
    return false
end
function WorldPointManager:DeleteOutOfView()
    if self.reqPos ==nil then
        return
    end
    local svLod = self:GetServerLod(self.lodLv)
    local viewLevelRange = ViewLevelRange[svLod+1]
    if self.lastDelPos == nil then
        self.lastDelPos = {}
        self.lastDelPos.x = -1
        self.lastDelPos.y = -1
    end
    if self.lastDelPos.x ~= self.reqPos.x or self.lastDelPos.y ~= self.reqPos.y or svLod ~= self.lastDelSvLod then
        if LuaEntry.Player.serverType ~= ServerType.DRAGON_BATTLE_FIGHT_SERVER then
            for k, v in pairs(self.allViewPoints) do
                local mainIndex = v.mainIndex
                local tp = SceneUtils.IndexToTilePos(mainIndex, ForceChangeScene.World)
                if self:IsOutOfRange(tp, self.reqPos, viewLevelRange) == true then
                    self.outOfViewPoints[mainIndex] = true
                end
            end
        end
        self.lastDelSvLod = svLod
        self.lastDelPos.x = self.reqPos.x
        self.lastDelPos.y = self.reqPos.y
    end
    if table.count(self.outOfViewPoints)>0 then
        self.keysToRemove = {}
        local count = 0
        for k,v in pairs(self.outOfViewPoints) do
            if self:IsSyncBusy() then
                Logger.Log("[world point] delete break because long  count"..count);
                break
            end
            self:DestroyObject(k)
            self:RemovePointInfo(k,true)
            table.insert(self.keysToRemove,k)
            count = count+1
        end
        for i = 1,#self.keysToRemove do
            self.outOfViewPoints[self.keysToRemove[i]] = nil
        end
    end
end

function WorldPointManager:AddToDeleteList(index)
    if self.outOfViewPoints~=nil then
        self.outOfViewPoints[index] = true
    end
end

function WorldPointManager:DestroyAll()
    if self.allObj~=nil then
        for k,v in pairs(self.allObj) do
            v:Destroy()
        end
        self.allObj  ={}
    end
end
return WorldPointManager