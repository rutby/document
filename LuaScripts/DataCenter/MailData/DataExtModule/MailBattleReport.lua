---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by guqu.
--- DateTime: 2020/7/21 15:53
---
local rapidjson = require "rapidjson"
local BattleEffectList = require "DataCenter.MailData.BattleReport.BattleEffectData.BattleEffectList"
local HeroBattleEffect = require "DataCenter.MailData.BattleReport.BattleEffectData.HeroBattleEffect"
local MailBattleOneRound = require "DataCenter.MailData.BattleReport.MailBattleOneRound"
local AllFightLost = require "DataCenter.MailData.BattleReport.AllFightLost"
local MailBattleReport = BaseClass("MailBattleReport")
function MailBattleReport:__init()
    -- 所有回合的集合
    self._fightRoundList = {}
    self.showRoundList = {}
    self._battlePointId = 0
    self._battleServerId = -1
    self._battleBuffList = {}
    self._heroBattleBuffList = {}
    self.version = 0
    self.marchTargetType = -1
    self.needExchangeInfo = false
    self.mailType = nil
end

function MailBattleReport:SetMailType(mailType)
    self.mailType = mailType
end
function MailBattleReport:GetBattleFightPointId()
    return self._battlePointId
end
function MailBattleReport:GetBattleServerId()
    return self._battleServerId
end
function MailBattleReport:GetBattleWorldId()
    return self._worldId
end
-- 通过 SimpleCombatUnit 中的 uuid获取对应的SimpleCombatUnit
function MailBattleReport:GetSimpleCombatUnitByUuid()

end

function MailBattleReport:ParseContent(mailContent)
    if (table.IsNullOrEmpty(mailContent)) then
        return
    end
    local battleReport = mailContent["battleContent"] or ""
    local pb_BattleReport = PBController.ParsePb1(battleReport, "protobuf.BattleReport") or {}

    -- 解析回合战斗
    local fightReports = pb_BattleReport["fightReports"] or {}
    for _, roundItem in pairs(fightReports) do
        self.needExchangeInfo = table.count(fightReports) == 1 and roundItem.otherInfo and roundItem.selfInfo
                and roundItem.otherInfo.uid == LuaEntry.Player.uid
        if self.needExchangeInfo and (self.mailType == MailType.NEW_FIGHT_MINECAVE or self.mailType == MailType.NEW_FIGHT_ARENA) then
            roundItem.selfInfo, roundItem.otherInfo = roundItem.otherInfo, roundItem.selfInfo
            --roundItem.selfInfo = pb_BattleReport.otherInfo
            --roundItem.otherInfo = pb_BattleReport.selfInfo
            local function swapValue(obj, name1, name2)
                local tmp = obj[name1]
                obj[name1] = obj[name2]
                obj[name2] = tmp
            end

            swapValue(roundItem, "otherArmyResult", "selfArmyResult")
            roundItem.otherBattleEffectGroups, pb_BattleReport.selfBattleEffectGroups = pb_BattleReport.selfBattleEffectGroups, roundItem.otherBattleEffectGroups
            --swapValue(roundItem, "otherBattleEffectGroups", "selfBattleEffectGroups")
            if roundItem.fightResult == 0 then
                roundItem.fightResult = 1
            elseif roundItem.fightResult == 1 then
                roundItem.fightResult = 0
            end
        end

        local battleRound = MailBattleOneRound.New()
        battleRound:ParseContent(roundItem,false)
        self:InsertRound(battleRound)
    end

    -- 解析战斗坐标点
    if (pb_BattleReport["battlePointInfo"] and pb_BattleReport["battlePointInfo"]["pointId"]) then
        self._battlePointId = pb_BattleReport["battlePointInfo"]["pointId"]
        self._battleServerId = pb_BattleReport["battlePointInfo"]["battleServerId"]
        self._worldId = pb_BattleReport["battlePointInfo"]["worldId"] or 0
    end

    -- 解析战斗胜利/失败
    local battleResult = pb_BattleReport["battleResult"] or 0
    self._battleWin = battleResult == 0

    -- 当前战报所属服务器第几轮战斗
    self._startRound = pb_BattleReport["startRound"] or 0

    -- 部队增益
    local battleEffectGroup = pb_BattleReport["selfBattleEffectGroups"] or {}
    self:InitMySideBattleEffect(battleEffectGroup)
    local fightLost = pb_BattleReport["allFightLost"] or {}
    self:InitAllFightLost(fightLost)
    self.version = pb_BattleReport["version"] or 0

    local marchType = pb_BattleReport["marchType"] or 0
    self.marchTargetType = marchType-1
end

function MailBattleReport:GetBattleWinInPve()
    for _, roundItem in pairs(self._fightRoundList) do
        if (roundItem:GetBattleResult() ~= FightResult.SELF_WIN) then
            return false
        end
    end
    return true
end

function MailBattleReport:GetMarchTargetType()
    return self.marchTargetType
end
function MailBattleReport:AddInShowList(battleRound,roundIndex)
    local vsList = battleRound:GetVsMap()
    local leaderUuid = battleRound:GetLeaderUuid(true)
    for k,v in pairs(vsList) do
        for a,b in pairs(v) do
            local oneData = {}
            oneData.leftUuid = k
            oneData.rightUuid = a
            oneData.roundIndex = roundIndex
            self.showRoundList[#self.showRoundList+1] = oneData
        end
    end
    if self.mailType == nil or self.mailType ~= MailType.ELITE_FIGHT_MAIL then
        table.sort(self.showRoundList, function(a,b)
            if a.leftUuid == leaderUuid and b.leftUuid ~= leaderUuid then
                return true
            end
            return false
        end)
    end
end
--[[
将每次回合的数据插入到列表中显示
在这个地方需要做一些处理,有些类型的战报比如打有驻扎的炮台,此时需要拆成两块来显示
]]
function MailBattleReport:InsertRound( battleRound )
    local index = #self._fightRoundList+1
    self._fightRoundList[index] = battleRound
    self:AddInShowList(battleRound,index)
    ---- 检测是需要分成几轮显示,如果一轮的话,直接塞入数据,如果两轮或多轮按照逻辑行为进行拆分
    --local roundCnt = battleRound:GetRoundCnt()
    --if (roundCnt == 1) then
    --    self._fightRoundList[#self._fightRoundList+1] = battleRound
    --elseif roundCnt == 2 then
    --    self:InsertRoundItem(battleRound)
    --end
end

--[[
箭塔模式下进行数据拆分插入
    大致思路:
    第一,在两轮中,第一轮设置战斗类型是箭塔,界面中按照箭塔模式显示血条,第二轮设置类型为编队,按照编队的样式进行展示
    第二,需要知道双方哪边是箭塔,箭塔方不做处理,另一方获取出总的属性值后,获取出本身对于箭塔数据的系数,乘以系数后,强制设置属性数据缓存,此时为第一轮的数据
    第三,在第二轮中,使用总数减去上一轮的数据,强制设置到缓存中,同时设置战斗类型为编队
]]
--function MailBattleReport:InsertRoundItem( battleRound )
--    -- 第一轮显示箭塔本身
--    local sBattleType = battleRound:GetSelfBattleType()
--    local tBattleType = battleRound:GetTargetBattleType()
--    
--    if (sBattleType == BattleType["Turret"]) then
--        self:SetSimpleRound_Turret(battleRound, true)
--    elseif sBattleType == BattleType["ALLIANCE_OCCUPIED_CITY"] then
--        self:SetSimpleRound_Neutral(battleRound, true)
--    elseif tBattleType == BattleType["Turret"] then
--        self:SetSimpleRound_Turret(battleRound, false)
--    elseif tBattleType == BattleType["ALLIANCE_OCCUPIED_CITY"] then
--        self:SetSimpleRound_Neutral(battleRound, false)
--    end
--end
--
--function MailBattleReport:SetSimpleRound_Turret(battleRound, mySideIsTurret)
--    local totalCnt = 0
--    local wounded = 0
--    local injured = 0
--    local dead = 0
--    local lost = 0
--    local cure = 0
--    local alive = 0
--
--    local sUuid = self:GetSimpleCombatUnit(battleRound, mySideIsTurret):GetMarchId()
--    local damagePercent = 0.0
--    local armyResult = nil
--    if (mySideIsTurret) then
--        armyResult = battleRound:GetOtherArmyResult()
--    else
--        armyResult = battleRound:GetSelfArmyResult()
--    end
--    if (armyResult ~= nil) then
--        damagePercent = armyResult:GetDamagePercentInfo()[sUuid] or 0
--    end
--    totalCnt = battleRound:GetArmyObjAttTotalCnt(eMailSoldierAttr.Total, not mySideIsTurret)
--    wounded = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Wounded, not mySideIsTurret) --轻伤
--    injured = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Injured, not mySideIsTurret) --重伤
--    dead = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Dead, not mySideIsTurret) -- 死亡
--    lost = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Lost, not mySideIsTurret) -- 损失
--    cure = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Cure, not mySideIsTurret) -- 治疗
--
--    -- 设置当前数据
--    local tmpWounded = Mathf.Ceil(wounded * damagePercent)
--    local tmpInjured = Mathf.Ceil(injured * damagePercent)
--    local tmpDead = Mathf.Ceil(dead * damagePercent)
--    local tmpLost = Mathf.Ceil(lost * damagePercent)
--    local tmpCure = Mathf.Ceil(cure * damagePercent)
--    alive = totalCnt - tmpLost
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Wounded, not mySideIsTurret, tmpWounded)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Injured, not mySideIsTurret, tmpInjured)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Dead, not mySideIsTurret, tmpDead)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Lost, not mySideIsTurret, tmpLost)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Cure, not mySideIsTurret, tmpCure)
--    self._fightRoundList[#self._fightRoundList+1] = battleRound
--
--    local battleRound_Second = DeepCopy(battleRound)
--    if (mySideIsTurret) then
--        battleRound_Second:SetSelfBattleType(BattleType["Formation"])
--    else
--        battleRound_Second:SetTargetBattleType(BattleType["Formation"])
--    end
--
--    battleRound_Second:SetArmyObjAttTotalCntCache(eMailSoldierAttr.Total, not mySideIsTurret, alive)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Wounded, not mySideIsTurret, wounded-tmpWounded)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Injured, not mySideIsTurret, injured-tmpInjured)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Dead, not mySideIsTurret, dead-tmpDead)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Lost, not mySideIsTurret, lost-tmpLost)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Cure, not mySideIsTurret, cure-tmpCure)
--    
--    self._fightRoundList[#self._fightRoundList+1] = battleRound_Second
--end
--
--function MailBattleReport:SetSimpleRound_Neutral(battleRound, mySideIsTurret)
--    local totalCnt = 0
--    local wounded = 0
--    local injured = 0
--    local dead = 0
--    local lost = 0
--    local cure = 0
--    local alive = 0
--    
--    local sUuid = self:GetSimpleCombatUnit(battleRound, mySideIsTurret):GetMarchId()
--    local damagePercent = 0.0
--    local armyResult = nil
--    if (mySideIsTurret) then
--        armyResult = battleRound:GetOtherArmyResult()
--    else
--        armyResult = battleRound:GetSelfArmyResult()
--    end
--    if (armyResult ~= nil) then
--        damagePercent = armyResult:GetDamagePercentInfo()[sUuid] or 0
--    end
--    totalCnt = battleRound:GetArmyObjAttTotalCnt(eMailSoldierAttr.Total, not mySideIsTurret)
--    wounded = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Wounded, not mySideIsTurret) --轻伤
--    injured = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Injured, not mySideIsTurret) --重伤
--    dead = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Dead, not mySideIsTurret) -- 死亡
--    lost = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Lost, not mySideIsTurret) -- 损失
--    cure = battleRound:GetSoldierAttrDisById(eMailSoldierAttr.Cure, not mySideIsTurret) -- 治疗
--
--    -- 设置当前数据
--    local tmpWounded = Mathf.Ceil(wounded * damagePercent)
--    local tmpInjured = Mathf.Ceil(injured * damagePercent)
--    local tmpDead = Mathf.Ceil(dead * damagePercent)
--    local tmpLost = Mathf.Ceil(lost * damagePercent)
--    local tmpCure = Mathf.Ceil(cure * damagePercent)
--    alive = totalCnt - tmpLost
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Wounded, not mySideIsTurret, tmpWounded)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Injured, not mySideIsTurret, tmpInjured)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Dead, not mySideIsTurret, tmpDead)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Lost, not mySideIsTurret, tmpLost)
--    battleRound:SetSoldierAttrDisCacheById(eMailSoldierAttr.Cure, not mySideIsTurret, tmpCure)
--    self._fightRoundList[#self._fightRoundList+1] = battleRound
--
--    local battleRound_Second = DeepCopy(battleRound)
--    if (mySideIsTurret) then
--        battleRound_Second:SetSelfBattleType(BattleType["Formation"])
--    else
--        battleRound_Second:SetTargetBattleType(BattleType["Formation"])
--    end
--    
--    battleRound_Second:SetArmyObjAttTotalCntCache(eMailSoldierAttr.Total, not mySideIsTurret, alive)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Wounded, not mySideIsTurret, wounded-tmpWounded)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Injured, not mySideIsTurret, injured-tmpInjured)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Dead, not mySideIsTurret, dead-tmpDead)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Lost, not mySideIsTurret, lost-tmpLost)
--    battleRound_Second:SetSoldierAttrDisCacheById(eMailSoldierAttr.Cure, not mySideIsTurret, cure-tmpCure)
--    local armyResult = mySideIsTurret and battleRound_Second:GetSelfArmyResult() or battleRound_Second:GetOtherArmyResult()
--    --todo:修改了members结构
--    local members = armyResult:GetAllMembers() or {}
--    local userInfo = {}
--    if (mySideIsTurret) then
--        userInfo = battleRound_Second._selfInfo
--    else
--        userInfo = battleRound_Second._otherInfo
--    end
--    for k,v in pairs(members) do
--        local oneMember = v
--        if (not string.IsNullOrEmpty(oneMember.name)) then
--            userInfo["name"] = oneMember["name"]
--            userInfo["pic"] = oneMember["pic"]
--            userInfo["picVer"] = oneMember["picVer"]
--            userInfo["allianceInfo"] = {}
--            userInfo["allianceInfo"]["alAbbr"] = oneMember["alAbbr"]
--            if (mySideIsTurret) then
--                userInfo["pointId"] = armyResult:GetPointId()-- battleRound:GetTargetPos()
--                battleRound._selfInfo = userInfo
--            else
--                userInfo["pointId"] = battleRound:GetTargetPos()
--                battleRound._otherInfo = userInfo
--            end
--            break
--        end
--    end
--    self._fightRoundList[#self._fightRoundList+1] = battleRound_Second
--end

--function MailBattleReport:GetSimpleCombatUnit( battleRound, isMySide )
--    local armyResult = nil
--    if (isMySide) then
--        armyResult = battleRound:GetSelfArmyResult()
--    else
--        armyResult = battleRound:GetOtherArmyResult()
--    end
--    if (armyResult == nil) then
--        return
--    end
--    local afterArmyObj = armyResult:GetAfterArmyObj()
--    if (afterArmyObj == nil) then
--        return
--    end
--    local simpleCombatUnit = afterArmyObj:GetSimpleCombatUnit()
--    if (simpleCombatUnit == nil) then
--        return
--    end
--    return simpleCombatUnit
--end

function MailBattleReport:GetAllMembers( isMySide )
    local tbl = {}
    for _, v in pairs(self._fightRoundList) do
        local tb = v:GetAllMembers(isMySide)
        for _, v in pairs(tb) do
            tbl[#tbl+1] = v
        end
    end
    return tbl
end

function MailBattleReport:GetStartRound()
    return self._startRound
end

-- 检索己方的部队增益
function MailBattleReport:InitMySideBattleEffect( buffEffect )
    self._battleBuffList = {}
    for _, buffItem in pairs(buffEffect) do
        local uuid = buffItem["memberUuid"]
        local arrayEffect = buffItem["battleEffectInfos"]
        local oneData = BattleEffectList.New()
        oneData:InitData(arrayEffect)
        self._battleBuffList[uuid] = oneData

        local arrayEffectHero = buffItem["heroBattleEffects"]
        local oneDataHero = HeroBattleEffect.New()
        oneDataHero:InitData(arrayEffectHero)
        self._heroBattleBuffList[uuid] = oneDataHero
    end
end

function MailBattleReport:InitAllFightLost(allFightLost)
    self.allFightLost = {}
    for k,v in pairs(allFightLost) do
        local oneData = AllFightLost.New()
        oneData:InitData(v)
        if oneData.uuid~=0 then
            self.allFightLost[oneData.uuid] = oneData
        end
    end
end

function MailBattleReport:GetResLostListByTargetUuid(targetUuid)
    if self.allFightLost~=nil and self.allFightLost[targetUuid]~=nil then
        return self.allFightLost[targetUuid]:GetResLostList()
    end
end

function MailBattleReport:GetResItemLostListByTargetUuid(targetUuid)
    if self.allFightLost~=nil and self.allFightLost[targetUuid]~=nil then
        return self.allFightLost[targetUuid]:GetResItemLostArr()
    end
end

function MailBattleReport:GetMySideBattleEffect(marchId)
    if self.mailType ~= nil and self.mailType == MailType.ELITE_FIGHT_MAIL then
        for _, roundItem in pairs(self._fightRoundList) do
            local _battleBuff = roundItem:GetSelfBattleEffectByMarchId(marchId)
            if _battleBuff~=nil then
                return _battleBuff
            end
        end
    else
        return self._battleBuffList[marchId]
    end

end
function MailBattleReport:GetOtherSideBattleEffect(marchId)
    for _, roundItem in pairs(self._fightRoundList) do
        local _battleBuff = roundItem:GetOtherBattleEffectByMarchId(marchId)
        if _battleBuff~=nil then
            return _battleBuff
        end
    end
end

function MailBattleReport:GetMySideHeroBattleEffect(marchId)
    if self.mailType ~= nil and self.mailType == MailType.ELITE_FIGHT_MAIL then
        for _, roundItem in pairs(self._fightRoundList) do
            local _battleBuff = roundItem:GetSelfHeroBattleEffectByMarchId(marchId)
            if _battleBuff~=nil then
                return _battleBuff
            end
        end
    else
        return self._heroBattleBuffList[marchId]
    end

end
function MailBattleReport:GetOtherSideHeroBattleEffect(marchId)
    for _, roundItem in pairs(self._fightRoundList) do
        local _battleBuff = roundItem:GetOtherHeroBattleEffectByMarchId(marchId)
        if _battleBuff~=nil then
            return _battleBuff
        end
    end
end
---- 所有自己的士兵总数
--function MailBattleReport:GetSelfSoldierTotalCnt()
--    if (table.count(self._fightRoundList) == 0) then
--        return 0
--    end
--    return self._fightRoundList[1]:GetSelfSoldierTotalCnt()
--end

--function MailBattleReport:GetSelfSoldierTotalLose()
--    if (table.count(self._fightRoundList) == 0) then
--        return 0
--    end
--    return self._fightRoundList[#self._fightRoundList]:GetAfterArmyObjAttTotalCnt(eMailSoldierAttr.Lost, true, true)
--end


function MailBattleReport:GetBuildingName( isMySide )
    for _, roundItem in pairs(self._fightRoundList) do
        local battleType = isMySide and roundItem:GetSelfBattleType() or roundItem:GetTargetBattleType()
        if (battleType == BattleType["Building"] or
                battleType == BattleType.CROSS_WORM or
                battleType == BattleType["City"]) then
            return roundItem:GetBuildingName(isMySide)
        end
    end
    for _, roundItem in pairs(self._fightRoundList) do
        local battleType = isMySide and roundItem:GetSelfBattleType() or roundItem:GetTargetBattleType()
        if battleType == BattleType["Turret"] then
            return roundItem:GetBuildingName(isMySide)
        end
    end
end

function MailBattleReport:GetBuildingName_ForShare( isMySide )
    for _, roundItem in pairs(self._fightRoundList) do
        local battleType = isMySide and roundItem:GetSelfBattleType() or roundItem:GetTargetBattleType()
        if (battleType == BattleType["Building"] or
                battleType == BattleType.CROSS_WORM or
                battleType == BattleType["City"]) then
            return roundItem:GetBuildingName_ForShare(isMySide)
        end
    end
    for _, roundItem in pairs(self._fightRoundList) do
        local battleType = isMySide and roundItem:GetSelfBattleType() or roundItem:GetTargetBattleType()
        if battleType == BattleType["Turret"] then
            return roundItem:GetBuildingName_ForShare(isMySide)
        end
    end
end

function MailBattleReport:GetTargetName(senderUid)
    local playerName = ""
    local monsterName = ""
    for _, roundItem in pairs(self._fightRoundList) do
        if (roundItem:GetTargetBattleType() == BattleType["Monster"] or
                roundItem:GetTargetBattleType() == BattleType["Boss"] or
                roundItem:GetTargetBattleType() == BattleType.Explore or
                roundItem:GetTargetBattleType() == BattleType["PVE_MONSTER"] or
                roundItem:GetTargetBattleType() == BattleType["ALLIANCE_OCCUPIED_CITY"] or
                roundItem:GetTargetBattleType() == BattleType.THRONE_ARMY or
                roundItem:GetTargetBattleType() == BattleType.BLACK_KNIGHT or
                roundItem:GetTargetBattleType() == BattleType["CHALLENGE_BOSS"]) then
            monsterName = monsterName .. roundItem:GetTargetName()
            if (roundItem:GetTargetBattleType() == BattleType["ALLIANCE_OCCUPIED_CITY"] and
                    not string.IsNullOrEmpty(monsterName)) then
                return monsterName
            end
        else
            playerName = playerName .. roundItem:GetTargetName(senderUid)
            break
        end
    end
    if (string.IsNullOrEmpty(playerName)) then
        return monsterName
    else
        return playerName
    end
end

function MailBattleReport:GetSelfName_ForShare()
    for _, roundItem in pairs(self._fightRoundList) do
        return roundItem:GetSelfName()
    end
    return ""
end

function MailBattleReport:GetTargetName_ForShare()
    local playerName = nil
    local monsterName = nil
    for _, roundItem in pairs(self._fightRoundList) do
        if (roundItem:GetTargetBattleType() == BattleType["Monster"] or
                roundItem:GetTargetBattleType() == BattleType["Boss"] or
                roundItem:GetTargetBattleType() == BattleType.Explore or
                roundItem:GetTargetBattleType() == BattleType["PVE_MONSTER"] or
                roundItem:GetTargetBattleType() == BattleType.BLACK_KNIGHT or
                roundItem:GetTargetBattleType() == BattleType.THRONE_ARMY or
                roundItem:GetTargetBattleType() == BattleType["ALLIANCE_OCCUPIED_CITY"]) then
            monsterName = roundItem:GetTargetName_ForShare()
            if (roundItem:GetTargetBattleType() == BattleType["ALLIANCE_OCCUPIED_CITY"] and
                    monsterName ~= nil) then
                return monsterName
            end
        else
            playerName = roundItem:GetTargetName_ForShare()
            break
        end
    end
    if (playerName == nil) then
        return monsterName
    else
        return playerName
    end
end


-- 获取所有道具奖励
function MailBattleReport:GetTotalItemReward()
    local rewardList = {}
    for _, oneFight in pairs(self._fightRoundList) do
        local rewardItemArr = oneFight:GetRewardItemArr()
        for itemId, itemCnt in pairs(rewardItemArr) do
            rewardList[itemId] = rewardList[itemId] and rewardList[itemId] + itemCnt or itemCnt
        end
    end
    return rewardList
end

-- 是否胜利了
function MailBattleReport:GetBattleWin()
    local isWin = true
    for _, roundItem in pairs(self._fightRoundList) do
        if (roundItem:GetBattleResult() ~= FightResult.SELF_WIN) then
            isWin = false
            break
            --return false
        end
    end
    if #self._fightRoundList > 0 then
        local selfInfo = self._fightRoundList[1]:GetSelfInfo()
        if LuaEntry.Player.uid ~= selfInfo.uid then
            isWin = not isWin
        end
    end
    
    --return true
    return isWin
end

function MailBattleReport:GetBattleResultStatus(senderUid)
    local result = FightResult.DEFAULT
    local isDraw = false
    for _, roundItem in pairs(self._fightRoundList) do
        if (roundItem:GetBattleResult() == FightResult.OTHER_WIN) then
            result = FightResult.OTHER_WIN
            break
        elseif roundItem:GetBattleResult() == FightResult.DRAW then
            isDraw = true
        end
    end
    
    if result == FightResult.DEFAULT then
        if isDraw == false then
            result = FightResult.SELF_WIN
        else
            result = FightResult.DRAW
        end
    end
    if table.count(self._fightRoundList) > 0 then
        local selfInfo = self._fightRoundList[1]:GetSelfInfo()
        if senderUid and selfInfo.uid ~= senderUid then
            if result == FightResult.SELF_WIN then
                result = FightResult.OTHER_WIN
            elseif result == FightResult.OTHER_WIN then
                result = FightResult.SELF_WIN
            end
        end
    end
    return result
end

-- 是否存在攻城战斗
function MailBattleReport:IsMyAttackCity()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetTargetBattleType()
        if (tBattleType == BattleType.Building or
                tBattleType == BattleType.CROSS_WORM or
                tBattleType == BattleType.Turret or
                tBattleType == BattleType.City) then
            return true
        end
    end
    return false
end

function MailBattleReport:IsMyAttackDesert()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetTargetBattleType()
        if (tBattleType == BattleType.Desert ) then
            return true
        end
    end
    return false
end
function MailBattleReport:IsMyTrainDesert()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetTargetBattleType()
        if (tBattleType == BattleType.TRAIN_DESERT ) then
            return true
        end
    end
    return false
end

function MailBattleReport:IsMyProtectDesert()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetSelfBattleType()
        if (tBattleType == BattleType.Desert) then
            return true
        end
    end
    return false
end

-- 是否存在攻城战斗
function MailBattleReport:IsExistMonsterBattle()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetTargetBattleType()
        if (tBattleType == BattleType.Monster or tBattleType == BattleType.Explore or tBattleType == BattleType.BLACK_KNIGHT) then
            return true
        end
    end
    return false
end

-- 是否存在守城战斗
function MailBattleReport:IsMyProtectCity()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetSelfBattleType()
        if (tBattleType == BattleType.Building or
                tBattleType == BattleType.CROSS_WORM or
                tBattleType == BattleType.Turret or
                tBattleType == BattleType.City) then
            return true
        end
    end
    return false
end


--[[
    返回英雄经验加成
    重组信息,{ [1] = {herouid, oldlevel, newlevel, oldExp, newExp, addExp}}
]]
function MailBattleReport:GetHeroExpAddInfo()
    local totalRewardExpArr = {}
    for _, roundItem in pairs(self._fightRoundList) do
        local rewardExpArr = roundItem:GetRewardExpArr()
        for _, rewardExp in pairs(rewardExpArr) do
            local heroUuid = rewardExp["heroId"]
            if (totalRewardExpArr[heroUuid] == nil) then
                totalRewardExpArr[heroUuid] = DeepCopy(rewardExp)
            else
                totalRewardExpArr[heroUuid].nowExp = rewardExp["nowExp"]
                totalRewardExpArr[heroUuid].expAdd = rewardExpArr[heroUuid].expAdd + rewardExp["expAdd"]
            end
        end
    end
    -- 根据heroUuid,获取英雄 oldLevel/newLevel 塞进数据里
    for heroId, rewardExp in pairs(totalRewardExpArr) do
        local oldLevel = self:GetHeroBeforeFightLevel(heroId)
        rewardExp["oldLevel"] = oldLevel
    end
    return totalRewardExpArr
end

-- 获取出战的时候英雄的等级
function MailBattleReport:GetHeroBeforeFightLevel( heroId )
    if (#self._fightRoundList > 0) then
        local _selfUid = LuaEntry.Player.uid
        local firstHeroList = self._fightRoundList[1]:GetPlayerHeroes(true, _selfUid, true)
        return firstHeroList[heroId] and firstHeroList[heroId].heroLevel or 0
    end
    return 0
end
-- 获取英雄最后的等级
function MailBattleReport:GetHeroLastFightLevel( heroId )
    if (#self._fightRoundList > 0) then
        local _selfUid = LuaEntry.Player.uid
        local firstHeroList = self._fightRoundList[1]:GetPlayerHeroes(true, _selfUid, false)
        return firstHeroList[heroId] and firstHeroList[heroId].heroLevel or 0
    end
    return 0
end

-- 获取总共的战斗轮数
function MailBattleReport:GetTotalRoundCnt()
    return table.count(self.showRoundList)
end

function MailBattleReport:CheckIfNeedExchange()
    return self.needExchangeInfo
end

function MailBattleReport:SortRound()
    if table.count(self.showRoundList)>1 and (self.mailType == nil or self.mailType ~= MailType.ELITE_FIGHT_MAIL) then
        table.sort(self.showRoundList,function(a,b)
            local leftType = BattleType.None
            local rightType = BattleType.None
            local leftSpecialType = SpecialUnitType.NONE
            local rightSpecialType = SpecialUnitType.NONE
            local leftOneRoundData = self:GetFightReportByRoundIndex(a.roundIndex)
            local rightOneRoundData = self:GetFightReportByRoundIndex(b.roundIndex)
            if leftOneRoundData~=nil then
                local leftData = leftOneRoundData:GetMemberPlayerInfoByUuid(a.leftUuid,a.rightUuid,true)
                local rightData = leftOneRoundData:GetMemberPlayerInfoByUuid(a.rightUuid,a.leftUuid,false)
                if leftData.battleType == BattleType.Turret or rightData.battleType == BattleType.Turret then
                    leftType = BattleType.Turret
                end
                if leftData.specialType == SpecialUnitType.BUILDING_STATION or rightData.specialType == SpecialUnitType.BUILDING_STATION then
                    leftSpecialType = SpecialUnitType.BUILDING_STATION
                end
            end
            if rightOneRoundData~=nil then
                local leftData = rightOneRoundData:GetMemberPlayerInfoByUuid(b.leftUuid,b.rightUuid,true)
                local rightData = rightOneRoundData:GetMemberPlayerInfoByUuid(b.rightUuid,b.leftUuid,false)
                if leftData.battleType == BattleType.Turret or rightData.battleType == BattleType.Turret then
                    rightType = BattleType.Turret
                end
                if leftData.specialType == SpecialUnitType.BUILDING_STATION or rightData.specialType == SpecialUnitType.BUILDING_STATION then
                    rightSpecialType = SpecialUnitType.BUILDING_STATION
                end
            end
            if leftType~=rightType and rightType == BattleType.Turret then
                return true
            elseif leftType~=rightType and leftType == BattleType.Turret then
                return false
            end
            if leftSpecialType~=rightSpecialType and rightSpecialType == SpecialUnitType.BUILDING_STATION then
                return true
            end
            return false
        end)
    end
end
function MailBattleReport:GetShowRoundListDataByIndex(index)
    if ( index < 1 or index > table.count(self.showRoundList) ) then
        return nil
    end
    local tempData = self.showRoundList[index]
    if tempData~=nil then
        local oneRoundData = self:GetFightReportByRoundIndex(tempData.roundIndex)
        if oneRoundData~=nil then
            local oneData = {}
            oneData.roundUuid = oneRoundData:GetCurRoundUuid()
            oneData._roundIndex = tempData.roundIndex
            oneData.fightResult = oneRoundData.fightResult
            oneData.leftUuid = tempData.leftUuid
            oneData.rightUuid = tempData.rightUuid
            local leftData = oneRoundData:GetMemberPlayerInfoByUuid(tempData.leftUuid,tempData.rightUuid,true)
            local rightData = oneRoundData:GetMemberPlayerInfoByUuid(tempData.rightUuid,tempData.leftUuid,false)
            oneData.leftData = leftData
            oneData.rightData = rightData
            oneData.leftHurt = 0
            oneData.rightHurt = 0
            oneData.actBossDamage = oneRoundData.actBossDamage
            if leftData.unitData~=nil and leftData.afterUnitData~=nil and leftData.damagePercent~=nil then
                local leftDead = leftData.unitData:GetAttTotalCnt(eMailSoldierAttr.Dead)
                local leftWounded = leftData.unitData:GetAttTotalCnt(eMailSoldierAttr.Wounded)
                local leftInjured = leftData.unitData:GetAttTotalCnt(eMailSoldierAttr.Injured)
                local leftCure = leftData.unitData:GetAttTotalCnt(eMailSoldierAttr.Cure)
                local leftAfterDead = leftData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Dead)
                local leftAfterWounded = leftData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Wounded)
                local leftAfterInjured = leftData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Injured)
                local leftAfterCure = leftData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Cure)
                local leftDeadPercent = leftData.damagePercent.deadPercent
                local leftWoundedPercent = leftData.damagePercent.woundedPercent
                local leftInjuredPercent = leftData.damagePercent.injuredPercent
                oneData.rightHurt = (leftAfterDead-leftDead)*leftDeadPercent + (leftAfterInjured-leftInjured)*leftInjuredPercent + (leftAfterWounded-leftWounded+leftAfterCure-leftCure)*leftWoundedPercent
            end
            if rightData.unitData~=nil and rightData.afterUnitData~=nil and rightData.damagePercent~=nil then
                local rightDead = rightData.unitData:GetAttTotalCnt(eMailSoldierAttr.Dead)
                local rightWounded = rightData.unitData:GetAttTotalCnt(eMailSoldierAttr.Wounded)
                local rightInjured = rightData.unitData:GetAttTotalCnt(eMailSoldierAttr.Injured)
                local rightCure = rightData.unitData:GetAttTotalCnt(eMailSoldierAttr.Cure)
                local rightAfterDead = rightData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Dead)
                local rightAfterWounded = rightData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Wounded)
                local rightAfterInjured = rightData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Injured)
                local rightAfterCure = rightData.afterUnitData:GetAttTotalCnt(eMailSoldierAttr.Cure)
                local rightDeadPercent = rightData.damagePercent.deadPercent
                local rightWoundedPercent = rightData.damagePercent.woundedPercent
                local rightInjuredPercent = rightData.damagePercent.injuredPercent
                oneData.leftHurt = (rightAfterDead-rightDead)*rightDeadPercent + (rightAfterInjured-rightInjured)*rightInjuredPercent + (rightAfterWounded-rightWounded+rightAfterCure-rightCure)*rightWoundedPercent
            end
            return oneData
        end
    end

end


-- 获取第N轮的战斗信息
function MailBattleReport:GetFightReportByRoundIndex( index )
    if ( index < 1 or index > table.count(self._fightRoundList) ) then
        return nil
    end
    return self._fightRoundList[index]
end

-- 是否只是和野怪发生了战斗
function MailBattleReport:IsOnlyMonsterBattle()
    for _, roundInfo in pairs(self._fightRoundList) do
        local targetBattleType = roundInfo:GetTargetBattleType()
        local selfBattleType = roundInfo:GetSelfBattleType()
        if ( (targetBattleType ~= BattleType.Monster and targetBattleType ~= BattleType.Boss) or
                (selfBattleType ~= BattleType.Formation and selfBattleType ~= BattleType.RallyFormation and selfBattleType ~= BattleType.BLACK_KNIGHT )) then
            return false
        end
    end
    return true
end

--是否只是和地块发生了战斗
function MailBattleReport:IsOnlyDesertBattle()
    for _, roundInfo in pairs(self._fightRoundList) do
        local targetBattleType = roundInfo:GetTargetBattleType()
        local selfBattleType = roundInfo:GetSelfBattleType()
        local list = roundInfo:GetLeaderHeroes()
        if ( (targetBattleType ~= BattleType.Desert and targetBattleType~=BattleType.TRAIN_DESERT) or
                selfBattleType ~= BattleType.Formation or table.count(list) > 0) then
            return false
        end
    end
    return true
end

--战报这里检查三个活动boss和遗迹
function MailBattleReport:IsOnlyPveBattle()
    for _, roundInfo in pairs(self._fightRoundList) do
        local targetBattleType = roundInfo:GetTargetBattleType()
        local selfBattleType = roundInfo:GetSelfBattleType()
        if ( (targetBattleType ~= BattleType.ACT_BOSS and targetBattleType~=BattleType.PUZZLE_BOSS and targetBattleType~=BattleType.CHALLENGE_BOSS
                and targetBattleType ~= BattleType.ALLIANCE_NEUTRAL_CITY and targetBattleType ~= BattleType.ALLIANCE_CITY_GUARD and targetBattleType ~= BattleType.ALLIANCE_BUILD_GUARD) or
                selfBattleType ~= BattleType.Formation) then
            return false
        end
    end
    return true
end

function MailBattleReport:GetCanRePlay()
    local canShow = false
    if table.count(self._fightRoundList)==1 and self:GetTotalRoundCnt() ==1 then
        local roundInfo = self._fightRoundList[1]
        if roundInfo~=nil then
            local targetBattleType = roundInfo:GetTargetBattleType()
            local selfBattleType = roundInfo:GetSelfBattleType()
            if (targetBattleType== BattleType.Monster or targetBattleType == BattleType.Formation or targetBattleType == BattleType.BLACK_KNIGHT) and (selfBattleType == BattleType.Formation ) then
                canShow =  true
            elseif targetBattleType== BattleType.ELITE_FIGHT_MAIL and targetBattleType == BattleType.ELITE_FIGHT_MAIL then
                canShow =  true
            elseif targetBattleType== BattleType.PVE_MARCH or selfBattleType == BattleType.PVE_MARCH then
                canShow =  true
            end
        end
    end
    return canShow
end

function MailBattleReport:GetVersion()
    return self.version
end

function MailBattleReport:GetHeroDict(isSelf)
    local round = self._fightRoundList[1]
    if round then
        local armyResult = isSelf and round:GetSelfArmyResult() or round:GetOtherArmyResult()
        if armyResult then
            local armyObj = armyResult:GetArmyObj()
            return armyObj:GetPlayerHeroes() or {}
        end
    end
    return {}
end

--获取进攻方的名字
function MailBattleReport:GetAttackSideName()
    if self:IsMyAttackCity() then
        return self:GetSelfName_ForShare()
    end
    return self:GetTargetName_ForShare()
end

--获取防守方的名字
function MailBattleReport:GetDefendSideName()
    if self:IsMyProtectCity() then
        return self:GetSelfName_ForShare()
    end
    return self:GetTargetName_ForShare()
end

-- 是否存在黑骑士战斗
function MailBattleReport:IsExistBlackKnightBattle()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetTargetBattleType()
        if (tBattleType == BattleType.BLACK_KNIGHT) then
            local info = roundItem:GetTargetInfo()
            if info ~= nil then
                local special = DataCenter.MonsterTemplateManager:GetTableValue(info.monsterId, "special")
                if  special == MonsterSpecialType.BlackKnight then
                    return true
                end
            end
        end
    end
    return false
end

-- 是否存在远征对决战斗
function MailBattleReport:IsExistExpeditionaryDuelBattle()
    for _, roundItem in pairs(self._fightRoundList) do
        local tBattleType = roundItem:GetTargetBattleType()
        if (tBattleType == BattleType.BLACK_KNIGHT) then
            local info = roundItem:GetTargetInfo()
            if info ~= nil then
                local special = DataCenter.MonsterTemplateManager:GetTableValue( info.monsterId, "special")
                if special == MonsterSpecialType.ExpeditionaryDuel then
                    return true
                end
            end
        end
    end
    return false
end
-- 获取所有资源奖励
function MailBattleReport:GetFightResItemArr(uuid)
    local rewardList = {}
    for _, oneFight in pairs(self._fightRoundList) do
        local arr = oneFight:GetFightResArrByUserUid(uuid)
        if arr ~= nil then
            for resourceType, count in pairs(arr) do
                rewardList[resourceType] = rewardList[resourceType] and rewardList[resourceType] + count or count
            end
        end
    end
    return rewardList
end

-- 获取所有怪物id
function MailBattleReport:GetMonsterIds()
    local result = {}
    local has = {}
    local monsterId
    for _, oneFight in pairs(self._fightRoundList) do
        local info = oneFight:GetTargetInfo()
        if info ~= nil then
            monsterId = info.monsterId
            if monsterId ~= nil and not has[monsterId] then
                has[monsterId] = true
                table.insert(result, monsterId)
            end
        end
    end
    return result
end

-- 是否是uid去援助别人
function MailBattleReport:IsHelpOther(uid)
    if string.IsNullOrEmpty(uid) then
        return false
    end
    
    local round = self._fightRoundList[1]
    if round then
        local selfInfo = round:GetSelfInfo()
        if uid == selfInfo.uid then
            return false
        end
        local otherInfo = round:GetOtherInfo()
        if uid == otherInfo.uid then
            return false
        end
    end
    
    return true
end

function MailBattleReport:IsDefenceShowRound(showRoundIndex)
    local showData = self:GetShowRoundListDataByIndex(showRoundIndex)
    if showData then
        if showData.leftData.specialType == SpecialUnitType.TRAP or
           showData.rightData.specialType == SpecialUnitType.TRAP or
           showData.leftData.specialType == SpecialUnitType.TOWER or
           showData.rightData.specialType == SpecialUnitType.TOWER then
            return true
        end
    end
    return false
end

return MailBattleReport