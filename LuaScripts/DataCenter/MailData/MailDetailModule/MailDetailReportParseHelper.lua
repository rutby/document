---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mac.
--- DateTime: 8/11/21 3:25 PM
---
local BuffMgr = require "DataCenter.MailData.MailDetailModule.MailDetailBuffMgr"
local ActionItem = require "DataCenter.MailData.MailDetailModule.MailDetailActionItem"
---------------------------------------------------------------- ReportDetail ---------------------------------------------------------
--[[ 
// 详细战报
message BattleDetailInfo {
	repeated BaseRoundReport roundReports = 1;
	repeated EffectRoundReport effectReports = 2;
	repeated DetailReportPlayerInfo playerInfos = 3;// 详细战报玩家信息
}

    功能:
        在拿到服务器的数据后需要做文字战报解析的服务
        
    大体流程:
        在服务器返回的数据中,计算出startRoundIndex, endRoundIndex,然后遍历 roundReports / effectReports
        如果roundReport存在[有可能会有多个] 这个表示释放技能,普攻这种动作描述
        如果effectReports存在,则需要进入自己维护的列表中,在接下来的round中要获取当前轮次身上的buff状态
    
    local AllReports = { [roundIdx] = {[Action] = { xxxx-list }, [Buff] = { xxx-list }} }
    之后可以直接获取指定一轮的数据,进行显示
]]
local MailDetailReportParseHelper = {}

function MailDetailReportParseHelper:InitData()
    self._minIndex = 0
    self._maxIndex = 0
    self._allDetails = {}
    self._healthList = {}
end

function MailDetailReportParseHelper:AddEffectData( effectlist, roundIdx )
    if (self._allDetails[roundIdx] == nil) then
        self._allDetails[roundIdx] = {}
    end
    self._allDetails[roundIdx]["BUFF"] = effectlist
end

function MailDetailReportParseHelper:AddActionData( actionlist, roundIdx )
    if (self._allDetails[roundIdx] == nil) then
        self._allDetails[roundIdx] = {}
    end
    self._allDetails[roundIdx]["ACTION"] = actionlist
end

function MailDetailReportParseHelper:AddLeftSpecialSkill(skillList,roundIdx)
    if skillList ==nil or #skillList<=0 then
        return
    end
    if (self._allDetails[roundIdx] == nil) then
        self._allDetails[roundIdx] = {}
    end
    self._allDetails[roundIdx]["SPECIAL_SELF"] = skillList
end
function MailDetailReportParseHelper:AddRightSpecialSkill(skillList,roundIdx)
    if skillList ==nil or #skillList<=0 then
        return
    end
    if (self._allDetails[roundIdx] == nil) then
        self._allDetails[roundIdx] = {}
    end
    self._allDetails[roundIdx]["SPECIAL_OTHER"] = skillList
end

-- 计算回合中最大/小回合数
function MailDetailReportParseHelper:SetIndexRange( detailData )
    -- 获取最大
    local roundReports = self._roundReports
    local effectReports = self._effectReports
    if (not table.IsNullOrEmpty(roundReports)) then
        self._minIndex = roundReports[1]["round"]
        self._maxIndex = roundReports[#roundReports]["round"]
    end
    if (not table.IsNullOrEmpty(effectReports)) then
        local e_minIndex = effectReports[1]["baseReport"]["round"]
        local e_maxIndex = effectReports[#effectReports]["baseReport"]["round"]
        self._minIndex = self._minIndex > e_minIndex and e_minIndex or self._minIndex
        self._maxIndex = self._maxIndex > e_maxIndex and self._maxIndex or e_maxIndex
    end
end

--[[
 返回Round
 在这个里面需要处理 如果在遍历中遇到了type=7的类型的表示使用技能,需要将 attid+defid+skillid相同的type=1的都给他.这才表示完整的一个技能打击
 好无奈啊！！！
]]
function MailDetailReportParseHelper:GetActionList( findIndex )
    local roundList = {}
    
    local function InsertActionItem( actionItem )
        local tbCnt = table.count(roundList)
        if (tbCnt == 0) then
            return false
        end
        for i = tbCnt, 1, -1 do
            local _action = roundList[i]
            if (_action:IsBelongThisSkill(actionItem)) then
                _action:AddSkillTarget(actionItem)
                return true
            end
        end
        return false
    end
    
    -- 筛选进入辅助列表
    for key, reportItem in pairs(self._roundReports) do
        if (reportItem ~= nil and reportItem["round"] == findIndex) then
            local actionItem = ActionItem.New()
            actionItem:InitData(reportItem, self._playerInfos)
            -- 检测是否是type=1的技能攻击,如果是的话,需要向前找到该技能的发起方
            if (actionItem:IsSubActionItem()) then
                local a = 1
            end
            if (actionItem:IsSubActionItem() and InsertActionItem(actionItem)) then
            else
                roundList[#roundList+1] = actionItem
            end
            self._roundReports[key] = nil
        elseif (reportItem ~= nil and reportItem["round"] > findIndex) then
            break
        end
    end
    return roundList
end

-- 返回Effect
function MailDetailReportParseHelper:GetEffectList( findIndex )
    local effectList = {}
    -- 筛选进入辅助列表
    for key, effectItem in pairs(self._effectReports) do
        if (effectItem ~= nil and effectItem["baseReport"] ~= nil and effectItem["baseReport"]["round"] == findIndex) then
            effectList[#effectList+1] = effectItem
            self._roundReports[key] = nil
        elseif (effectItem ~= nil and effectItem["baseReport"] ~= nil and effectItem["baseReport"]["round"] > findIndex) then
            break
        end
    end
    return effectList
end

--[[ 构建玩家信息 这个地方使用玩家的index作为key,方便后续查找 ]]
function MailDetailReportParseHelper:InitPlayerInfo( playerInfos )
    playerInfos = playerInfos or {}
    if (self._playerInfos == nil) then
        self._playerInfos = {}
    end
    for _, userinfo in pairs(playerInfos) do
        self._playerInfos[userinfo["index"]] = userinfo
    end
end

function MailDetailReportParseHelper:ClearData()
    self:InitData()
    BuffMgr:ClearData()
end

function MailDetailReportParseHelper:ParseData( detailData, selfHealth, otherHealth,selfSpSkillList,otherSpSkillList)
    BuffMgr:ClearData()
    self:InitData()
    self._roundReports = detailData["roundReports"] or {}
    self._effectReports = detailData["effectReports"] or {}
    self:InitPlayerInfo(detailData["playerInfos"])
    -- 计算区间   
    self:SetIndexRange(detailData)
    self:InitHeathList()
    local initData = self._healthList[self._minIndex]
    local initSelfHealth = selfHealth
    local initOtherHealth = otherHealth
    if initData~=nil then
        initSelfHealth= initData.self.total
        initOtherHealth = initData.other.total
    end
    for index = self._minIndex, self._maxIndex do
        -- Buff效果处理 需要加入本地EffectMgr中,在后续round中通过isBuffActive来处理,查看是否生效
        if index>1 then
            local beforeHealth = self._healthList[index-1]
            if beforeHealth~=nil then
                local LSkillList = self:GetSpecialSkillList(selfHealth,beforeHealth["self"]["total"],selfSpSkillList)
                self:AddLeftSpecialSkill(LSkillList,index)
                local RSkillList = self:GetSpecialSkillList(otherHealth,beforeHealth["other"]["total"],otherSpSkillList)
                self:AddRightSpecialSkill(RSkillList,index)
            end
        end
        local effectList = self:GetEffectList(index)
        for k, effectitem in pairs(effectList) do
            BuffMgr:AddBuffItem(effectitem, self._playerInfos)
        end
        -- 获取当前轮次生效的Buff
        local activeBuff = BuffMgr:GetActiveBuffList(index)
        self:AddEffectData(activeBuff, index)
        -- 获取当前的action
        local actionlist = self:GetActionList(index)
        self:AddActionData(actionlist, index)
        
        -- 计算伤害值
        local myValue = 0
        local otherValue = 0
        -- 计算当前
        for _, actionItem in pairs(actionlist) do
            -- 如果是攻击类型的需要筛选其target
            if (actionItem:GetActionItemType() == eMailDetailActionType.USE_SKILL) then
                local subItem = actionItem:GetSkillTarget()
                for _, v in pairs(subItem) do
                    local actionValue = v:GetValue()
                    if (not table.IsNullOrEmpty(actionValue)) then
                        local side = actionValue["side"]
                        local value = actionValue["value"]
                        if (side == eMailDetailTroopSide.Self) then
                            myValue = myValue + value
                        else
                            otherValue = otherValue + value
                        end
                    end
                end
            end
            
            local actionValue = actionItem:GetValue()
            if (not table.IsNullOrEmpty(actionValue)) then
                local side = actionValue["side"]
                local value = actionValue["value"]
                if (side == eMailDetailTroopSide.Self) then
                    myValue = myValue + value
                else
                    otherValue = otherValue + value
                end
            end
        end
        local param = self._healthList[index]
        if param~=nil then
            if param.self~=nil then
                param.self.demage = myValue
            end
            if param.other~=nil then
                param.other.demage = otherValue
            end
        end
        
        --
        --if (initSelfHealth <= 0 or initOtherHealth <= 0) then
        --    self._maxIndex = index
        --    break
        --end
        --initSelfHealth = initSelfHealth + myValue
        --initSelfHealth = initSelfHealth > 0 and initSelfHealth or 0
        --initOtherHealth = initOtherHealth + otherValue
        --initOtherHealth = initOtherHealth > 0 and initOtherHealth or 0
    end
end

function MailDetailReportParseHelper:InitHeathList()
    self._healthList = {}
    for key, reportItem in pairs(self._roundReports) do
        local index = reportItem["round"]
        if self._healthList[index] == nil then
            local oneData = {}
            oneData.self = {}
            oneData.self.total = 0
            oneData.self.demage = 0
            oneData.other = {}
            oneData.other.total = 0
            oneData.other.demage = 0
            self._healthList[index] = oneData
        end
        local health = reportItem["health"]
        local targetId = reportItem["targetIndex"]
        local userinfo = self._playerInfos[targetId] or {}
        if (userinfo["isSelf"] == true) then
            self._healthList[index].self.total = health
        else
            self._healthList[index].other.total = health
        end
    end
end
function MailDetailReportParseHelper:GetHealthByIndex(roundIdx)
    return self._healthList[roundIdx] or {}
end

function MailDetailReportParseHelper:GetMinIndex()
    return self._minIndex or 0
end

function MailDetailReportParseHelper:GetMaxIndex()
    return self._maxIndex or 0
end

function MailDetailReportParseHelper:GetInfoByIndex( index )
    return self._allDetails[index] or {}
end

function MailDetailReportParseHelper:GetSpecialSkillList(initHealth,curHealth,skillList)
    if skillList ==nil or #skillList<=0 then
        return {}
    end
    local showSkillList = {}
    local percent = curHealth*100/math.max(1,initHealth)
    for i =1,#skillList do
        local skillData = skillList[i]
        local minPercent = skillData.minPercent
        local maxPercent = skillData.maxPercent
        if maxPercent~=nil and maxPercent~=nil then
            if maxPercent>=percent and minPercent<=percent then
                table.insert(showSkillList,skillData)
            end
        end
    end
    return showSkillList
end
return MailDetailReportParseHelper