---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2023/1/3 22:19
---

local KeepPayManager = BaseClass("KeepPayManager")
local KeepPayData = require "DataCenter.KeepPay.KeepPayData"

--[[
    data: KeepPayData
    stage: Table { id, needScore, reward, state, level }
]]

local function __init(self)
    self.dataDict = {} -- Dict<id, KeepPayData>
    self:AddListeners()
end

local function __delete(self)
    self.dataDict = nil
    self:RemoveListeners()
end

local function AddListeners(self)

end

local function RemoveListeners(self)

end

local function GetData(self, id)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local data = self.dataDict[tonumber(id)]
    if data ~= nil and curTime >= data.startTime and curTime <= data.endTime then
        return data
    else
        return nil
    end
end

local function IsOpen(self)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    for _, data in pairs(self.dataDict) do
        if curTime >= data.startTime and curTime <= data.endTime then
            return true
        end
    end
    return false
end

local function SendGetInfo(self, id)
    SFSNetwork.SendMessage(MsgDefines.GetRechargeInfo, id)
end

local function SendReceiveReward(self, id, stageId)
    SFSNetwork.SendMessage(MsgDefines.ReceiveRechargeReward, id, stageId)
end

local function HandleInit(self, message)
    if message["rechargeArr"] then
        local curTime = UITimeManager:GetInstance():GetServerTime()
        for _, v in ipairs(message["rechargeArr"]) do
            if v.rechargeType == RechargeType.KeepPay then
                local data = KeepPayData.New(v.rechargeId)
                data.startTime = v.startTime
                data.endTime = v.endTime
                data.rechargeType = v.rechargeType
                data.stages = {}
                data.score = 0
                data.lastRewardTime = 0
                data.scoreTime = curTime
                self.dataDict[data.id] = data
                self:SendGetInfo(data.id)
                EventManager:GetInstance():Broadcast(EventId.KeepPayUpdate, data.id)
                EventManager:GetInstance():Broadcast(EventId.RefreshWelfareRedDot)
            end
        end
    end
end

local function HandleGetInfo(self, message)
    local id = message["rechargeId"]
    local data = self.dataDict[id]
    if data then
        local curTime = UITimeManager:GetInstance():GetServerTime()
        for _, v in ipairs(message["rechargeStageArr"]) do
            local stage = {}
            stage.id = v.stageId
            stage.needScore = v.needScore
            stage.rewards = DataCenter.RewardManager:ReturnRewardParamForView(v.reward)
            stage.state = v.state
            stage.level = v.lv
            data.stages[stage.level] = stage
        end
        data.score = message["score"]
        data.lastRewardTime = message["lastRewardTime"]
        data.scoreTime = curTime
        EventManager:GetInstance():Broadcast(EventId.KeepPayUpdate, id)
        EventManager:GetInstance():Broadcast(EventId.RefreshWelfareRedDot)
    end
end

local function HandleReceiveReward(self, message)
    local id = message["rechargeId"]
    local data = self.dataDict[id]
    if data then
        for _, stage in pairs(data.stages) do
            if stage.id == message["stageId"] then
                stage.state = 1
                break
            end
        end
        for _, v in ipairs(message["reward"]) do
            DataCenter.RewardManager:AddOneReward(v)
        end
        DataCenter.RewardManager:ShowCommonReward(message)
        data.lastRewardTime = message["lastRewardTime"]
        EventManager:GetInstance():Broadcast(EventId.KeepPayUpdate, id)
        EventManager:GetInstance():Broadcast(EventId.RefreshWelfareRedDot)
    end
end

local function HandleScore(self, message)
    local id = message["rechargeId"]
    local data = self.dataDict[id]
    if data then
        data.score = message["score"]
        EventManager:GetInstance():Broadcast(EventId.KeepPayUpdate, id)
        EventManager:GetInstance():Broadcast(EventId.RefreshWelfareRedDot)
    end
end

local function HandleNew(self, message)
    if message["rechargeType"] == RechargeType.KeepPay then
        local data = KeepPayData.New(message["rechargeId"])
        data.startTime = message["startTime"]
        data.endTime = message["endTime"]
        data.rechargeType = message["rechargeType"]
        data.stages = {}
        data.score = 0
        data.lastRewardTime = 0
        self.dataDict[data.id] = data
        EventManager:GetInstance():Broadcast(EventId.KeepPayUpdate, data.id)
        EventManager:GetInstance():Broadcast(EventId.RefreshWelfareRedDot)
    end
end

KeepPayManager.__init = __init
KeepPayManager.__delete = __delete
KeepPayManager.AddListeners = AddListeners
KeepPayManager.RemoveListeners = RemoveListeners

KeepPayManager.GetData = GetData
KeepPayManager.IsOpen = IsOpen

KeepPayManager.SendGetInfo = SendGetInfo
KeepPayManager.SendReceiveReward = SendReceiveReward

KeepPayManager.HandleInit = HandleInit
KeepPayManager.HandleGetInfo = HandleGetInfo
KeepPayManager.HandleReceiveReward = HandleReceiveReward
KeepPayManager.HandleScore = HandleScore
KeepPayManager.HandleNew = HandleNew

return KeepPayManager