---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2023/8/18 14:12
---

local StoryManager = BaseClass("StoryManager")

local ShowBubblePercent = 0.25--显示气泡百分比25%

local function __init(self)
    self.maxLevel = 0 -- 最大关卡数
    self.level = 0 -- 已通关等级
    self.startTime = 0 -- 开始挂机时间
    self.hangupTime = 0 -- 挂机上次结算时间
    self.rankList = {}
    self.selfRank = 0
    self.selfScore = 0
    self.hangupReward = {} -- 挂机奖励1
    self.hangupRemainReward = {} -- 挂机奖励2
    self.hangupRewardTime = 0 -- 上次同步挂机奖励时间
    self.autoNext = false
    self.finish_timer_callback = function() 
        self:FinishTimerCallback()
    end
    self:AddListeners()
end

local function __delete(self)
    self:RemoveListeners()
end

local function AddListeners(self)
    
end

local function RemoveListeners(self)
    
end

local function Enabled(self)
    if not LuaEntry.DataConfig:CheckSwitch("push_map") then
        return false
    end
    local mainLv = DataCenter.BuildManager.MainLv
    local needLv = self:GetEnableMainLv()
    return mainLv >= needLv
end

local function Startup(self)
    
end

local function GetEnableMainLv(self)
    local needLv = 0
    local str = LuaEntry.DataConfig:TryGetStr("push_level", "k6")
    local spls = string.split(str, "|")
    if LuaEntry.Player.abTest == ABTestType.A then
        needLv = tonumber(spls[1]) or 0
    elseif LuaEntry.Player.abTest == ABTestType.B then
        needLv = tonumber(spls[2]) or 0
    end
    return needLv
end

local function GetConfig(self, id)
    local config = LocalController:instance():getLine(TableName.StoryMap, id)
    return config
end

local function GetCurLevel(self)
    return self.level
end

local function GetMaxLevel(self)
    if self.maxLevel == 0 then
        for level = 1, 100000 do
            if self:GetConfig(level) == nil then
                self.maxLevel = level - 1
                break
            end
        end
    end
    return self.maxLevel
end

-- 开始 PVE
local function StartPve(self, id)
    Logger.Log(string.format("StoryManager, StartPve, id = %s", id))
    local config = self:GetConfig(id)
    local param = {}
    param.levelId = config.pve
    param.storyLevel = config.level
    param.pveEntrance = PveEntrance.Story
    DataCenter.BattleLevel:Enter(param)
end

-- 挂机上次结算时间
local function GetHangupTime(self)
    return self.hangupTime
end

-- 挂机收益最大时间
local function GetMaxHangupTime(self)
    local t = LuaEntry.DataConfig:TryGetNum("push_level", "k2") -- 时
    return t * 3600000
end

-- 挂机收益最小时间
local function GetMinHangupTime(self)
    local t = LuaEntry.DataConfig:TryGetNum("push_level", "k3") -- 秒
    return t * 1000
end

-- 挂机收益各阶段时间
local function GetSteppedHangupTime(self)
    if self.steppedHangupTimeList == nil then
        self.steppedHangupTimeList = {}
        local k4 = LuaEntry.DataConfig:TryGetStr("push_level", "k4") -- 秒
        for _, str in ipairs(string.split(k4, ";")) do
            table.insert(self.steppedHangupTimeList, tonumber(str) * 1000)
        end
    end
    return self.steppedHangupTimeList
end

-- 展示排行榜需要的大本等级
local function GetRankNeedMainLevel(self)
    return LuaEntry.DataConfig:TryGetNum("push_level", "k1")
end

local function GetHangupRewardByTime(self, curTime)
    local tempRewardList = {}
    tempRewardList[1] = self:GetHangupProductPerHour()
    local maxTime = DataCenter.StoryManager:GetMaxHangupTime()
    local addTime = math.max(math.min(curTime, self.hangupTime + maxTime) - self.hangupRewardTime, 0)
    for _, v in ipairs(tempRewardList[1]) do
        v.count = v.count * addTime / 3600000
    end
    
    tempRewardList[2] = self.hangupReward
    tempRewardList[3] = self.hangupRemainReward
    
    local rewardList = {}
    for i = 1, 3 do
        for _, v in ipairs(tempRewardList[i]) do
            local found = false
            for _, u in ipairs(rewardList) do
                if u.rewardType == v.rewardType and u.itemId == v.itemId then
                    u.count = u.count + v.count
                    found = true
                    break
                end
            end
            if not found then
                table.insert(rewardList, DeepCopy(v))
            end
        end
    end
    for _, v in ipairs(rewardList) do
        v.count = math.floor(v.count)
    end
    return rewardList
end

local function GetHangupProductPerHour(self)
    local rewardList = {}
    local config = self:GetConfig(self.level)
    for _, str in ipairs(string.split(config.reward_hang, "|")) do
        local spls = string.split(str, ";")
        if #spls == 3 then
            local type = tonumber(spls[1])
            if type == 0 then
                local reward = {}
                reward.rewardType = ResTypeToReward[tonumber(spls[2])]
                reward.count = tonumber(spls[3])
                table.insert(rewardList, reward)
            elseif type == 1 then
                local reward = {}
                reward.rewardType = RewardType.GOODS
                reward.itemId = spls[2]
                reward.count = tonumber(spls[3])
                table.insert(rewardList, reward)
            end
        end
    end
    return rewardList
end

local function SendGetHangupReward(self)
    SFSNetwork.SendMessage(MsgDefines.GetStoryTimeReward)
end

local function SendReceiveHangupReward(self)
    SFSNetwork.SendMessage(MsgDefines.ReceiveStoryTimeReward)
end

local function SendGetRank(self)
    SFSNetwork.SendMessage(MsgDefines.GetStoryRank)
end

local function SendPveBattle(self, level, heroes, formations, pass)
    SFSNetwork.SendMessage(MsgDefines.FinishStoryPve, level, heroes, formations, pass)
end

local function HandleInit(self, message)
    if message["storyInfo"] then
        local info = message["storyInfo"]
        if info.lv then
            self.level = info.lv
        end
        if info.startTime then
            self.hangupTime = info.startTime
        end
        self:CheckFinishTimer()
    end
end

local function HandleUpdateHangupTime(self, message)
    if message["startTime"] then
        self.hangupTime = message["startTime"]
        EventManager:GetInstance():Broadcast(EventId.StoryUpdateHangupTime)
        self:CheckFinishTimer()
    end
end

local function HandleGetHangupReward(self, message)
    if message["startTime"] then
        self.hangupTime = message["startTime"]
        EventManager:GetInstance():Broadcast(EventId.StoryUpdateHangupTime)
    end
    if message["reward"] then
        self.hangupReward = DataCenter.RewardManager:ReturnRewardParamForView(message["reward"]) or {}
        self.hangupRewardTime = UITimeManager:GetInstance():GetServerTime()
        EventManager:GetInstance():Broadcast(EventId.StoryGetHangupReward)
    end
    if message["remainReward"] then
        self.hangupRemainReward = {}
        for _, str in ipairs(string.split(message["remainReward"], "|")) do
            local spls = string.split(str, ";")
            if #spls == 3 then
                local type = tonumber(spls[1])
                if type == 0 then
                    local reward = {}
                    reward.rewardType = ResTypeToReward[tonumber(spls[2])]
                    reward.count = tonumber(spls[3])
                    table.insert(self.hangupRemainReward, reward)
                elseif type == 1 then
                    local reward = {}
                    reward.rewardType = RewardType.GOODS
                    reward.itemId = spls[2]
                    reward.count = tonumber(spls[3])
                    table.insert(self.hangupRemainReward, reward)
                end
            end
        end
    end
    self:CheckFinishTimer()
end

local function HandleReceiveHangupReward(self, message)
    if message["startTime"] then
        self.hangupTime = message["startTime"]
        EventManager:GetInstance():Broadcast(EventId.StoryUpdateHangupTime)
    end
    if message["reward"] then
        for _, v in pairs(message["reward"]) do
            DataCenter.RewardManager:AddOneReward(v)
        end
        self.hangupReward = {}
        DataCenter.RewardManager:ShowCommonReward(message)
        EventManager:GetInstance():Broadcast(EventId.StoryReceiveHangupReward, message)
    end
    if message["remainReward"] then
        
    end
    self:CheckFinishTimer()
end

local function HandleGetRank(self, message)
    if message["rankList"] then
        self.rankList = message["rankList"]
    end
    if message["selfRank"] then
        self.selfRank = message["selfRank"]
    end
    if message["selfScore"] then
        self.selfScore = message["selfScore"]
    end
    EventManager:GetInstance():Broadcast(EventId.StoryGetRank)
end

local function HandlePveBattle(self, message)
    if message["storyInfo"] then
        local info = message["storyInfo"]
        if info.lv then
            self.level = info.lv
        end
        if info.startTime then
            self.hangupTime = info.startTime
        end
    end

    if message["reward"] then
        for _, v in pairs(message["reward"]) do
            DataCenter.RewardManager:AddOneReward(v)
        end
        self.reward = message["reward"]
    else
        self.reward = {}
    end

    local battleContent = PveUtil.ParseBattleContent(message)
    local detailContent = PveUtil.ParseDetailContent(message)
    PveActorMgr:GetInstance():ParseData(battleContent, detailContent)
    self:CheckFinishTimer()
end

local function HandleUpdate(self, message)
    if message["storyInfo"] then
        local info = message["storyInfo"]
        if info.lv then
            self.level = info.lv
        end
        if info.startTime then
            self.hangupTime = info.startTime
            EventManager:GetInstance():Broadcast(EventId.StoryUpdateHangupTime)
        end
    end
end

--判断是否需要添加挂机奖励气泡的计时器
function StoryManager:CheckFinishTimer()
    self:DeleteFinishTimer()
    if self:Enabled() then
        local curTime = UITimeManager:GetInstance():GetServerTime()
        local showBubbleTime = self:GetShowBubbleTime()
        local hangupTime = self:GetHangupTime()
        local left = showBubbleTime - curTime + hangupTime
        if left > 0 then
            self:AddFinishTimer(left / 1000)
        else
            EventManager:GetInstance():Broadcast(EventId.ShowStoryRewardBubble)
        end
    end
end

function StoryManager:DeleteFinishTimer()
    if self.finish_timer ~= nil then
        self.finish_timer:Stop()
        self.finish_timer = nil
    end
end

function StoryManager:AddFinishTimer(time)
    if self.finish_timer == nil then
        self.finish_timer = TimerManager:GetInstance():GetTimer(time, self.finish_timer_callback, self, true, false, false)
        self.finish_timer:Start()
    end
end

function StoryManager:FinishTimerCallback()
    self:DeleteFinishTimer()
    EventManager:GetInstance():Broadcast(EventId.ShowStoryRewardBubble)
end

-- 挂机时间是否最大
function StoryManager:IsHangUpTimeMaxed()
    if self:Enabled() then
        local hangupTime = self:GetHangupTime()
        local curTime = UITimeManager:GetInstance():GetServerTime()
        local maxTime = DataCenter.StoryManager:GetMaxHangupTime()
        local time = curTime - hangupTime
        if time >= maxTime then
            return true
        end
    end
    return false
end

-- 挂机气泡是否显示
function StoryManager:CanShowBubble()
    if self:Enabled() then
        local curTime = UITimeManager:GetInstance():GetServerTime()
        local showBubbleTime = self:GetShowBubbleTime()
        local hangupTime = self:GetHangupTime()
        local left = showBubbleTime - curTime + hangupTime
        if left <= 0 then
            return true
        end
    end
    return false
end

--获取显示气泡需要时间（间隔）
function StoryManager:GetShowBubbleTime()
    return self:GetMaxHangupTime() * ShowBubblePercent
end

StoryManager.__init = __init
StoryManager.__delete = __delete
StoryManager.AddListeners = AddListeners
StoryManager.RemoveListeners = RemoveListeners

StoryManager.Enabled = Enabled
StoryManager.GetEnableMainLv = GetEnableMainLv
StoryManager.GetConfig = GetConfig
StoryManager.GetCurLevel = GetCurLevel
StoryManager.GetMaxLevel = GetMaxLevel
StoryManager.StartPve = StartPve
StoryManager.GetHangupTime = GetHangupTime
StoryManager.GetMaxHangupTime = GetMaxHangupTime
StoryManager.GetMinHangupTime = GetMinHangupTime
StoryManager.GetSteppedHangupTime = GetSteppedHangupTime
StoryManager.GetRankNeedMainLevel = GetRankNeedMainLevel
StoryManager.GetHangupRewardByTime = GetHangupRewardByTime
StoryManager.GetHangupProductPerHour = GetHangupProductPerHour

StoryManager.SendGetHangupReward = SendGetHangupReward
StoryManager.SendReceiveHangupReward = SendReceiveHangupReward
StoryManager.SendGetRank = SendGetRank
StoryManager.SendPveBattle = SendPveBattle

StoryManager.HandleInit = HandleInit
StoryManager.HandleUpdateHangupTime = HandleUpdateHangupTime
StoryManager.HandleGetHangupReward = HandleGetHangupReward
StoryManager.HandleReceiveHangupReward = HandleReceiveHangupReward
StoryManager.HandleGetRank = HandleGetRank
StoryManager.HandlePveBattle = HandlePveBattle
StoryManager.HandleUpdate = HandleUpdate

return StoryManager
