---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by w.
--- DateTime: 2022/12/28 14:33
---
local Resource = CS.GameEntry.Resource
local PVEScenePath = "Assets/Main/Prefabs/PVELevel/%s/scene.prefab"
local PVEDecorationPath = "Assets/Main/Prefabs/PVELevel/%s/decoration.bytes"
local Const = require("Scene.LWBattle.Const")
local TouchWrapper = CS.BitBenderGames.TouchWrapper
local EventSystem = CS.UnityEngine.EventSystems.EventSystem
local Time = Time
local Plane = Plane
local Touch = CS.BitBenderGames.TouchWrapper
local AddKillEffect = "Assets/_Art/Effect_B/Prefab/Arms/APS/VFX_animal_grow_big.prefab"
local Physics = CS.UnityEngine.Physics

local base = require "DataCenter.LWBattle.Logic.LWBattleLogicInterface"
local Team = require "Scene.LWBattle.ParkourBattle.Team.Team"
local ParkourTeam = require "Scene.LWBattle.ParkourBattle.Team.ParkourTeam"
local ParkourBattleData = require "DataCenter.LWBattle.Logic.ParkourBattle.ParkourBattleData"
local MonsterManager = require "Scene.LWBattle.ParkourBattle.Monster.MonsterManager"
local DamageTextManager = require "DataCenter.ZombieBattle.DamageTextManager"
local EffectObjManager = require"Scene.LWBattle.EffectObj.EffectObjManager"
local TriggerEventManager = require"Scene.LWBattle.ParkourBattle.TriggerEvent.TriggerEventManager"
local StageEffectManager = require "Scene.LWBattle.StageEffect.StageEffectManager"

---@class ParkourBattleLogic
---@field team Scene.LWBattle.ParkourBattle.ParkourTeam
---@field data ParkourBattleData
local ParkourBattleLogic = BaseClass("ParkourBattleLogic",base);
local BulletManager = require"Scene.LWBattle.Bullet.BulletManager"
local UnitManager = require"Scene.LWBattle.BarrageBattle.Unit.UnitManager"

local DISPLACE_EPSILON=0.01--最小位移
local XCenter = Const.ParkourSceneCenter --场景中轴线
local FPS_SAMPLE_CD = 10 --fps采样周期

function ParkourBattleLogic:Enter(param)
    self.battleMgr = DataCenter.LWBattleManager
    self.data = ParkourBattleData.New(param.levelId)
    self.param = param
    self.levelId = param.levelId
    self.tryHeroes = param.tryHeroes or {} --关卡试用英雄
    self.winCondition = self.data.winCondition
    self.battleMgr.cameraOffset:Set(0,0,4)
    self.initComplete = false
    self.fingerDown = false
    self.lastFingerPosX = 36
    --Logger.Log("跑酷：Farm")
    self:ChangeStage(Const.ParkourBattleState.Ready)
    self.monsterMgr = MonsterManager.New()  ---@type Scene.LWBattle.ParkourBattle.Monster.MonsterManager
    self.bulletManager=BulletManager.New(self)---@type Scene.LWBattle.Bullet.BulletManager
    self.damageTextMgr = DamageTextManager.New()---@type DataCenter.ZombieBattle.DamageTextManager
    self.effectObjMgr=EffectObjManager.New(self)---@type Scene.LWBattle.EffectObj.EffectObjManager
    self.triggerEventMgr=TriggerEventManager.New(self)---@type Scene.LWBattle.ParkourBattle.TriggerEvent.TriggerEventManager
    self.stageEffectMgr = StageEffectManager.New(self)
    self:InitRVO()
    self.useTime = 0
    self.startFrame = Time.frameCount
    self.sampleCd = FPS_SAMPLE_CD
    self.sampleFrame = Time.frameCount
    self.lowestFps = 999--最低帧率（每十秒统计一次平均帧率，记录全场最小值）
    self.killNum = 0
    self.saveNum = 0
    self.killBossNum = 0
    self.unitMgr=UnitManager.New(self)---@type Scene.LWBattle.BarrageBattle.Unit.UnitManager
    self.unitGuid = 0
    self.boss = {}
    self.delayEvents = {}
    self.lastTriggerY = 0
    self.__event_handlers = {}
    self.goods={}
    self.auto = false   --自动进入，不需要选阵容
    self.selectHeroUuidDict = {} -- Dict<index, heroUuid>
    self:AddListener(EventId.OpenUI, self.OnOpenUI)
    self:AddListener(EventId.LWBattleBuffStart, self.OnBuffChange)
    self:AddListener(EventId.LWBattleBuffEnd, self.OnBuffChange)
    self:AddListener(EventId.ParkourBattleStart, self.OnParkourBattleStart)

    --塔防模式用来模拟小队位置
    self.defenseFakeTeamPosZ = self.data.initPosY
    self.endLine = self.data.endLine    --塔防模式模拟结束线移动
    self.defenseOffsetZ = 0             --塔防模式记录Z方向运动偏移量
    self.initMoveSpeedZ = self.data.moveSpeedZ
    
    self.battleType = self.data.battleType
    self.initUnitDeath = false --初始单位阵亡
    
    self.heroIdReplaceSkillMap = nil
    self.heroIdReplaceAppearanceMap = nil
    self.battleResult = Const.BattleResult.None
end

function ParkourBattleLogic:__delete()
    self:Destroy()
end

function ParkourBattleLogic:InitCamera()
    self.camera = self.battleMgr.camera
    --self.hudCamera = self.battleMgr.hudCamera
    self.touchCamera = self.battleMgr.touchCamera
    self.touchCamera.CanMoveing = false

    self:InitCameraParams()
    local touchInput = self.battleMgr.touchCamera.touchInput
    self.onFingerDown = function(pos)
        self:OnFingerDown(pos)
    end
    self.onFingerUp = function()
        self:OnFingerUp()
    end

    touchInput:OnFingerDown('+', self.onFingerDown)
    touchInput:OnFingerUp('+', self.onFingerUp)
end

function ParkourBattleLogic:UnInitCamera()
    if self.touchCamera and self.touchCamera.touchInput then
        local touchInput = self.touchCamera.touchInput
        self.touchCamera.CanMoveing = true

        if self.onFingerDown then
            touchInput:OnFingerDown('-', self.onFingerDown)
        end
        if self.onFingerUp then
            touchInput:OnFingerUp('-', self.onFingerUp)
        end
    end
end

function ParkourBattleLogic:InitCameraParams(pos)
    local cameraParam = self:GetCameraParam()
    local height = cameraParam.height
    local fov = cameraParam.fov
    self.touchCamera.CamZoom = height
    self.touchCamera.LodLevel = 1
    self.camera.fieldOfView = fov
    --self.hudCamera.fieldOfView = fov
    local offsetZ = self:GetOffsetZ(height, cameraParam.rotation)
    self.touchCamera:SetZoomParams(1, height, offsetZ, 25)
    self.defaultHeight = height
    self.touchCamera.CamZoomMin=20
    self.camera.transform.eulerAngles = Vector3.New(cameraParam.rotation, 0, 0)
end

function ParkourBattleLogic:InitRVO()
    self.rvoMgr = CS.LWBattleRVOManager()
    local timeStep = 0.033
    local neighborDist = 2
    local maxNeighbors = 8
    local timeHorizon = 1
    local timeHorizonObst = 1
    local radius = 1
    local maxSpeed = 20
    self.rvoMgr:InitLW(timeStep,neighborDist,maxNeighbors,timeHorizon,timeHorizonObst,radius,maxSpeed)
end

function ParkourBattleLogic:GetCameraParam(pos)
    local camera = {}
    camera.fov = 60
    camera.height = 20
    camera.rotation = 45
    return camera
end

--是否塔防模式
function ParkourBattleLogic:IsDefenseMode()
    return self.battleType == Const.ParkourBattleType.Defense
end

--手指开始按下
function ParkourBattleLogic:OnFingerDown(pos)
    if self.state == Const.ParkourBattleState.Ready then
        return
    end
    if not self.battleMgr.gameStart or self.battleMgr.gamePause or self.battleMgr.gameOver then
        EventManager:GetInstance():Broadcast(EventId.PveGuideStartDrag, {pos = pos})
        return
    end
    self.fingerDown = true
    if self.state == Const.ParkourBattleState.Farm then--跑酷阶段
        self:OnFingerDownLeftRight(pos)
    elseif self.state == Const.ParkourBattleState.Boss then--boss阶段使用摇杆
        self:OnFingerDownJoyStick(pos)
    end
end

--手指抬起
function ParkourBattleLogic:OnFingerUp()
    self.fingerDown = false
    if self.state == Const.ParkourBattleState.Boss then
        self:OnFingerUpJoyStick()
    end
end

--手指持续按下
function ParkourBattleLogic:OnFingerHold()
    if self.state == Const.ParkourBattleState.Ready then
        return
    end
    if self.state == Const.ParkourBattleState.Farm or self.state == Const.ParkourBattleState.BossHorizontal then--跑酷阶段 或 boss水平控制阶段
        self:OnFingerHoldLeftRight()
    elseif self.state == Const.ParkourBattleState.Boss then--boss阶段使用摇杆
        self:OnFingerHoldJoyStick()
    end
end


function ParkourBattleLogic:OnFingerDownLeftRight(pos)
    local ray = self.touchCamera:ScreenPointToRay(pos)
    local plane = Plane.New(Vector3.up,0)
    local hit,dis = plane:Raycast(ray)
    local hitPoint = ray:GetPoint(dis)
    self.lastFingerPosX = hitPoint.x
end

function ParkourBattleLogic:OnFingerHoldLeftRight()
    local pos = nil
    if Touch.TouchCount > 0 then
        local touch = Touch.Touches[0]
        pos = touch.Position
    end
    if not pos then
        return
    end
    local nowX = self.team:GetPosition().x
    local ray = self.touchCamera:ScreenPointToRay(pos)
    local plane = Plane.New(Vector3.up,0)
    local hit,dis = plane:Raycast(ray)
    local hitPoint = ray:GetPoint(dis)
    local delta = hitPoint.x - self.lastFingerPosX
    if math.abs(delta) < DISPLACE_EPSILON then
        self.hasHorizonMove=false
        return
    end
    self.hasHorizonMove=true
    local clamp = self:ClampMoveX(nowX + delta * self.data.moveDeltaMulti)
    self.lastFingerPosX = hitPoint.x
    self.team:MoveHorizontalTo(clamp)
end

--是否有水平位移
function ParkourBattleLogic:HasHorizonMove()
    return self.fingerDown and self.hasHorizonMove
end

function ParkourBattleLogic:ClampMoveArea(hitPoint)
    return Mathf.Clamp(hitPoint.x,31,41)
end

function ParkourBattleLogic:ClampMoveX(x)
    return Mathf.Clamp(x,31,41)
end

function ParkourBattleLogic:GetOffsetZ(height, rotation)
    return height / math.tan(rotation * math.pi / 180)
end

function ParkourBattleLogic:LoadScene(callBack)
    --Team
    --self.team = Team.New(self.data.initPosX,self.data.initPosY,self,self.data.meta.default_hero)
    --self.team = Team.New(self.data.initPosX,self.data.initPosY,self)
    self.team = ParkourTeam.New(self.data.initPosX,self.data.initPosY,self, self.data.meta.default_hero)
    self.team.speedX = self.data.moveSpeedX
    self.team.speedZ = self.initMoveSpeedZ
    
    self.defenseFakeTeamPosZ = self.team:GetPositionZ()
    
    local teamDefaultCount = self.team:GetMemberCount()
    self.auto = teamDefaultCount > 0
    if teamDefaultCount == 0 then
        --需要选阵容
        --读取阵型配置
        ---@type ArmyFormationInfo
        local squadData = DataCenter.ArmyFormationDataManager:GetTemplateFormationByIndex(1)
        local allHeroes = {}
        if squadData ~= nil then
            local heroes = squadData:GetAllHeroes()
            for slotIndex, heroUuid in pairs(heroes) do
                local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
                if heroData ~= nil then
                    allHeroes[slotIndex] = heroData
                end
            end
        end

        -- DS 无战术装备
        --local weaponData = DataCenter.TacticalWeaponManager:GetFirstWeaponInfo()
        self.team:InitHeroes(allHeroes)
        --local setId = squadData:GetLocalTWSkillChipSetId()
        --local skillChips = DataCenter.TWSkillChipManager:GetChipsByMasterSet(setId)
        --self.team:InitWeapon(weaponData,skillChips)
    end
    
    --Scene
    self.staticMgr = CS.PVEStaticManager()
    self.staticMgr:InitLW(10, 10)
    self.staticMgr:SetVisibleChunk(2)
    self.damageTextMgr:Init(self)

    
    local sceneCfgArr = self.data.sceneCfgArr
    self.sceneLoadRequest = {}
    self.finishedScene = 0
    --if DataCenter.LWGuideManager:GetCurGuideId() ~= GuideState.LevelOne or DataCenter.LWGuideManager:GetIsStart() then
        self.monsterMgr:Init(self) --屏蔽障礙
    --end
    local finalX = 0
    local finalZ = 0
    for _, sceneCfg in ipairs(sceneCfgArr) do
        local req = Resource:InstantiateAsync(string.format(PVEScenePath, sceneCfg.meta.asset))
        req:completed('+', function()
            local sceneRoot = req.gameObject.transform
            sceneRoot:Set_position(0, 0, sceneCfg.offset)
            self.finishedScene = self.finishedScene + 1
            if(self.finishedScene>= #self.data.sceneCfgArr) then
                -- 创建成功回调
                if callBack then
                    callBack()
                end
                if string.IsNullOrEmpty(self.data.meta.bgm) then
                    Logger.LogError("跑酷关卡bgm为空，levelId="..self.data.meta.id)
                else
                    CS.GameEntry.Sound:PlayBGMusicByName(self.data.meta.bgm)
                end
                self:LoadSceneComplete()
            end
        end)
        finalX = math.max(finalX, sceneCfg.meta.scene_size)
        finalZ = finalZ + sceneCfg.meta.scene_size
        table.insert(self.sceneLoadRequest,req)
        self.staticMgr:Append(string.format(PVEDecorationPath, sceneCfg.meta.asset),sceneCfg.offset)
    end
    if DataCenter.LWBattleManager:UseNewDetect() then
        self.unitMgr:SetArea(0, 0, finalX, finalZ, finalX, finalZ) --每个网格尺寸 1x1
    end
end

function ParkourBattleLogic:LoadSceneComplete()
    self.initComplete = true
    local pos = Vector3.New(XCenter,0,self.team:GetPositionZ())
    self.battleMgr:LookAt(pos)
    
    self:AddSceneUpdator()

    if not self.param.firstGuideStage then
        --新手第一关不在这里打开界面
        if self.auto then
            self:OnParkourBattleStart()
        else
            UIManager:GetInstance():OpenWindow(UIWindowNames.UIParkourFormation,{anim = true,UIMainAnim = UIMainAnimType.AllHide },self.param.levelId)
        end
    end

    local uiPveLoading = UIManager:GetInstance():GetWindow(UIWindowNames.UIPVELoading).View
    if uiPveLoading then
        uiPveLoading:Quit()
    end
end

function ParkourBattleLogic:AddSceneUpdator()
    if self.sceneUpdateTimer == nil then
        self.sceneUpdateTimer = function() self:SceneUpdate() end
        UpdateManager:GetInstance():AddUpdate(self.sceneUpdateTimer)
    end
end

function ParkourBattleLogic:RemoveSceneUpdator()
    if self.sceneUpdateTimer then
        UpdateManager:GetInstance():RemoveUpdate(self.sceneUpdateTimer)
        self.sceneUpdateTimer = nil
    end
end

function ParkourBattleLogic:SceneUpdate()

    if not self.touchCamera then
        return
    end

    if self.battleMgr.gameStart then
        return
    end

    if self.touchCamera then
        local tarPos = self.touchCamera:GetCameraTargetPos()
        local viewTile = SceneUtils.WorldToTile(tarPos)
        if self.staticMgr ~= nil then
            self.staticMgr:OnUpdate(viewTile.x, viewTile.y)
        end
    end

end

function ParkourBattleLogic:OnParkourBattleStart()
    self:RemoveSceneUpdator()
    self.heroStatisticalData = {makeDmg={}, takeDmg={}, death={}}
    if self.team then
        self.team:OnStartBattle(not self.auto)

        local heroes = self.team.teamUnits
        for _, hero in pairs(heroes) do
            local uuId = hero.hero.uuid
            local heroData = DataCenter.HeroDataManager:GetHeroByUuid(uuId)
            if heroData ~= nil or hero.hero.fromTemplate then
                self.heroStatisticalData.makeDmg[uuId] = 0
                self.heroStatisticalData.takeDmg[uuId] = 0
                self.heroStatisticalData.death[uuId] = false
            end
            
            hero:SetInitUnit()
        end
    end

    self.weaponStatisticalData = {makeDmg=0, takeDmg=0}

    if not UIManager:GetInstance():IsWindowOpen(UIWindowNames.UIParkourBattleMain) then
        --新手第一关不在这里打开界面
        local param = {}
        local onOpen = function()
            if self.mainUI then
                UIManager:GetInstance():DestroyWindow(UIWindowNames.UIParkourFormation)

                self.mainUI:ShowWinCondition(function()end, self.data.hideTitle)--BindCallback(self,self.SetGamePause,false))
                
                self:ReadyGo()
            end
        end
        param.onOpen = onOpen

        UIManager:GetInstance():OpenWindow(UIWindowNames.UIParkourBattleMain, { anim = true, UIMainAnim = UIMainAnimType.AllHide }, param)
        self.mainUI = UIManager:GetInstance():GetWindow(UIWindowNames.UIParkourBattleMain).View
    else
        self:ReadyGo()
    end
end

function ParkourBattleLogic:ReadyGo()

    self:ChangeStage(Const.ParkourBattleState.Farm)

    self.battleMgr:SetGameStart(true)

    --EventManager:GetInstance():Broadcast(EventId.GF_parkour_battle_start, {self.data.battleType, self.data.metaId})
    
end

function ParkourBattleLogic:OnUpdate()
    local deltaTime = Time.deltaTime
    Physics.Simulate(deltaTime)
    if self.state == Const.ParkourBattleState.Ready then
        return
    end
    if self.touchCamera then
        local tarPos = self.touchCamera:GetCameraTargetPos()
        local viewTile = SceneUtils.WorldToTile(tarPos)
        if self.staticMgr ~= nil then
            self.staticMgr:OnUpdate(viewTile.x, viewTile.y)
        end
    end

    if not self.battleMgr:IsPlayingShakeCamera() then
        self:UpdateCameraFollow()
    end

    self.bulletManager:OnUpdate()
    self.effectObjMgr:OnUpdate()
    self.damageTextMgr:OnUpdate()
    self.unitMgr:OnUpdate()
    local winCondition = self.winCondition

    if winCondition.winType ==  Const.ParkourWinType.FinishPoint or winCondition.winType ==  Const.ParkourWinType.KillBoss then
        if self.mainUI then
            self.mainUI:UpdateWinConditionBar()
        end
    end
    if self.state==Const.ParkourBattleState.Farm then
        if self.team:GetPositionZ() < self.endLine then
            --if self.team:GetPositionZ() < 30 then

        elseif  winCondition.winType == Const.ParkourWinType.FinishPoint then
            -- 成功走到终点 （3）
            self:OnBattleWin()
        else
            if self.data.teamBossControlState == Const.ParkourTeamBossControlState.AllDirection then
                self:ChangeStage(Const.ParkourBattleState.Boss)
            elseif self.data.teamBossControlState == Const.ParkourTeamBossControlState.Stay then
                self:ChangeStage(Const.ParkourBattleState.BossStay)
            elseif self.data.teamBossControlState == Const.ParkourTeamBossControlState.Horizontal then
                self:ChangeStage(Const.ParkourBattleState.BossHorizontal)
            end
        end
    end

    if self.fingerDown then
        self:OnFingerHold()
    end
    local playerPos = self.team:GetPosition()
    if self.rvoMgr ~= nil then
        self.rvoMgr:Update(playerPos.x, playerPos.z)
    end

    if self.monsterMgr ~= nil then
        if self.battleType == Const.ParkourBattleType.Defense then
            self.monsterMgr:UpdateDefense(self.team:GetPositionZ(), self.defenseOffsetZ)
        else
            self.monsterMgr:Update(self.team:GetPositionZ())
        end
    end
    
    self.team:Update()

    if self.battleType == Const.ParkourBattleType.Defense then
        self:UpdateDefenseFakeTeamPosZ()
    end
end

function ParkourBattleLogic:UpdateDefenseFakeTeamPosZ()

    local deltaTime = Time.deltaTime
    local position = self.defenseFakeTeamPosZ
    local add = self.initMoveSpeedZ * deltaTime
    local z = position + add
    self.defenseFakeTeamPosZ = z
    self.endLine = self.endLine - add
    self.defenseOffsetZ = self.defenseOffsetZ - add
    --self.team:SetPosition(position.x,z)
end

function ParkourBattleLogic:GetMoveSpeedZ()
    return self.initMoveSpeedZ
end

function ParkourBattleLogic:OnUpdateSec()
    self.useTime = self.useTime + 1
    self.sampleCd = self.sampleCd - 1
    if self.sampleCd<=0 then
        self.sampleCd = FPS_SAMPLE_CD
        local fps = (Time.frameCount-self.sampleFrame)/FPS_SAMPLE_CD
        self.sampleFrame = Time.frameCount
        if fps<self.lowestFps then
            self.lowestFps = fps
        end
    end
end


local velocity = Vector3.unity_vector3(0, 0, 0)
local smoothTime = 0.3
local tmpV1 = Vector3.New(0, 0, 0)
local tmpV2 = Vector3.New(0, 0, 0)
local tmpV3 = Vector3.New(0, 0, 1)
local LookOffset = 5
local LookOffsetBoss = 0
function ParkourBattleLogic:UpdateCameraFollow()
    if self.state==Const.ParkourBattleState.Exit then
        return
    end

    local v1 = self.battleMgr:GetFollowCameraTarget()
    
    tmpV1:Set(v1.x, v1.y, v1.z)

    if self.state==Const.ParkourBattleState.Boss then
        local teamPos = self.team:GetPosition()
        tmpV2:Set(teamPos.x, 0, teamPos.z + LookOffsetBoss)
    else
        tmpV2:Set(XCenter, 0, self.team:GetPositionZ()+LookOffset)
    end
    --tmpV3:Set(0,0,1)
    
    tmpV2.x = tmpV2.x + tmpV3.x * 0.3
    tmpV2.y = tmpV2.y + tmpV3.y * 0.3
    tmpV2.z = tmpV2.z + tmpV3.z * 0.3

    local distance = true
    if math.abs(tmpV1.x - tmpV2.x) < 0.01 and
            math.abs(tmpV1.y - tmpV2.y) < 0.01 and
            math.abs(tmpV1.z - tmpV2.z) < 0.01 then
        distance = false
        velocity.x, velocity.y, velocity.z = 0, 0, 0
    end

    if distance then
        local targetPos, v = Vector3.SmoothDamp(v1, tmpV2, velocity, smoothTime)
        velocity = v
        self.battleMgr:CameraFollowLookAt(targetPos)
    end
end

function ParkourBattleLogic:TeamObjectActive(isShow)
    self.team:SetActive(isShow)
end

--新手第一关timeline结束回调
function ParkourBattleLogic:MonsterInit()
    self:OnParkourBattleStart()
    self.monsterMgr:Init(self)
end

function ParkourBattleLogic:GetGuideTimelineOffset()
    return Vector3.New(-1.6, 0, 7.2)
end

function ParkourBattleLogic:OnGuideTimelineStart(timelineGO)
    local camInTimeline = timelineGO:GetComponentInChildren(typeof(CS.UnityEngine.Camera))
    self.srcCamPos = camInTimeline.transform.position
    self.srcCamAngle = camInTimeline.transform.eulerAngles.x
    self.srcCamFov = camInTimeline.fieldOfView
    camInTimeline.enabled = false

    if self.camera then
        self.camera.transform.position = self.srcCamPos
        self.camera.transform.eulerAngles = Vector3.New(self.srcCamAngle, 0, 0)
        self.camera.fieldOfView = self.srcCamFov
    end
end

--战斗胜利，进入准备谢幕阶段
function ParkourBattleLogic:OnBattleWin()
    self:ChangeStage(Const.ParkourBattleState.PreExit)
end

function ParkourBattleLogic:OnBattleLose()
    self:ChangeStage(Const.ParkourBattleState.Lose)
end

function ParkourBattleLogic:GetPlayerPosZ()
    if not self.initComplete then
        return self.data.initPosY
    end
    return self.team:GetPositionZ()
end

function ParkourBattleLogic:ShakeCameraWithParam(param)
    self.battleMgr:ShakeCameraWithParam(param)
end

function ParkourBattleLogic:DealDamage(attacker,defender,bulletMeta,damageMultiplier,hitPoint,hitDir,whiteTime,stiffTime,hitBackDistance,hitEff,skill,exType,exValue)
    local hurt,isCritical,isMiss,nakedDmg=PveUtil.CalculateDamage(attacker,defender,bulletMeta.damage_type,damageMultiplier,exType,exValue)
    if isMiss then
        self:ShowDamageText(hurt,hitPoint,DamageTextType.Miss,bulletMeta.damage_type,isCritical)
        return
    end
    if hurt<=0 then
        return
    end
    defender:BeAttack(hurt,hitPoint,hitDir,whiteTime,stiffTime,hitBackDistance,hitEff)
    defender:AfterBeAttack(hurt,hitPoint,hitDir,whiteTime,stiffTime,hitBackDistance,hitEff,skill)

    -- 统计
    --跑酷关卡只统计初始阵容数据
    if attacker.hero and hurt > 0 then
        --if self.heroStatisticalData.makeDmg[attacker.hero.uuid] == nil then self.heroStatisticalData.makeDmg[attacker.hero.uuid] = 0 end
        if self.heroStatisticalData.makeDmg[attacker.hero.uuid] then
            self.heroStatisticalData.makeDmg[attacker.hero.uuid] = self.heroStatisticalData.makeDmg[attacker.hero.uuid] + hurt -- 统计输出伤害可以溢出
        end
    end
    if defender.hero and nakedDmg > 0 then
        --if self.heroStatisticalData.takeDmg[defender.hero.uuid] == nil then self.heroStatisticalData.takeDmg[defender.hero.uuid] = 0 end
        if self.heroStatisticalData.takeDmg[defender.hero.uuid] then
            self.heroStatisticalData.takeDmg[defender.hero.uuid] = self.heroStatisticalData.takeDmg[defender.hero.uuid] + nakedDmg -- 统计承受伤害不能溢出
        end
    end
    if attacker.weaponData and hurt > 0 then
        if self.weaponStatisticalData.makeDmg == nil then self.weaponStatisticalData.makeDmg = 0 end
        self.weaponStatisticalData.makeDmg = self.weaponStatisticalData.makeDmg + hurt -- 统计输出伤害可以溢出
    end
    
    local damageTextType
    if attacker.unitType == UnitType.Member then
        if skill and (not skill:IsNormalAttack()) then
            damageTextType=DamageTextType.HeroUltimate
        else
            damageTextType=DamageTextType.HeroNormalAttack
        end
    elseif attacker.unitType == UnitType.Zombie then
        if defender:GetSubTypeBuffCount(BuffSubType.ReduceDamage)>0 then
            damageTextType=DamageTextType.ReduceDamageBuff
        elseif skill and skill:IsNormalAttack() then
            damageTextType=DamageTextType.ZombieNormalAttack
        else
            damageTextType=DamageTextType.ZombieUltimate
        end
    elseif attacker.unitType == UnitType.TacticalWeapon then
        damageTextType=DamageTextType.Drone
    else
        damageTextType=DamageTextType.HeroNormalAttack
    end
    self:ShowDamageText(hurt,hitPoint,damageTextType,bulletMeta.damage_type,isCritical)
end

function ParkourBattleLogic:DealMemberDie(hero)
    self.team:RemoveMember(hero)
    if self.team:GetMemberCount() < 1 then
        self:OnBattleLose()
    end
end

--小队有队员死亡
function ParkourBattleLogic:OnMemberDeath(unit)
    if unit and unit.initUnit then
        self.initUnitDeath = true
        if unit.hero and unit.hero.uuid then
            self.heroStatisticalData.death[unit.hero.uuid] = true
        end
    end
    if self.team:GetMemberCount() < 1 then
        self:OnBattleLose()
    end
end

function ParkourBattleLogic:ShowDamageText(damage,position,style,damage_type,isCritical)
    self.damageTextMgr:GenText(damage,position,style,damage_type,isCritical)
end

function ParkourBattleLogic:Destroy()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIParkourFormation)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIParkourBattleMain)
    
    self:RemoveListener(EventId.OpenUI)
    self:RemoveListener(EventId.LWBattleBuffStart)
    self:RemoveListener(EventId.LWBattleBuffEnd)
    self:RemoveListener(EventId.ParkourBattleStart)
    for _,v in pairs(self.delayEvents) do
        v:Stop()
    end
    self.delayEvents = {}
    self:UnInitCamera()
    self.touchCamera = nil
    if self.staticMgr then
        self.staticMgr:UnInit()
        self.staticMgr = nil
    end
    if self.bulletManager then
        self.bulletManager:Delete()
        self.bulletManager = nil
    end
    if self.team then
        self.team:Destroy()
        self.team = nil
    end
    if  self.monsterMgr then
        self.monsterMgr:Destroy()
        self.monsterMgr = nil
    end
    if self.unitMgr then
        self.unitMgr:Destroy()
        self.unitMgr = nil
    end
    if self.damageTextMgr ~= nil then
        self.damageTextMgr:Destroy()
        self.damageTextMgr = nil
    end
    if self.effectObjMgr then
        self.effectObjMgr:Delete()
        self.effectObjMgr = nil
    end
    if self.stageEffectMgr then
        self.stageEffectMgr:Destroy()
        self.stageEffectMgr = nil
    end
    if(self.rvoMgr) then
        self.rvoMgr:Destory()
        self.rvoMgr = nil
    end
    if(self.sceneLoadRequest) then
        for  _, sceneReq in pairs(self.sceneLoadRequest) do
            sceneReq:Destroy()
        end
        self.sceneLoadRequest = nil
    end

    self.heroStatisticalData = nil
    self.weaponStatisticalData = nil

    self.heroIdReplaceSkillMap = nil
    self.heroIdReplaceAppearanceMap = nil

    self:RemoveSceneUpdator()
end

function ParkourBattleLogic:AfterExit()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIParkourBattleMain, { anim = false })
    self.mainUI = nil
    --打过才触发
    if self.battleResult == Const.BattleResult.Win then
        DataCenter.GuideManager:CheckDoTriggerGuide(GuideTriggerType.ParkourBattleExit, tostring(self:GetPveId()))
    end
end

function ParkourBattleLogic:AddUnit(unit)
    self.unitMgr:AddUnit(unit)
end

function ParkourBattleLogic:RemoveUnit(guid)
    self.unitMgr:RemoveUnitById(guid)
end

function ParkourBattleLogic:AllotUnitGuid()
    self.unitGuid = self.unitGuid + 1
    return self.unitGuid
end

function ParkourBattleLogic:GetUnit(id)
    return self.unitMgr:GetUnit(id)
end

--显示特效，time=nil则1秒后隐藏；time<=0 则永远显示；time>0则显示time秒
function ParkourBattleLogic:ShowEffectObj(path,pos,rot,time,parent,type)
    return self.effectObjMgr:ShowEffectObj(path,pos,rot,time,parent,type)
end

--移除特效
function ParkourBattleLogic:RemoveEffectObj(id)
    self.effectObjMgr:RemoveEffectObj(id)
end


function ParkourBattleLogic:OnWorkerSave()
    if self.battleMgr.gameOver then return end
    --winCondition 营救工人达到数量
    if self.winCondition.winType == Const.ParkourWinType.SaveWorker then
        self.saveNum = self.saveNum + 1
        EventManager:GetInstance():Broadcast(EventId.ParkourWinConditionRefresh)
        if self.saveNum >= self.winCondition.needSaveNum then
            self:OnBattleWin()
        end    
    end
end

function ParkourBattleLogic:OnMonsterDeath(monster)
    if self.battleMgr.gameOver then return end

    local winCondition = self.winCondition
    if monster.monsterMeta.monster_type == 0 or monster.monsterMeta.monster_type == 2 then
        self.killNum = self.killNum + 1
    end
    --winCondition 杀任意怪达到数量
    if winCondition.winType == Const.ParkourWinType.KillMonster then
        EventManager:GetInstance():Broadcast(EventId.ParkourWinConditionRefresh)
        if self.killNum >= winCondition.needKillNum then
            self:OnBattleWin()
        end
    --winCondition 击杀指定ID的怪物达到数量
    elseif winCondition.winType == Const.ParkourWinType.KillTargetMonster then
        local target = winCondition.needKillTarget[monster.monsterMeta.id]
        if target and target.finish<target.need then
            target.finish=target.finish+1
            EventManager:GetInstance():Broadcast(EventId.ParkourWinConditionRefresh)
            local allFinish = true
            for k,v in pairs(winCondition.needKillTarget) do
                if v.finish < v.need then
                    allFinish = false
                    break
                end
            end
            if allFinish then
                self:OnBattleWin()
            end
        end
    --winCondition 杀boss 达到数量  
    elseif winCondition.winType == Const.ParkourWinType.KillBoss then
        if (monster.monsterMeta.is_boss == 1 or monster.monsterMeta.monster_type == Const.MonsterType.Boss) then
            table.removebyvalue(self.boss,monster,true)
            self.killBossNum = self.killBossNum + 1
            if self.killBossNum == winCondition.needKillNum  then
                -- self:OnBattleWin()
                self.unitMgr:ForceFinishFlash()--关卡结束时，强制结束所有单位的闪白
                self.battleMgr:SetGamePause(true)
                if not self.winTimer then
                    --Logger.Log("跑酷：win KillBossNum")
                    Time.timeScale = 0.5
                    self.winTimer = TimerManager:GetInstance():GetTimer(4,
                            function()
                                self.battleMgr:SetGamePause(false)
                                Time.timeScale = 1
                                self:OnBattleWin()
                                self.winTimer:Stop()
                                self.winTimer = nil
                            end,
                            nil, true, false, true)
                    self.winTimer:Start()
                end
            end
        end
    end
    
end


function ParkourBattleLogic:OnBossEnterBattle(boss)
    local winCondition = self.winCondition
    if winCondition.winType ==  Const.ParkourWinType.KillBoss  then        
        --self.boss = boss
        table.insert(self.boss,boss)
        -- self.mainUI:ShowBossHpBar()
    end
end

function ParkourBattleLogic:OnOpenUI(name)
    --if name == UIWindowNames.UIParkourBattleWin or name == UIWindowNames.UIParkourBattleLose then
    --    self.unitMgr:RemoveAllUnitByType(UnitType.Zombie)
    --end
end


function ParkourBattleLogic:AddListener(msg_name, callback)
    local bindFunc = function(...) callback(self, ...) end
    self.__event_handlers[msg_name] = bindFunc
    EventManager:GetInstance():AddListener(msg_name, bindFunc)
end

function ParkourBattleLogic:RemoveListener(msg_name, callback)
    local bindFunc = self.__event_handlers[msg_name]
    if not bindFunc then
        return
    end
    self.__event_handlers[msg_name] = nil
    EventManager:GetInstance():RemoveListener(msg_name, bindFunc)
end

function ParkourBattleLogic:AddDelayEvent(event,delay)
    assert(event,"event invalid")
    local timer = TimerManager:GetInstance():DelayInvoke(event,delay)
    table.insert(self.delayEvents,timer)
end

function ParkourBattleLogic:OnBuffChange()
    --TODO 判断buff类型和作用号
    if not self.team then return end
    self.team.moveSpeedDirty = true
    self.team.moveSpeedZDirty = true
    self.team.superArmorDirty = true
end

function ParkourBattleLogic:GetStageId()
    return self.data.meta.id
end

function ParkourBattleLogic:GetTotalKill()
    return self.killNum
end

function ParkourBattleLogic:GetCostTime()
    return self.useTime
end

function ParkourBattleLogic:GetAvgFPS()
    if self.useTime==0 then
        return -1
    end
    return (Time.frameCount-self.startFrame)/self.useTime
end

function ParkourBattleLogic:GetLowestFPS()
    return math.min(self.lowestFps,self:GetAvgFPS())
end

--记录吃到的奖励，通关时向后端索取
function ParkourBattleLogic:RecordGoods(goodsId,goodsCount)
    if not self.goods[goodsId] then
        self.goods[goodsId] = 0
    end
    self.goods[goodsId] = self.goods[goodsId] + goodsCount
end

--region joystick
function ParkourBattleLogic:SetJoystick(joystick)
    self.joystick = joystick
    self:DisableJoystick()
end

function ParkourBattleLogic:EnableJoystick()
    self.joystick:SetEnabled(true)
end

function ParkourBattleLogic:DisableJoystick()
    if self.fingerDown then
        self.fingerDown = false
        self.joystick:Reset()
    end
    self.joystick:SetEnabled(false)
end


function ParkourBattleLogic:IsFingerOnUI()
    if TouchWrapper.TouchCount > 0 then
        local touches = TouchWrapper.Touches
        local touchCount = touches.Count
        for i = 0, touchCount - 1 do
            local t = touches[i]
            if EventSystem.current:IsPointerOverGameObject(t.FingerId) then
                return true
            end
        end
    end
    return false
end

function ParkourBattleLogic:OnFingerDownJoyStick(pos)
    if not self.joystick or not self.joystick:GetEnabled() or self:IsFingerOnUI() then
        return
    end
    self.joystick:OnFingerDown(pos)
    self.team:OnFingerDown(pos)
end

function ParkourBattleLogic:OnFingerUpJoyStick()
    self.joystick:OnFingerUp()
    self.team:OnFingerUp()
end

function ParkourBattleLogic:OnFingerHoldJoyStick()
    local vx, vz = self.joystick:OnUpdate()
    self.team:OnFingerHold(vx,vz)
end


--endregion


function ParkourBattleLogic:ChangeStage(newStage)
    local oldStage = self.state
    if newStage == Const.ParkourBattleState.Ready then
        --Logger.Log("跑酷：Ready")
        self.state = Const.ParkourBattleState.Ready
    elseif newStage==Const.ParkourBattleState.Farm then
        --Logger.Log("跑酷：Farm")
        self.touchCamera:SetYRotation(0)
        self.state = Const.ParkourBattleState.Farm
        self.team:ChangeStage(self.state)
    elseif newStage==Const.ParkourBattleState.Boss then
        --Logger.Log("跑酷：Boss")
        self.touchCamera:SetYRotation(0)
        self.state = Const.ParkourBattleState.Boss
        self.team:ChangeStage(self.state)
        self.battleMgr:AutoZoom(30)
        self:EnableJoystick()
        if self:GetStageId()==108 then
            UIManager:GetInstance():OpenWindow(UIWindowNames.UITutorialAnimation,{anim=false},3)
        end
        self:OnFingerUp()
    elseif newStage == Const.ParkourBattleState.BossStay then
        --Logger.Log("跑酷：BossStay")
        self.state = Const.ParkourBattleState.BossStay
        self.team:ChangeStage(self.state)
        self:OnFingerUp()
    elseif newStage == Const.ParkourBattleState.BossHorizontal then
        --Logger.Log("跑酷：BossHorizontal")
        self.state = Const.ParkourBattleState.BossHorizontal
        self.team:ChangeStage(self.state)
    elseif newStage==Const.ParkourBattleState.PreExit then
        if oldStage==Const.ParkourBattleState.PreExit
                or oldStage==Const.ParkourBattleState.Exit
                or oldStage==Const.ParkourBattleState.Lose then
            return
        end
        --Logger.Log("跑酷：PreExit")
        self.state=Const.ParkourBattleState.PreExit
        self.team:ChangeStage(self.state)--进入无敌状态
        if self.mainUI then
            self.mainUI:OnParkourBattleWin()--ui动画
        end
        self:AddDelayEvent(function()
            self:ChangeStage(Const.ParkourBattleState.Exit)
        end, 0.7)
    elseif newStage==Const.ParkourBattleState.Exit then
        if oldStage~=Const.ParkourBattleState.PreExit then
            return
        end
        --Logger.Log("跑酷：Exit")
        self.state=Const.ParkourBattleState.Exit--进入谢幕阶段，镜头固定，小队前进
        self:DisableJoystick()
        self.team:ChangeStage(self.state)--进入谢幕狂飙状态
        --打开胜利ui
        local param = {}
        param.time = self.useTime
        param.kill = self.killNum
        param.stageId = self.data.meta.id
        param.showStatistic = self.data.showStatistic
        UIManager:GetInstance():OpenWindow(UIWindowNames.UIParkourBattleWin, 
                { anim = false,playEffect = DataCenter.LWSoundManager:GetSound(10024) }, param)
        --发出胜利通知
        self:NoticeWin()
        --打点
        --PostEventLog.BattleResultLog(PVEType.Parkour,1)
        --谢幕阶段结束
        self:AddDelayEvent(function()
            if self.battleMgr then
                self.battleMgr:SetGameOver(true)--暂停update
            end
        end, 4)
    elseif newStage==Const.ParkourBattleState.Lose then
        if oldStage==Const.ParkourBattleState.PreExit
                or oldStage==Const.ParkourBattleState.Exit
                or oldStage==Const.ParkourBattleState.Lose then
            return
        end
        --Logger.Log("跑酷：Lose")
        self.state=Const.ParkourBattleState.Lose--进入输了阶段

        if self.team then
            self.team:ChangeStage(self.state)
        end

        --打开失败ui
        self.battleMgr:SetGameOver(true)
        local param = {}
        param.time = self.useTime
        param.kill = self.killNum
        param.stageId = self.data.meta.id
        param.extraData = self.param.extraData
        param.showStatistic = self.data.showStatistic
        UIManager:GetInstance():OpenWindow(UIWindowNames.UIParkourBattleLose, 
                { anim = false,playEffect = DataCenter.LWSoundManager:GetSound(10023) }, param)
        --这里不能发出失败通知，由玩家通过ui选择是否失败
        self:NoticeLose()
        --打点
        --PostEventLog.BattleResultLog(PVEType.Parkour,0)
    end
end

function ParkourBattleLogic:IsBattleFinish()
    return self.state >= Const.ParkourBattleState.PreExit
end

function ParkourBattleLogic:NoticeWin()
    --发出胜利通知
    EventManager:GetInstance():Broadcast(EventId.ParkourBattleWin,self.data.meta.id)
    if self.param.pveEntrance == PveEntrance.LandBlock then
        DataCenter.LandManager:SendFinishPve(self.param.blockId, self.param.levelId, 1)
    elseif self.param.pveEntrance == PveEntrance.SiegeBoss then
        DataCenter.CitySiegeManager:SendFinishZombie(self.param.zombieId, nil, 1)
    end
    self.battleResult = Const.BattleResult.Win
end

function ParkourBattleLogic:NoticeLose()
    --发出失败通知
    if self.param.pveEntrance == PveEntrance.LandBlock then
        DataCenter.LandManager:SendFinishPve(self.param.blockId, self.param.levelId, 0)
    elseif self.param.pveEntrance == PveEntrance.SiegeBoss then
        DataCenter.CitySiegeManager:SendFinishZombie(self.param.zombieId, nil, 0)
    end
    self.battleResult = Const.BattleResult.Fail
end

function ParkourBattleLogic:GetInitPos()
    return Vector3(self.data.initPosX, 0, self.data.initPosY)
end

function ParkourBattleLogic:GetPVEType()
    return PVEType.Parkour
end

function ParkourBattleLogic:GetSquadMemberPosition()
    if self.team then
        return self.team:ReturnMemberPositions()
    end
    
    return {}
end

function ParkourBattleLogic:ResetHeroPos()
    if self.team then
        self.team:ResetHeroPosition()
    end
end

function ParkourBattleLogic:SetHeroers(heroes)
    if self.team then
        self.team:ChangeHeroes(heroes)
    end
end

function ParkourBattleLogic:GetHeroes()
    if self.team then
        return self.team.teamUnits
    end
    
    return {}
end

function ParkourBattleLogic:SetHeroPos(index, worldPos)
    if self.team then
        self.team:SetHeroPosition(index, worldPos)
    end
end

function ParkourBattleLogic:HeroMoveToIndex(index, dstIndex, time)
    local animTime = time or 0.5
    if self.team then
        self.team:MoveHeroToIndex(index, dstIndex, animTime)
    end
end

---召唤
---@param owner Scene.LWBattle.UnitBase 谁召唤的
---@param monsterId number 配置id
---@param count number 召唤数量
---@param hpPercent number 召唤怪生命值为owner的百分比
function ParkourBattleLogic:SummonMonster(pos, owner, monsterId, count, hpPercent)
    if owner then
        --local pos = owner:GetPosition()
        local maxBlood = owner.maxBlood
        maxBlood = maxBlood * hpPercent
        
        self.monsterMgr:Summon(pos, monsterId, count, maxBlood,owner.meta)
    end
end

function ParkourBattleLogic:AddTrialHero(heroCfg)

    local uuId = heroCfg.uuid
    if not self.heroStatisticalData.makeDmg[uuId] then
        self.heroStatisticalData.makeDmg[uuId] = 0
        self.heroStatisticalData.takeDmg[uuId] = 0
        self.heroStatisticalData.death[uuId] = false

        --EventManager:GetInstance():Broadcast(EventId.GF_parkour_battle_add_trail_hero, {self.data.metaId, heroCfg.heroId})
    end
    
end

function ParkourBattleLogic:ChangeTWSkillChipSetId(setId)
    if self.team then
        local skillChips = DataCenter.TWSkillChipManager:GetChipsByMasterSet(setId)
        self.team:ChangeWeaponSkillChips(skillChips)
    end
end


--trigger 效果处理

--增加小队英雄
function ParkourBattleLogic:AddMember(heroId)
    if self.team then
        self.team:AddMember(heroId)
    end
end

function ParkourBattleLogic:GetReplaceNormalSkill(heroId)
    if self.heroIdReplaceSkillMap and self.heroIdReplaceSkillMap[heroId] then
        return self.heroIdReplaceSkillMap[heroId]
    end
    
    return 0
    
end

function ParkourBattleLogic:GetReplaceAppearance(heroId)
    if self.heroIdReplaceAppearanceMap and self.heroIdReplaceAppearanceMap[heroId] then
        return self.heroIdReplaceAppearanceMap[heroId]
    end
    
    return 0
end

function ParkourBattleLogic:ReplaceHeroUuidNormalAttack(heroUuid, skillId)

    if self.team then
        local skillMeta = DataCenter.HeroSkillTemplateManager:GetTemplate(skillId)
        if skillMeta == nil then
            Logger.LogError("[ReplaceHeroUuidNormalAttack]找不到技能，id为:" .. skillId)
        end

        local heroes = self.team.teamUnits
        if heroes then
            for _, hero in pairs(heroes) do
                if hero.hero and hero.hero.uuid and hero.hero.uuid == heroUuid then
                    local succeed = hero.skillManager:ReplaceNormalAttack(skillMeta)
                    if succeed then
                        DataCenter.LWBattleManager.logic:ShowEffectObj(
                                AddKillEffect, nil,nil,5,hero.transform)
                    end
                    break
                end
            end
        end
        
    end
end

function ParkourBattleLogic:ReplaceHeroIdNormalAttack(heroId, skillId, init)

    if self.team then

        if not init then
            --该方法替换的技能需要缓存，后续新增的同id英雄也要替换技能
            if self.heroIdReplaceSkillMap == nil then
                self.heroIdReplaceSkillMap = {}
            end

            self.heroIdReplaceSkillMap[heroId] = skillId
        end
        
        local skillMeta = DataCenter.HeroSkillTemplateManager:GetTemplate(skillId)
        if skillMeta == nil then
            Logger.LogError("[ReplaceHeroIdNormalAttack]找不到技能，id为:" .. skillId)
        end

        local heroes = self.team.teamUnits
        if heroes then
            for _, hero in pairs(heroes) do
                if hero.hero and hero.hero.heroId and hero.hero.heroId == heroId then
                    local succeed = hero.skillManager:ReplaceNormalAttack(skillMeta)
                    if succeed and (not init) then
                        DataCenter.LWBattleManager.logic:ShowEffectObj(
                                AddKillEffect, nil,nil,5,hero.transform)
                    end
                end
            end
        end
        
    end
end

--换肤
function ParkourBattleLogic:ReplaceHeroIdAppearance(heroId, newHeroId)
    if self.team then
        if self.heroIdReplaceAppearanceMap == nil then
            self.heroIdReplaceAppearanceMap = {}
        end
        
        self.heroIdReplaceAppearanceMap[heroId] = newHeroId

        local heroes = self.team.teamUnits
        if heroes then
            for _, hero in pairs(heroes) do
                if hero.hero and hero.hero.heroId and hero.hero.heroId == heroId then
                    hero:ReplaceAppearance(newHeroId)
                end
            end
        end
    end
end

---end trigger 效果处理
function ParkourBattleLogic:GetLevelId()
    return self.levelId
end

function ParkourBattleLogic:OnKeyCodeEscape()
    if self.winTimer or DataCenter.LWBattleManager.gameOver then
        return
    end
    if self.state ~= Const.ParkourBattleState.Ready and
       self.state ~= Const.ParkourBattleState.PreExit and
       self.state ~= Const.ParkourBattleState.Exit and
       self.state ~= Const.ParkourBattleState.Lose
    then
        self:NoticeLose()
    end
    DataCenter.LWBattleManager:Exit()
end
--pve表的id 引导全部用这个
function ParkourBattleLogic:GetPveId()
    return self.param.pveId
end

function ParkourBattleLogic:GetHeroUuids()
    return self.team.teamInitUnitIds
end

return ParkourBattleLogic