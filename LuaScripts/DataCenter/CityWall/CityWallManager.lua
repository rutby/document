---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2024/4/11 15:42
---

local CityWallManager = BaseClass("CityWallManager")
local CityWallData = require "DataCenter.CityWall.CityWallData"
local CityWallConfig = require "DataCenter.CityWall.CityWallConfig"
local Resource = CS.GameEntry.Resource

local function __init(self)
    self:AddListeners()
    self.light_req = nil
    self.dataDict = {}
    for id = 1, CityWallConfig.OriginCount do
        local data = CityWallData.New(id)
        data:Load()
        self.dataDict[id] = data
    end
    
    self.isVisible = true
    self.curZoneId = -1
    self.seq = nil
end

local function __delete(self)
    for _, data in pairs(self.dataDict) do
        data:Save()
    end
    
    self.isVisible = false
    self:RemoveListeners()
    self:DestroyAll()
end

local function AddListeners(self)
    EventManager:GetInstance():AddListener(EventId.CityZombieInvadeChange, self.OnZombieInvadeChange)
    EventManager:GetInstance():AddListener(EventId.VitaDayNightChange, self.OnDayNightChange)
end

local function RemoveListeners(self)
    EventManager:GetInstance():RemoveListener(EventId.CityZombieInvadeChange, self.OnZombieInvadeChange)
    EventManager:GetInstance():RemoveListener(EventId.VitaDayNightChange, self.OnDayNightChange)
end

local function GetData(self, id)
    return self.dataDict[id]
end

local function RefreshByZone(self, zoneId)
    zoneId = Mathf.Clamp(zoneId, 0, table.count(CityWallConfig.ShowDict) - 1)
    if self.curZoneId == zoneId then
        return
    end
    self.curZoneId = zoneId

    if self.seq then
        self.seq:Kill()
        self.seq = nil
    end
    
    local index = 1 -- 避免使用 table.hasvalue
    for id = 1, CityWallConfig.OriginCount do
        local showId = CityWallConfig.ShowDict[zoneId][index] or 0
        if showId == 0 or id < showId then
            self:DestroyOne(id)
        else
            self:CreateOne(id)
            index = index + 1
        end
    end
    
    self:CheckShowRepair()
    if self.light_req == nil then
        self.light_req = Resource:InstantiateAsync("Assets/_Art/Models/Environment/Dadige/prefab02/ZhuChengWeiLan_light.prefab")
        self.light_req:completed('+', function(_)
            if self.light_req.gameObject == nil then
                self.light_req:Destroy()
                self.light_req = nil
            end
            local transform = self.light_req.gameObject.transform
            transform:SetParent(CS.SceneManager.World.DynamicObjNode)
            transform.position = Vector3.zero
            transform.rotation = Quaternion.identity
            transform.localScale = Vector3.one
            self:CheckIsDay()
        end)
    end
    DataCenter.ZeroTreeManager:CheckShowTree()
end

local function OnDayNightChange(self)
    DataCenter.CityWallManager:CheckIsDay()
end
local function CheckIsDay(self)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local dayNight = DataCenter.VitaManager:GetDayNight(curTime)
    if dayNight == VitaDefines.DayNight.Day then
        if self.light_req~=nil and self.light_req.gameObject~=nil then
            self.light_req.gameObject:SetActive(false)
        end
    else
        if self.light_req~=nil and self.light_req.gameObject~=nil then
            self.light_req.gameObject:SetActive(true)
        end
    end
end
local function CreateOne(self, id)
    local data = self.dataDict[id]
    if data.created then
        return
    end

    if data.req then
        data:Destroy()
    end
    
    local config = CityWallConfig.OriginDict[id]
    local req = Resource:InstantiateAsync(config.prefabPath)
    req:completed('+', function(_)
        data:OnCreate()
    end)
    data:SetReq(req)
    data:SetActive(self.isVisible)
end

local function DestroyOne(self, id)
    local data = self.dataDict[id]
    data:Destroy()
end

local function DestroyAll(self)
    if self.seq then
        self.seq:Kill()
        self.seq = nil
    end
    
    for id, _ in pairs(self.dataDict) do
        self:DestroyOne(id)
    end
    if self.light_req~=nil then
        self.light_req:Destroy()
        self.light_req = nil
    end
    self.curZoneId = -1
end

local function DoExpand(self, delay, zoneId, fallInterval)
    zoneId = Mathf.Clamp(zoneId, 0, table.count(CityWallConfig.ShowDict) - 1)
    if self.curZoneId == zoneId then
        return
    end
    self:RefreshByZone(zoneId)
    
    local startId, endId
    if zoneId == 0 then
        startId = 1
        endId = CityWallConfig.ShowDict[zoneId][table.count(CityWallConfig.ShowDict[zoneId])]
    else
        startId = CityWallConfig.ShowDict[zoneId - 1][table.count(CityWallConfig.ShowDict[zoneId - 1])]
        endId = CityWallConfig.ShowDict[zoneId][table.count(CityWallConfig.ShowDict[zoneId])]
    end
    
    local seq = DOTween.Sequence()
    seq:AppendInterval(delay)
    fallInterval = fallInterval or CityWallFallInterval
    seq:AppendCallback(function()
        SoundUtil.PlayEffect(SoundAssets.Music_Effect_Pve_Wall_Fall)
    end)
    for id = startId, endId do
        local data = self.dataDict[id]
        if data then
            data:SetActive(false)
        end
        seq:AppendCallback(function()
            local data = self.dataDict[id]
            if data then
                data:SetActive(true)
                data:PlayAnim(CityWallAnim.Create)
            end
        end)
        seq:AppendInterval(fallInterval)
    end
    self.seq = seq
    DataCenter.ZeroTreeManager:CheckShowTree()
    return 1 -- TODO: 问顾曲
end

local function SetVisible(self, isVisible)
    self.isVisible = isVisible
    for _, data in pairs(self.dataDict) do
        data:SetActive(isVisible)
    end
end

local function GetWallMaxHp(self)
    local buildData = DataCenter.BuildManager:GetFunbuildByItemID(BuildingTypes.FUN_BUILD_DEFENCE_CENTER_NEW)
    if buildData and buildData.level > 0 then
        local buildLevelTemplate = DataCenter.BuildTemplateManager:GetBuildingLevelTemplate(buildData.itemId, buildData.level)
        if buildLevelTemplate then
            local wallMaxHp = tonumber(buildLevelTemplate.durability)
            if wallMaxHp then
                return wallMaxHp
            end
        end
    end
    
    -- 仅做容错
    return LuaEntry.DataConfig:TryGetNum("safety_area", "k13")
end

local function RefreshBrokenWalls(self, message)
    if message["zombie_destroy_wall"] then
        local dict = {}
        local str = message["zombie_destroy_wall"]
        for _, spl in ipairs(string.split(str, ";")) do
            local id = tonumber(spl) or 0
            dict[id] = true
        end
        for id = 1, CityWallConfig.OriginCount do
            local data = self:GetData(id)
            data:SetHasHurt(dict[id] or false)
        end
        self:CheckShowRepair()
    end
end

local function GetHurtWallIds(self)
    local list = {}
    for _, data in pairs(self.dataDict) do
        if data.hasHurt then
            table.insert(list, data.id)
        end
    end
    return list
end

local function CheckShowRepair(self)
    local shownDict = {} -- Dict<group, bool>
    for _, data in pairs(self.dataDict) do
        -- 每组只显示一个
        if shownDict[data.group] == nil and data.hasHurt and not DataCenter.CityResidentManager:IsZombieInvade() then
            local hudParam = {}
            hudParam.uuid = data.uuid
            hudParam.ids = CityWallRepairGroupIds[data.group] or { data.id }
            hudParam.pos = data.pos
            hudParam.offset = Vector3.New(0, 50, 0)
            hudParam.type = CityHudType.RepairWall
            hudParam.location = CityHudLocation.UI
            DataCenter.CityHudManager:Create(hudParam)
            shownDict[data.group] = true
        else
            DataCenter.CityHudManager:Destroy(data.uuid, CityHudType.RepairWall)
        end
    end
end

local function SendBreakWall(self, id)
    SFSNetwork.SendMessage(MsgDefines.ZombieDestroyWall, id)
end

local function SendRepairWall(self, id)
    self:SendRepairWalls({ id })
end

local function SendRepairWalls(self, ids)
    SFSNetwork.SendMessage(MsgDefines.FixZombieDestroyWall, ids)
end

local function HandleInit(self, message)
    self:RefreshBrokenWalls(message)
end

local function HandleBreakWall(self, message)
    self:RefreshBrokenWalls(message)
end

local function HandleRepairWall(self, message)
    self:RefreshBrokenWalls(message)
    if message["resource"] then
        LuaEntry.Resource:UpdateResource(message["resource"])
    end
end

local function OnZombieInvadeChange()
    if not SceneUtils.GetIsInCity() then
        return
    end
    
    DataCenter.CityWallManager:CheckShowRepair()
end

local function IsHasWall(self)
    return self.curZoneId>=0
end
CityWallManager.__init = __init
CityWallManager.__delete = __delete
CityWallManager.AddListeners = AddListeners
CityWallManager.RemoveListeners = RemoveListeners

CityWallManager.GetData = GetData
CityWallManager.RefreshByZone = RefreshByZone
CityWallManager.CreateOne = CreateOne
CityWallManager.DestroyOne = DestroyOne
CityWallManager.DestroyAll = DestroyAll
CityWallManager.DoExpand = DoExpand
CityWallManager.SetVisible = SetVisible
CityWallManager.GetWallMaxHp = GetWallMaxHp
CityWallManager.RefreshBrokenWalls = RefreshBrokenWalls
CityWallManager.GetHurtWallIds = GetHurtWallIds
CityWallManager.CheckShowRepair = CheckShowRepair

CityWallManager.SendBreakWall = SendBreakWall
CityWallManager.SendRepairWall = SendRepairWall
CityWallManager.SendRepairWalls = SendRepairWalls

CityWallManager.HandleInit = HandleInit
CityWallManager.HandleBreakWall = HandleBreakWall
CityWallManager.HandleRepairWall = HandleRepairWall

CityWallManager.OnZombieInvadeChange = OnZombieInvadeChange
CityWallManager.IsHasWall =IsHasWall
CityWallManager.CheckIsDay = CheckIsDay
CityWallManager.OnDayNightChange =OnDayNightChange
return CityWallManager
