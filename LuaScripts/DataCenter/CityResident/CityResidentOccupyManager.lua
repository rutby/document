---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2024/4/18 16:57
---

---
--- 给小人分配东西的管理器
---
local CityResidentOccupyManager = BaseClass("CityResidentOccupyManager")

local function __init(self)
    -- 小人占用家具
    self.furnitureTransformOccupyDict = {} -- Dict<fUuid, Dict<Transform, rUuid>>

    -- 小人占用床
    self.occupyResidentBedDict = {} -- Dict<rUuid, fUuid>
    self.occupyBedResidentDict = {} -- Dict<fUuid, List<rUuid>> 每个床可以容纳多个小人
    
    -- 丧尸占用建筑攻击点
    self.attackBuildPosDict = {} -- Dict<bUuid, List<{ pos, rUuid }>> 建筑可用的攻击点
    self.occupyAttackBuildPosDict = {} -- Dict<rUuid, { bUuid, index }> 丧尸占用的攻击点
    
    -- 小人占用路点
    self.occupyResidentWayPointDict = {} -- Dict<rUuid, wayPoint.id>
    self.occupyWayPointResidentDict = {} -- Dict<wayPoint.id, rUuid>
end

local function __delete(self)
    
end

-- 尝试分配给小人一个家具
local function TryOccupyFurnitureTransform(self, rUuid, furnitureId)
    for fUuid, dict in pairs(self.furnitureTransformOccupyDict) do
        for tf, uuid in pairs(dict) do
            if not IsNull(tf) and uuid == rUuid then
                return tf, fUuid
            end
        end
    end
    local furnitureInfoList = DataCenter.FurnitureManager:GetFurnitureByFurnitureId(furnitureId)
    for _, furnitureInfo in ipairs(furnitureInfoList) do
        local fUuid = furnitureInfo.uuid
        local buildData = DataCenter.BuildManager:GetBuildingDataByUuid(furnitureInfo.bUuid)
        if buildData and buildData.level > 0 and buildData:GetCurStamina() > 0 then
            local furnitureTf = DataCenter.FurnitureObjectManager:GetTransformByFurnitureUuid(fUuid)
            if furnitureTf then
                if self.furnitureTransformOccupyDict[fUuid] == nil then
                    self.furnitureTransformOccupyDict[fUuid] = {}
                end
                for i = 1, furnitureTf.childCount do
                    local tf = furnitureTf:Find("Interact_" .. i)
                    if tf and self.furnitureTransformOccupyDict[fUuid][tf] == nil then
                        self.furnitureTransformOccupyDict[fUuid][tf] = rUuid
                        return tf, fUuid
                    end
                end
            end
        end
    end
    return nil, 0
end

-- 释放分配给小人的家具
local function ReleaseOccupyFurnitureTransform(self, rUuid)
    for fUuid, dict in pairs(self.furnitureTransformOccupyDict) do
        local tfs = {}
        for tf, uuid in pairs(dict) do
            if uuid == rUuid then
                table.insert(tfs, tf)
            end
        end
        for _, tf in ipairs(tfs) do
            self.furnitureTransformOccupyDict[fUuid][tf] = nil
        end
    end
end

-- return
-- fUUid 床的家具uuid
-- index 床位
local function TryOccupyBed(self, rUuid)
    if self.occupyResidentBedDict[rUuid] then
        -- cache
        local fUuid = self.occupyResidentBedDict[rUuid]
        if self.occupyBedResidentDict[fUuid] then
            for index, v in pairs(self.occupyBedResidentDict[fUuid]) do
                if v == rUuid then
                    return fUuid, index
                end
            end
        end
    end
    local furnitureInfoList = DataCenter.FurnitureManager:GetFurnitureByFurnitureId(FurnitureType.Bed)
    table.sort(furnitureInfoList, function(infoA, infoB)
        return infoA.uuid < infoB.uuid
    end)
    for _, furnitureInfo in ipairs(furnitureInfoList) do
        local fUuid = furnitureInfo.uuid
        local furnitureTf = DataCenter.FurnitureObjectManager:GetTransformByFurnitureUuid(fUuid)
        if furnitureTf then
            local index
            if self.occupyBedResidentDict[fUuid] == nil then
                index = 1
            elseif #self.occupyBedResidentDict[fUuid] < self:GetBedCapacity(fUuid) then
                index = #self.occupyBedResidentDict[fUuid] + 1
            end
            if index then
                self:OccupyResidentWithBed(rUuid, fUuid, index)
                return fUuid, index
            end
        end
    end
    return 0, 0
end

local function GetBedCapacity(self, fUuid)
    local furnitureInfo = DataCenter.FurnitureManager:GetFurnitureByUuid(fUuid)
    if furnitureInfo then
        local furnitureTemplate = DataCenter.BuildTemplateManager:GetBuildingLevelTemplate(furnitureInfo.fId, furnitureInfo.lv)
        if furnitureTemplate then
            return tonumber(furnitureTemplate.para6) or 1
        end
    end
    return 1
end

local function OccupyResidentWithBed(self, rUuid, fUuid, index)
    if self.occupyBedResidentDict[fUuid] == nil then
        self.occupyBedResidentDict[fUuid] = {}
    end
    self.occupyResidentBedDict[rUuid] = fUuid
    self.occupyBedResidentDict[fUuid][index] = rUuid
end

-- 尝试占用一个建筑攻击点
local function TryOccupyAttackBuildPos(self, rUuid, bUuid)
    local cache = self.occupyAttackBuildPosDict[rUuid]
    if cache and cache.bUuid == bUuid then
        return self.attackBuildPosDict[bUuid][cache.index].pos
    end
    
    self:ReleaseAttackBuildPos(rUuid)
    local index = self:GetNearAttackBuildPos(rUuid, bUuid)
    if index then
        self:OccupyAttackBuildPos(rUuid, bUuid, index)
        return self.attackBuildPosDict[bUuid][index].pos
    end
    
    return nil
end

local function OccupyAttackBuildPos(self, rUuid, bUuid, index)
    self.occupyAttackBuildPosDict[rUuid] = { bUuid = bUuid, index = index }
    self.attackBuildPosDict[bUuid][index].rUuid = rUuid
end

local function ReleaseAttackBuildPos(self, rUuid)
    local cache = self.occupyAttackBuildPosDict[rUuid]
    if cache == nil then
        return
    end

    self.attackBuildPosDict[cache.bUuid][cache.index].rUuid = nil
    self.occupyAttackBuildPosDict[rUuid] = nil
end

local function GetNearAttackBuildPos(self, rUuid, bUuid)
    if self.attackBuildPosDict[bUuid] == nil then
        self:InitAttackBuildPos(bUuid)
        if self.attackBuildPosDict[bUuid] == nil then
            return nil
        end
    end
    
    local data = DataCenter.CityResidentManager:GetData(rUuid)
    local curPos = data:GetPos()
    local list = self.attackBuildPosDict[bUuid]
    local targetIndex = nil
    local minMhtDis = IntMaxValue
    for index, v in ipairs(list) do
        if v.rUuid == nil then
            local mhtDis = math.abs(curPos.x - v.pos.x) + math.abs(curPos.z - v.pos.z)
            if mhtDis < minMhtDis then
                minMhtDis = mhtDis
                targetIndex = index
            end
        end
    end
    return targetIndex
end

local function InitAttackBuildPos(self, bUuid)
    local buildData = DataCenter.BuildManager:GetBuildingDataByUuid(bUuid)
    if buildData == nil then
        return
    end
    
    local buildTemplate = DataCenter.BuildTemplateManager:GetBuildingDesTemplate(buildData.itemId)
    if buildTemplate == nil then
        return
    end
    
    local cityBuilding = CS.SceneManager.World:GetBuildingByPoint(buildData.pointId)
    if cityBuilding == nil then
        return
    end

    local transform = cityBuilding:GetTransform()
    if IsNull(transform) then
        return
    end

    self.attackBuildPosDict[bUuid] = {}
    local index = 1
    local parent = CS.CityBuilding.GetChildByName(transform, "AttackLines")
    if IsNull(parent) or parent.childCount == 0 then
        Logger.LogError("CityResidentOccupyManager InitAttackBuildPos, AttackLines not found, buildId = " .. buildData.itemId)
        return
    end

    for i = 0, parent.childCount - 1 do
        local lineTf = parent:GetChild(i)
        local line = lineTf:GetComponent(typeof(CS.UnityEngine.LineRenderer))
        if line and line.GetPosition then
            local buildPos = buildTemplate:GetPosition()
            local pos1 = line:GetPosition(0) + buildPos
            local pos2 = line:GetPosition(1) + buildPos
            local vec = pos2 - pos1
            local len = Vector3.Magnitude(vec)
            local dir = Vector3.Normalize(vec)
            local space = CityResidentDefines.ZombieAttackBuildingSpacing
            local offset = 0
            while offset <= len do
                local pos = pos1 + dir * offset
                self.attackBuildPosDict[bUuid][index] = { pos = pos, rUuid = nil }
                offset = offset + space
                index = index + 1
            end
        end
    end
end

-- 尝试占用一个最近的路点
local function TryOccupyNearWayPoint(self, rUuid, mask, flag, arg)
    local data = DataCenter.CityResidentManager:GetData(rUuid)
    if data == nil then
        return nil
    end
    
    local wayPoints = WayPointUtil.GetWayPointsByMask(mask, flag, arg)
    if wayPoints == nil or wayPoints.Count == 0 then
        return nil
    end
    
    local list = {}
    for i = 0, wayPoints.Count - 1 do
        local wayPoint = wayPoints[i]
        if self.occupyWayPointResidentDict[wayPoint.id] == nil then
            table.insert(list, wayPoint)
        end
    end
    if #list == 0 then
        return nil
    end
    
    local curPos = data:GetPos()
    local targetWayPoint = nil
    local minMhtDis = IntMaxValue
    for _, wayPoint in ipairs(list) do
        local mhtDis = math.abs(curPos.x - wayPoint.pos.x) + math.abs(curPos.z - wayPoint.pos.z)
        if mhtDis < minMhtDis then
            minMhtDis = mhtDis
            targetWayPoint = wayPoint
        end
    end
    
    if targetWayPoint then
        self:OccupyWayPoint(rUuid, targetWayPoint.id)
    end
    
    return targetWayPoint
end

-- 尝试占用一个随机的路点
local function TryOccupyRandomWayPoint(self, rUuid, mask, flag, arg)
    local data = DataCenter.CityResidentManager:GetData(rUuid)
    if data == nil then
        return nil
    end
    
    local wayPoints = WayPointUtil.GetWayPointsByMask(mask, flag, arg)
    if wayPoints == nil or wayPoints.Count == 0 then
        return nil
    end

    local list = {}
    for i = 0, wayPoints.Count - 1 do
        local wayPoint = wayPoints[i]
        if self.occupyWayPointResidentDict[wayPoint.id] == nil then
            table.insert(list, wayPoint)
        end
    end
    if #list == 0 then
        return nil
    end
    
    local targetWayPoint = table.randomArrayValue(list)
    self:OccupyWayPoint(rUuid, targetWayPoint.id)
    return targetWayPoint
end

local function OccupyWayPoint(self, rUuid, id)
    self.occupyResidentWayPointDict[rUuid] = id
    self.occupyWayPointResidentDict[id] = rUuid
end

local function ReleaseWayPoint(self, rUuid)
    local id = self.occupyResidentWayPointDict[rUuid]
    if id then
        self.occupyResidentWayPointDict[rUuid] = nil
        self.occupyWayPointResidentDict[id] = nil
    end
end

local function OnSegmentChange(self)
    self.furnitureTransformOccupyDict = {}
    self.occupyBedResidentDict = {}
    self.occupyResidentBedDict = {}
end

CityResidentOccupyManager.__init = __init
CityResidentOccupyManager.__delete = __delete

CityResidentOccupyManager.TryOccupyFurnitureTransform = TryOccupyFurnitureTransform
CityResidentOccupyManager.ReleaseOccupyFurnitureTransform = ReleaseOccupyFurnitureTransform
CityResidentOccupyManager.TryOccupyBed = TryOccupyBed
CityResidentOccupyManager.GetBedCapacity = GetBedCapacity
CityResidentOccupyManager.OccupyResidentWithBed = OccupyResidentWithBed
CityResidentOccupyManager.TryOccupyAttackBuildPos = TryOccupyAttackBuildPos
CityResidentOccupyManager.OccupyAttackBuildPos = OccupyAttackBuildPos
CityResidentOccupyManager.ReleaseAttackBuildPos = ReleaseAttackBuildPos
CityResidentOccupyManager.GetNearAttackBuildPos = GetNearAttackBuildPos
CityResidentOccupyManager.InitAttackBuildPos = InitAttackBuildPos
CityResidentOccupyManager.TryOccupyNearWayPoint = TryOccupyNearWayPoint
CityResidentOccupyManager.TryOccupyRandomWayPoint = TryOccupyRandomWayPoint
CityResidentOccupyManager.OccupyWayPoint = OccupyWayPoint
CityResidentOccupyManager.ReleaseWayPoint = ReleaseWayPoint

CityResidentOccupyManager.OnSegmentChange = OnSegmentChange

return CityResidentOccupyManager