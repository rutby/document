---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2023/11/13 20:55
---

-- CityResident 仅用作前端表现
local CityResidentManager = BaseClass("CityResidentManager")
local CityResidentData = require "DataCenter.CityResident.CityResidentData"
local CityResidentObject = require "DataCenter.CityResident.CityResidentObject"
local CityResidentOccupyManager = require "DataCenter.CityResident.CityResidentOccupyManager"
local CityResidentAnimalManager = require "DataCenter.CityResident.CityResidentAnimalManager"
local AreaMatrix = require "Common.AreaMatrix"
local rapidjson = require "rapidjson"
local Resource = CS.GameEntry.Resource
local Localization = CS.GameEntry.Localization

local TimerInterval = 0.125
local MinX = 80
local MinZ = 80
local MainPos = Vector3.New(101, 0, 101)

---
--- 本文件中
--- data : CityResidentData 是前端小人的表现数据
--- residentData : VitaResidentData 是后端发来的小人数据
---

local function __init(self)
    self:AddListeners()
    
    -- sub manager
    self.occupyMgr = CityResidentOccupyManager.New()
    self.animalMgr = CityResidentAnimalManager.New()
    
    self.inited = false
    self.isInCity = false
    self.camera = nil
    self.touchCamera = nil
    self.canDoGuide = false
    self.focusBUuid = 0
    self.nextZombieUuid = 200000
    self.canSpawnZombie = true
    self.zombieSpawnPosDict = {} -- Dict<mask, Dict<id, { pos, weight }>>
    self.foodWindowIndex = 0
    self.noBedSpeakTime = 0
    
    self.tick = 0
    self.areaMatrix = AreaMatrix.New(MinX, MinZ, 40, 40, 40) -- x, z from 80 to 120, 40x40 matrix
    self.tempList = {}
    self.zombieRoarIndex = 1
    self.zombieSearchIndex = 1
    self.readyResidentCount = 0 -- 待加入幸存者数量
    self.readyCanCome = nil -- 幸存者是否可以来排队
    self.readyQueueComeSwitch = true -- 幸存者排队开关
    self.readyQueueHudSwitch = true -- 幸存者排队气泡开关
    self.isPauseAll = false
    self.isActiveAll = true
    self.talkTimes = {} -- List<time> 小人触发调侃的时间
    self.talkTypeTimes = {} -- Dict<TalkTriggerType, List<time>> 小人触发该类型调侃的时间
    self.talkTypeNextTimes = {} -- Dict<TalkTriggerType, time> 所有小人可以再次触发该类型调侃的时间
    self.talkSingleNextTime = {} -- Dict<uuid, Dict<TalkTriggerType, time>> 同一个小人可以再次触发该类型调侃的时间
    self.threatSec = 0 -- 相机在恐怖迷雾中停留的时间(秒)
    self.levelUpHudReduceCountTimes = {} -- List<time> 小人触发升级气泡最大数量减少的时间
    self.detailZoom = 16 -- 打开小人详情面板前的相机高度
    self.expandLevel = 1
    self.fireBodyUuids = {} -- 将要被点燃的小人
    self.deadInfoDict = {} -- Dict<uuid, { uuid, id, pos, rot }> 今夜死亡小人的信息
    self.isPeace = false -- 和平夜
    self.buildInViewTimer = nil
    self.betrayStartTime = 0 -- 叛逃起始时间
    self.isZombieInvade = false
    self.overworkUuids = {} -- List<rUuid> 加班的小人
    self.overworkDict = {} -- Dict<bUuid, rUuid> 建筑里加班的小人
    self.wantCount = 0
    
    self.bankDict = {} -- Dict<uuid, table> 存档
    self.dataDict = {} -- Dict<uuid, CityResidentData>
    self.typeDataDict = {} -- Dict<CityResidentDefines.Type, List<CityResidentData>>
    self.typeDataDict[CityResidentDefines.Type.Resident] = {}
    self.typeDataDict[CityResidentDefines.Type.Zombie] = {}
    self.typeDataDict[CityResidentDefines.Type.Hero] = {}
    self.typeDataDict[CityResidentDefines.Type.Special] = {}
    self.typeDataDict[CityResidentDefines.Type.Animal] = {}
    self.objDict = {}
    self.effReqDict = {}
    
    self.timer = TimerManager:GetInstance():GetTimer(TimerInterval, self.TimerAction, self, false, false, false)
    self.timer:Start()
    
    self.onUpdate = BindCallback(self, self.OnUpdate)
    UpdateManager:GetInstance():AddUpdate(self.onUpdate)
    
    self:SetMoverUpdateInterval(CityResidentDefines.UpdateIntervalLow)
end

local function __delete(self)
    self:RemoveListeners()

    self.occupyMgr:Delete()
    self.animalMgr:Delete()

    if self.timer then
        self.timer:Stop()
        self.timer = nil
    end

    if self.buildInViewTimer then
        self.buildInViewTimer:Stop()
        self.buildInViewTimer = nil
    end

    if self.onUpdate then
        UpdateManager:GetInstance():RemoveUpdate(self.onUpdate)
        self.onUpdate = nil
    end
    
    self:DestroyAll()
end

local function AddListeners(self)
    EventManager:GetInstance():AddListener(EventId.VitaDataUpdate, self.OnDataChange)
    EventManager:GetInstance():AddListener(EventId.VitaSegmentChange, self.OnSegmentChange)
    EventManager:GetInstance():AddListener(EventId.VitaDayNightChange, self.OnDayNightChange)
    EventManager:GetInstance():AddListener(EventId.ShowFurniture, self.OnShowFurniture)
    EventManager:GetInstance():AddListener(EventId.HideFurniture, self.OnHideFurniture)
    EventManager:GetInstance():AddListener(EventId.OnBeforeEnterWorld, self.OnEnterWorld)
    EventManager:GetInstance():AddListener(EventId.OnEnterCity, self.OnEnterCity)
    EventManager:GetInstance():AddListener(EventId.PveLevelBeforeEnter, self.OnPveLevelEnter)
    EventManager:GetInstance():AddListener(EventId.PveLevelExit, self.OnPveLevelExit)
    EventManager:GetInstance():AddListener(EventId.BUILD_IN_VIEW, self.OnBuildInView)
    EventManager:GetInstance():AddListener(EventId.BUILD_OUT_VIEW, self.OnBuildOutView)
    EventManager:GetInstance():AddListener(EventId.FurnitureUpgrade, self.OnFurnitureUpgrade)
    EventManager:GetInstance():AddListener(EventId.CityResidentEnterBuilding, self.OnResidentEnterBuilding)
    EventManager:GetInstance():AddListener(EventId.CityResidentExitBuilding, self.OnResidentExitBuilding)
    EventManager:GetInstance():AddListener(EventId.CityResidentEnterFurniture, self.OnResidentEnterFurniture)
    EventManager:GetInstance():AddListener(EventId.CityResidentExitFurniture, self.OnResidentExitFurniture)
    EventManager:GetInstance():AddListener(EventId.VitaSetResidentWork, self.OnSetResidentWork)
    EventManager:GetInstance():AddListener(EventId.VitaSetResidentWorkBatch, self.OnSetResidentWorkBatch)
    EventManager:GetInstance():AddListener(EventId.VitaZombieAttackDead, self.OnZombieAttackDead)
    EventManager:GetInstance():AddListener(EventId.VitaResidentTaskFinish, self.OnResidentTaskFinish)
    EventManager:GetInstance():AddListener(EventId.MainLvUp, self.OnMainLvUp)
    EventManager:GetInstance():AddListener(EventId.CityWallBroken, self.OnCityWallBroken)
    EventManager:GetInstance():AddListener(EventId.CityResidentMoveComplete, self.OnResidentMoveComplete)
end

local function RemoveListeners(self)
    EventManager:GetInstance():RemoveListener(EventId.VitaDataUpdate, self.OnDataChange)
    EventManager:GetInstance():RemoveListener(EventId.VitaSegmentChange, self.OnSegmentChange)
    EventManager:GetInstance():RemoveListener(EventId.VitaDayNightChange, self.OnDayNightChange)
    EventManager:GetInstance():RemoveListener(EventId.ShowFurniture, self.OnShowFurniture)
    EventManager:GetInstance():RemoveListener(EventId.HideFurniture, self.OnHideFurniture)
    EventManager:GetInstance():RemoveListener(EventId.OnBeforeEnterWorld, self.OnEnterWorld)
    EventManager:GetInstance():RemoveListener(EventId.OnEnterCity, self.OnEnterCity)
    EventManager:GetInstance():RemoveListener(EventId.PveLevelBeforeEnter, self.OnPveLevelEnter)
    EventManager:GetInstance():RemoveListener(EventId.PveLevelExit, self.OnPveLevelExit)
    EventManager:GetInstance():RemoveListener(EventId.BUILD_IN_VIEW, self.OnBuildInView)
    EventManager:GetInstance():RemoveListener(EventId.BUILD_OUT_VIEW, self.OnBuildOutView)
    EventManager:GetInstance():RemoveListener(EventId.FurnitureUpgrade, self.OnFurnitureUpgrade)
    EventManager:GetInstance():RemoveListener(EventId.CityResidentEnterBuilding, self.OnResidentEnterBuilding)
    EventManager:GetInstance():RemoveListener(EventId.CityResidentExitBuilding, self.OnResidentExitBuilding)
    EventManager:GetInstance():RemoveListener(EventId.CityResidentEnterFurniture, self.OnResidentEnterFurniture)
    EventManager:GetInstance():RemoveListener(EventId.CityResidentExitFurniture, self.OnResidentExitFurniture)
    EventManager:GetInstance():RemoveListener(EventId.VitaSetResidentWork, self.OnSetResidentWork)
    EventManager:GetInstance():RemoveListener(EventId.VitaSetResidentWorkBatch, self.OnSetResidentWorkBatch)
    EventManager:GetInstance():RemoveListener(EventId.VitaZombieAttackDead, self.OnZombieAttackDead)
    EventManager:GetInstance():RemoveListener(EventId.VitaResidentTaskFinish, self.OnResidentTaskFinish)
    EventManager:GetInstance():RemoveListener(EventId.MainLvUp, self.OnMainLvUp)
    EventManager:GetInstance():RemoveListener(EventId.CityWallBroken, self.OnCityWallBroken)
    EventManager:GetInstance():RemoveListener(EventId.CityResidentMoveComplete, self.OnResidentMoveComplete)
end

local function Init(self)
    if self.inited then
        return
    end
    Logger.Log("CityResident Init start")
    self.camera = CS.UnityEngine.Camera.main
    self.touchCamera = self.camera:GetComponent(typeof(CS.BitBenderGames.MobileTouchCamera))
    
    local terrainGo = CS.SceneManager.World:GetTerrainGameObject()
    if IsNull(terrainGo) then
        Logger.LogError("CityResident Init failed: Cannot find terrain game object.")
        return
    end
    
    for _, mask in pairs(CityResidentDefines.WayPointMask) do
        local ok = pcall(function()
            -- new method
            CS.CityResidentPathUtil.RecordWayPoints(mask, "Path_" .. mask, Vector3.zero, Quaternion.identity, function()
                self:OnCityPathRecorded()
            end)
        end)
        if not ok then
            -- old method
            CS.CityResidentPathUtil.RecordWayPoints(mask, "Path_" .. mask, Vector3.zero, Quaternion.identity)
        end
    end
    
    local vitaData = DataCenter.VitaManager:GetData()
    self.inited = true
    self.isInCity = true
    DataCenter.GuideManager:SetWaitingMessage(WaitMessageFinishType.ResidentLoad, true)
    self:CreateAll(function()
        self.canDoGuide = true
        EventManager:GetInstance():Broadcast(EventId.CityResidentInitFinish)
        DataCenter.GuideManager:SetWaitingMessage(WaitMessageFinishType.ResidentLoad, nil)
        EventManager:GetInstance():Broadcast(EventId.GuideWaitMessage)
    end)
    self.canSpawnZombie = DataCenter.GuideManager:CanShowRandomZombie()
    
    pcall(function()
        CS.CityResidentPathUtil.SetTypeVisitInterval(CityResidentDefines.Type.Resident, 0.3)
        CS.CityResidentPathUtil.SetTypeVisitInterval(CityResidentDefines.Type.Zombie, 0.25)
        CS.CityResidentPathUtil.SetTypeVisitInterval(CityResidentDefines.Type.Hero, 0.3)
    end)
    
    Logger.Log("CityResident Init finish")
end

local function IsEngaged(self)
    return self.inited and self.isInCity
end

local function CanDoGuide(self)
    return self.canDoGuide
end

local function OnUpdate(self)
    if not self:IsEngaged() then
        return
    end
    
    local deltaTime = Time.deltaTime
    for _, data in pairs(self.dataDict) do
        data:OnUpdate(deltaTime)
    end
    --for _, obj in pairs(self.objDict) do
    --    obj:OnUpdate(deltaTime)
    --end
end

local function TimerAction(self)
    if not self:IsEngaged() then
        return
    end
    
    self:CheckZombieInvade()

    self.tick = self.tick + 1
    local mod = self.tick & 1
    if mod == 0 then
        self:SpawnZombie() -- 生成僵尸
        self:UpdateAreaMatrix() -- 更新网格
        self:HeroSearchZombie() -- 英雄找僵尸
        self:ZombieTryEscapeFromSafe() -- 丧尸逃离安全区
    elseif mod == 1 then
        self:ZombieScareResident() -- 僵尸惊吓小人
        self:CheckNoBed() -- 没床睡觉抗议
        self:CheckReadyQueue() -- 幸存者排队
        self:TryAutoReleaseBetrayResident() -- 小人自动叛逃
        self:CheckLevelUp() -- 小人可升级
    end
    self:ZombieSearchResident() -- 僵尸追击小人
    --self:ThreatWhenCameraInFog() -- 视野停留迷雾丧尸吼叫
end

local function Save(self)
    local banks = {}
    for _, data in pairs(self.dataDict) do
        if not data.isGuideControl and not data.isSpecialControl then
            local param = data.param
            local pos = data:GetPos()
            local rot = data:GetRot()
            local bank =
            {
                uuid = data.uuid,
                type = data.type,
                pos = { x = pos.x, y = pos.y, z = pos.z },
                rotY = rot.eulerAngles.y,
                eaten = data.eaten,
                drunkEndTime = data.drunkEndTime,
                scareStartTime = data.scareStartTime,
                atBUuid = data.atBUuid,
                state = data.state,
            }
            if data.param then
                bank.param =
                {
                    prefabPath = param.prefabPath,
                    isRedEye = param.isRedEye,
                    spawnId = param.spawnId,
                }
            end
            table.insert(banks, bank)
        end
    end
    local json = rapidjson.encode(banks)
    Setting:SetPrivateString("CITY_BANK", json)
    Logger.Log("CityResident Save: " .. json)
end

local function Load(self)
    self.bankDict = {}
    local json = Setting:GetPrivateString("CITY_BANK", "")
    Logger.Log("CityResident Load: " .. json)
    if json == "" then
        return
    end
    local banks = rapidjson.decode(json)
    
    -- 处理小人
    for _, bank in ipairs(banks) do
        if bank.type == CityResidentDefines.Type.Resident then
            local data = self:GetData(bank.uuid)
            if data then
                data.eaten = bank.eaten or false
                data.drunkEndTime = bank.drunkEndTime or 0
                data.scareStartTime = bank.scareStartTime or 0
                data.atBUuid = bank.atBUuid or 0
            end
            self.bankDict[bank.uuid] = bank
        end
    end
    
    -- 处理丧尸
    self:CheckZombieInvade()
    if self:IsZombieInvade() then
        local zombieBanks = {}
        for _, bank in ipairs(banks) do
            if bank.type == CityResidentDefines.Type.Zombie then
                if bank.state ~= CityResidentDefines.ZombieState.Dead and bank.pos.x > MinX and bank.pos.z > MinZ then
                    table.insert(zombieBanks, bank)
                end
            end
        end
        for _, bank in ipairs(zombieBanks) do
            bank.uuid = self:GetNextZombieUuid()
            self.bankDict[bank.uuid] = bank
            self:AddData(bank.uuid, bank.type, bank.param)
        end
    end
end

local function GetBank(self, uuid)
    return self.bankDict[uuid]
end

local function GetData(self, uuid)
    return self.dataDict[uuid]
end

local function GetDataByIndex(self, type, index)
    for _, data in pairs(self.dataDict) do
        if data.type == type and data:GetIndex() == index then
            return data
        end
    end
    return nil
end

local function GetDataById(self, type, id)
    for _, data in pairs(self.dataDict) do
        if data.type == type and data.residentData.id == id then
            return data
        end
    end
    return nil
end

local function GetDataByCareer(self, career)
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data:GetCareer() == career then
            return data
        end
    end
    return nil
end

local function GetDataListByCareer(self, career)
    local list = {}
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data:GetCareer() == career then
            table.insert(list, data)
        end
    end
    return list
end

local function GetDataListByType(self, type)
    return self.typeDataDict[type]
end

local function GetDataListByState(self, state)
    local list = {}
    for _, data in pairs(self.dataDict) do
        if data.state == state then
            table.insert(list, data)
        end
    end
    return list
end

local function GetDataListInRange(self, type, center, radius)
    table.clear(self.tempList)
    local count = self.areaMatrix:GetItemsInRangeNonAlloc(self.tempList, center.x, center.z, radius, function(data)
        return data.type == type
    end)
    self.tempList[count + 1] = nil
    return self.tempList
end

local function AddData(self, uuid, type, param, callback)
    local data = CityResidentData.New(uuid, type, param)
    if type == CityResidentDefines.Type.Resident then
        local residentData
        if param and param.id then
            param.uuid = uuid
            residentData = DataCenter.VitaManager:GenFakeResidentData(param)
        else
            residentData = DataCenter.VitaManager:GetResidentData(uuid)
            if residentData:IsReady() then
                self.readyResidentCount = self.readyResidentCount + 1
                data.readyIndex = self.readyResidentCount
            end
        end
        data.residentData = residentData
    elseif type == CityResidentDefines.Type.Hero then
        for index, cfg in pairs(CityResidentDefines.HeroConfig) do
            if cfg.uuid == uuid then
                data.index = index
                break
            end
        end
    end
    self.dataDict[uuid] = data
    table.insert(self.typeDataDict[type], data)
    if self:IsEngaged() then
        self:CreateObject(uuid, callback)
    end
    return data
end

local function RemoveData(self, uuid)
    local data = self.dataDict[uuid]
    if data then
        data:OnRemove()
        self.dataDict[uuid] = nil
        local index = nil
        for i, v in ipairs(self.typeDataDict[data.type]) do
            if v.uuid == uuid then
                index = i
                break
            end
        end
        if index then
            table.remove(self.typeDataDict[data.type], index)
        end
        if self:IsEngaged() then
            self:DestroyObject(uuid)
            DataCenter.CityHudManager:Destroy(uuid)
        end
    end
end

local function RemoveAllByType(self, type)
    for _, data in pairs(self.dataDict) do
        if data.type == type then
            self:RemoveData(data.uuid)
        end
    end
end

local function CreateObject(self, uuid, callback)
    if self.objDict[uuid] ~= nil then
        if callback then
            callback()
        end
        return
    end

    local data = self.dataDict[uuid]
    local obj = CityResidentObject.New(data)
    data.obj = obj
    obj:Create(function()
        data:ResetPos()
        data:Refresh(true)
        data:SetActive(self.isActiveAll)
        if self.isPauseAll then
            data:Pause()
        else
            data:Resume()
        end
        data:OnCreate()
        if callback then
            callback()
        end
    end)
    self.objDict[uuid] = obj
end

local function CreateAll(self, callback)
    Logger.Log("CityResident CreateAll")
    self:Load()
    local count = table.count(self.dataDict)
    for uuid, _ in pairs(self.dataDict) do
        self:CreateObject(uuid, function()
            count = count - 1
            if count <= 0 then
                if callback then
                    callback()
                end
            end
        end)
    end
    self:CheckHeroes()
end

local function DestroyObject(self, uuid)
    if self.objDict[uuid] == nil then
        return
    end
    
    self.objDict[uuid]:Destroy()
    self.objDict[uuid] = nil
end

local function DestroyAll(self)
    Logger.Log("CityResident DestroyAll")

    self.animalMgr:DestroyAll()

    self:Save()

    for _, obj in pairs(self.objDict) do
        obj:Destroy()
    end
    self.objDict = {}

    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Zombie then
            self:RemoveData(data.uuid)
        end
    end

    self.fireBodyUuids = {}
end

local function RefreshAll(self)
    if not self:IsEngaged() then
        return
    end
    
    for _, data in pairs(self.dataDict) do
        data:Refresh()
    end
end

local function Refresh(self, uuid)
    if not self:IsEngaged() then
        return
    end
    
    local data = self:GetData(uuid)
    if data then
        data:Refresh()
    end
end

local function PauseAll(self)
    if self.isPauseAll then
        return
    end
    self.isPauseAll = true
    for _, data in pairs(self.dataDict) do
        data:Pause()
    end
end

local function ResumeAll(self)
    if not self.isPauseAll then
        return
    end
    self.isPauseAll = false
    for _, data in pairs(self.dataDict) do
        data:Resume()
    end
end

local function SetActiveAll(self, active)
    if self.isActiveAll == active then
        return
    end
    self.isActiveAll = active
    for _, data in pairs(self.dataDict) do
        data:SetActive(active)
    end
end

local function CheckZombieInvade(self)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local vitaTime = VitaUtil.RealTimeToVita(curTime)
    local todayMinute = VitaUtil.VitaTimeTodayMinute(vitaTime)
    local wasZombieInvade = self.isZombieInvade
    local t1, t2 = self:GetZombieInvadeTime()
    if t1 <= t2 then
        self.isZombieInvade = (todayMinute >= t1 and todayMinute < t2)
    else
        self.isZombieInvade = (todayMinute >= t1 or todayMinute < t2)
    end
    if self.isZombieInvade ~= wasZombieInvade then
        EventManager:GetInstance():Broadcast(EventId.CityZombieInvadeChange)
        self:OnZombieInvadeChange()
        SoundUtil.PlayMainSceneBGMusic()
    end
end

local function IsZombieInvade(self)
    return self.isZombieInvade
end

local function SpawnZombie(self)
    if not self.canSpawnZombie then
        return
    end

    if self.isPeace then
        return
    end
    
    local zombieCount = self:GetZombieCount()
    if zombieCount >= self:GetZombieMaxCount() then
        return
    end
    
    local mask = self:GetCurrentCityMask()
    local dict = self:GetZombieSpawnPosDict(mask)
    local weightSum = 0
    for _, v in pairs(dict) do
        weightSum = weightSum + v.weight
    end
    if weightSum <= 0 then
        return
    end
    local ran = math.random(1, weightSum)
    local spawnId = nil
    for id, v in pairs(dict) do
        ran = ran - v.weight
        if ran <= 0 then
            spawnId = id
            break
        end
    end
    if spawnId == nil then
        spawnId = 1
    end

    local param = {}
    param.spawnId = spawnId
    param.pos = dict[spawnId].pos
    local uuid = self:GetNextZombieUuid()
    self:AddData(uuid, CityResidentDefines.Type.Zombie, param)
    --Logger.Log("CityResident SpawnZombie uuid = " .. uuid .. ", spawnId = " .. spawnId)
end

local function HeroSearchZombie(self)
    for _, data in ipairs(self:GetDataListByType(CityResidentDefines.Type.Hero)) do
        data:SearchZombie()
    end
end

local function ZombieTryEscapeFromSafe(self)
    for _, data in ipairs(self:GetDataListByType(CityResidentDefines.Type.Zombie)) do
        data:TryEscapeFromSafe()
    end
end

local function ZombieScareResident(self)
    if DataCenter.BuildManager.MainLv < CityResidentDefines.ZombieRoarMainLv then
        return
    end
    
    local dataList = self:GetDataListByType(CityResidentDefines.Type.Zombie)
    local startIndex = self.zombieRoarIndex
    local endIndex = self.zombieRoarIndex + CityResidentDefines.ZombieRoarCount - 1
    for i = startIndex, endIndex do
        local data = dataList[i]
        if data then
            if not data:IsDead() and data.state ~= CityResidentDefines.ZombieState.Escape then
                self.zombieRoarIndex = i + 1
                local pos = data:GetPos()
                if pos.x >= MinX and pos.z >= MinZ then
                    self:ScareResidentsAtPos(pos)
                end
            end
        else
            self.zombieRoarIndex = 1
            break
        end
    end
end

local function ZombieSearchResident(self)
    if DataCenter.BuildManager.MainLv < CityResidentDefines.ZombieAttackMainLv then
        return
    end
    
    local dataList = self:GetDataListByType(CityResidentDefines.Type.Zombie)
    local startIndex = self.zombieSearchIndex
    local endIndex = self.zombieSearchIndex + CityResidentDefines.ZombieSearchCount - 1
    for i = startIndex, endIndex do
        local data = dataList[i]
        if data then
            self.zombieSearchIndex = i + 1
            data:SearchResident(false)
        else
            self.zombieSearchIndex = 1
            break
        end
    end
end

local function CheckNoBed(self)
    if not DataCenter.GuideManager:InGuide() then
        return
    end

    local curSeg = DataCenter.VitaManager:GetCurSegment()
    if curSeg.type ~= VitaDefines.SegmentType.Sleep then
        return
    end

    local curTime = UITimeManager:GetInstance():GetServerTime()
    local interval = DataCenter.VitaManager:GetConfig(VitaDefines.ConfigKey.NoBedSpeak).interval * 1000
    if curTime - self.noBedSpeakTime > interval then
        local noBedUuids = self:GetNoBedResidentUuids()
        if #noBedUuids > 0 then
            self.noBedSpeakTime = curTime
            local dialogs = DataCenter.VitaManager:GetConfig(VitaDefines.ConfigKey.NoBedDialogs)
            local dialog = table.randomArrayValue(dialogs)
            local text = Localization:GetString(dialog)
            local uuid = table.randomArrayValue(noBedUuids)
            local duration = DataCenter.VitaManager:GetConfig(VitaDefines.ConfigKey.NoBedSpeak).duration
            self:ResidentSpeak(uuid, text, duration)
        end
    end
end

local function CheckReadyQueue(self)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local vitaTime = VitaUtil.RealTimeToVita(curTime)
    local todayMinute = VitaUtil.VitaTimeTodayMinute(vitaTime)
    
    local readyCanCome
    local leaveMinute = self:GetReadyQueueTime(CityResidentDefines.ReadyQueueTimeType.Leave)
    local comeMinute = self:GetReadyQueueTime(CityResidentDefines.ReadyQueueTimeType.Come)
    if leaveMinute > comeMinute then
        if comeMinute <= todayMinute and todayMinute <= leaveMinute then
            readyCanCome = self.readyQueueComeSwitch
        else
            readyCanCome = false
        end
    else
        if leaveMinute <= todayMinute and todayMinute <= comeMinute then
            readyCanCome = false
        else
            readyCanCome = self.readyQueueComeSwitch
        end
    end
    if self.readyCanCome ~= readyCanCome then
        self.readyCanCome = readyCanCome
        self:OnReadyQueueTimeChange()
        EventManager:GetInstance():Broadcast(EventId.CityResidentQueueTimeChanged)
    end
end

local function ThreatWhenCameraInFog(self)
    --local camPos = self.touchCamera:GetCameraTargetPos()
    --local disSqr = (camPos.x - 101) ^ 2 + (camPos.z - 101) ^ 2
    --local threatRadius = LuaEntry.DataConfig:TryGetNum("daynight_config", "k5")
    --if disSqr > threatRadius ^ 2 then
    --    self.threatSec = self.threatSec + 1
    --    if self.threatSec >= LuaEntry.DataConfig:TryGetNum("daynight_config", "k4") then
    --        self.threatSec = 0
    --        -- TODO: Beef 替换成丧尸吼叫
    --        SoundUtil.PlayEffect(SoundAssets.Music_Effect_Button)
    --    end
    --end
end

local function CheckLevelUp(self)
    if DataCenter.GuideManager:InGuide() then
        return
    end
    
    if not DataCenter.VitaManager:IsLevelUpEnabled() then
        return
    end
    
    local interval = DataCenter.VitaManager:GetConfig(VitaDefines.ConfigKey.LevelUpHudInterval) * 1000
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local remainTimes = {}
    for _, time in pairs(self.levelUpHudReduceCountTimes) do
        if curTime - time <= interval then
            table.insert(remainTimes, time)
        end
    end
    self.levelUpHudReduceCountTimes = remainTimes

    local maxCount = DataCenter.VitaManager:GetConfig(VitaDefines.ConfigKey.LevelUpHudCount)
    maxCount = maxCount - table.count(self.levelUpHudReduceCountTimes)
    local curCount = 0
    local dataList = self:GetDataListByType(CityResidentDefines.Type.Resident)
    for _, data in ipairs(dataList) do
        local show = false
        if curCount < maxCount and not DataCenter.CityResidentManager:IsZombieInvade() and data.residentData:CanLevelUp() then
            curCount = curCount + 1
            if data:CanShowLevelUp() then
                show = true
            end
        end
        if show then
            local hudParam = {}
            hudParam.uuid = data.uuid
            hudParam.type = CityHudType.ResidentLevelUp
            hudParam.GetPos = function() return data:GetPos() end
            hudParam.worldOffset = Vector3.New(0, 0.5, 0)
            hudParam.updateEveryFrame = true
            hudParam.layer = CityHudLayer.LevelUp
            hudParam.location = CityHudLocation.UI
            DataCenter.CityHudManager:Create(hudParam)
        else
            DataCenter.CityHudManager:Destroy(data.uuid, CityHudType.ResidentLevelUp)
        end
    end
end

local function UpdateAreaMatrix(self)
    self.areaMatrix:Clear()
    for _, data in pairs(self.dataDict) do
        local pos = data:GetPos()
        self.areaMatrix:AddByXY(pos.x, pos.z, data)
    end
end

local function GetZombieCount(self)
    local count = 0
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Zombie then
            count = count + 1
        end
    end
    return count
end

local function GetInvadeZombieCount(self, spawnId)
    local count = 0
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Zombie and data.state == CityResidentDefines.ZombieState.Invade and data.spawnId == spawnId then
            count = count + 1
        end
    end
    return count
end

local function GetNextZombieUuid(self)
    self.nextZombieUuid = self.nextZombieUuid + 1
    return self.nextZombieUuid
end

local function GetCanBeAttackZombie(self, pos, range, preferTargets)
    local zombieData = nil
    if not table.IsNullOrEmpty(preferTargets) then
        for _, data in ipairs(preferTargets) do
            if data:CanBeAttackZombie() then
                zombieData = data
                break
            end
        end
    end
    if zombieData == nil then
        local minDisSqr = IntMaxValue
        local dataList = self:GetDataListInRange(CityResidentDefines.Type.Zombie, pos, range)
        for _, data in ipairs(dataList) do
            if data:CanBeAttackZombie() then
                local curPos = data:GetPos()
                local dx = curPos.x - pos.x
                local dz = curPos.z - pos.z
                local disSqr = dx * dx + dz * dz
                if disSqr < minDisSqr then
                    minDisSqr = disSqr
                    zombieData = data
                end
            end
        end
    end
    return zombieData
end

local function GetFireBody(self, pos)
    local minDisData = nil
    local minDisSqr = IntMaxValue
    for _, uuid in ipairs(self.fireBodyUuids) do
        if self:IsFireBody(uuid) then
            local data = self:GetData(uuid)
            if data and data.attacker == nil then
                local curPos = data:GetPos()
                local dx = curPos.x - pos.x
                local dz = curPos.z - pos.z
                local disSqr = dx * dx + dz * dz
                if disSqr < minDisSqr then
                    minDisSqr = disSqr
                    minDisData = data
                end
            end
        end
    end
    return minDisData
end

local function GetSelectedHeroUuids(self)
    local uuids = {}
    local str = Setting:GetPrivateString("CITY_HERO", "")
    if str ~= "" then
        for _, spl in ipairs(string.split(str, ";")) do
            table.insert(uuids, tonumber(spl))
        end
    end
    return uuids
end

local function SetSelectedHeroUuids(self, uuids)
    Setting:SetPrivateString("CITY_HERO", string.join(uuids, ";"))
end

local function SetHeroOn(self, uuid, isOn, callback)
    local uuids = self:GetSelectedHeroUuids()
    if isOn then
        if not table.hasvalue(uuids, uuid) then
            table.insert(uuids, uuid)
            self:SetSelectedHeroUuids(uuids)
            self:CheckHeroes(callback)
        end
    else
        if table.hasvalue(uuids, uuid) then
            table.removebyvalue(uuids, uuid)
            self:SetSelectedHeroUuids(uuids)
            self:CheckHeroes(callback)
        end
    end
end

local function CheckHeroes(self, callback)
    local selectedUuids = self:GetSelectedHeroUuids()
    local curUuids = {}
    for _, data in ipairs(self:GetDataListByType(CityResidentDefines.Type.Hero)) do
        table.insert(curUuids, data.uuid)
    end

    local added = false
    for _, uuid in ipairs(selectedUuids) do
        if not table.hasvalue(curUuids, uuid) then
            self:AddData(uuid, CityResidentDefines.Type.Hero, nil, callback)
            added = true
        end
    end
    for _, uuid in ipairs(curUuids) do
        if not table.hasvalue(selectedUuids, uuid) then
            self:RemoveData(uuid)
        end
    end
    if not added then
        if callback then
            callback()
        end
    end
end

local function GetHeroSpawnPos(self)
    return Vector3.New(100.83, 0, 99.254)
end

local function SetCanSpawnZombie(self, canSpawnZombie)
    self.canSpawnZombie = canSpawnZombie
end

local function GetNoBedResidentUuids(self)
    local curSeg = DataCenter.VitaManager:GetCurSegment()
    if curSeg.type ~= VitaDefines.SegmentType.Sleep then
        return {}
    end
    local vitaData = DataCenter.VitaManager:GetData()
    if vitaData == nil or vitaData.furnaceState == VitaDefines.FurnaceState.Close or vitaData.furnaceState == VitaDefines.FurnaceState.CloseWithBooster then
        return {}
    end
    local uuids = {}
    local dataList = self:GetDataListByType(CityResidentDefines.Type.Resident)
    for _, data in ipairs(dataList) do
        if data.state == CityResidentDefines.State.SleepNoBed then
            table.insert(uuids, data.uuid)
        end
    end
    return uuids
end

local function GetNoBedPos(self)
    local mask = self:GetCurrentCityMask()
    local pos = WayPointUtil.GetRandomPos(mask, CityResidentDefines.WayPointFlag.Center)
    return pos
end

local function GetResidentPrefab(self, uuid)
    local data = self:GetData(uuid)
    if data.param.prefabPath then
        return data.param.prefabPath
    end
    local model = GetTableData(TableName.VitaResident, data.residentData.id, "model")
    if not string.IsNullOrEmpty(model) then
        local path = string.format("Assets/Main/Prefab_Dir/Home/Resident/%s.prefab", model)
        return path
    end
    return ""
end

local function GetZombiePrefab(self, uuid)
    local index = uuid % 4 + 1
    local path = string.format("Assets/Main/Prefab_Dir/Home/Zombie/A_Zombie_Home_%d.prefab", index)
    return path
end

local function GetFurnitureInteractTransform(self, fUuid, index)
    local furnitureTf = DataCenter.FurnitureObjectManager:GetTransformByFurnitureUuid(fUuid)
    if furnitureTf then
        local tf = furnitureTf:Find("Interact_" .. index)
        if tf then
            return tf
        end
    end
    return nil
end

-- 随机获取医院中有病人的床位
local function GetRandomSickBedByBUuid(self, bUuid)
    local fUuids = {}
    local furnitureInfoList = DataCenter.FurnitureManager:GetFurnitureListByBUuid(bUuid)
    for _, furnitureInfo in ipairs(furnitureInfoList) do
        local fUuid = furnitureInfo.uuid
        for _, data in pairs(self.dataDict) do
            if data.type == CityResidentDefines.Type.Resident and data.residentData.hUuid == fUuid then
                table.insert(fUuids, fUuid)
            end
        end
    end
    if #fUuids > 0 then
        return table.randomArrayValue(fUuids)
    else
        return 0
    end
end

local function IsHeroUnlocked(self, index)
    if self.heroUnlockConditionCache == nil then
        self.heroUnlockConditionCache = {}
        local str1 = LuaEntry.DataConfig:TryGetStr("base_hero", "k1")
        local str2 = LuaEntry.DataConfig:TryGetStr("base_hero", "k2")
        local str3 = LuaEntry.DataConfig:TryGetStr("base_hero", "k3")
        local spls1 = string.split(str1, ";")
        local spls2 = string.split(str2, ";")
        local spls3 = string.split(str3, ";")
        for i = 1, 3 do
            self.heroUnlockConditionCache[i] =
            {
                needMainLv = DataCenter.BuildManager:GetBuildLevel(tonumber(spls1[i]) or 0),
                needQuestId = tonumber(spls2[i]) or 0,
                guaranteeMainLv = DataCenter.BuildManager:GetBuildLevel(tonumber(spls3[i]) or 0),
            }
        end
    end
    
    local condition = self.heroUnlockConditionCache[index]
    if condition == nil then
        return true
    end
    
    local mainLv = DataCenter.BuildManager.MainLv
    if mainLv >= condition.guaranteeMainLv then
        return true
    end

    if mainLv >= condition.needMainLv then
        if condition.needQuestId == 0 or
           DataCenter.TaskManager:IsFinishTask(tostring(condition.needQuestId)) or
           DataCenter.ChapterTaskManager:CheckIsSuccess(tostring(condition.needQuestId)) then
            return true
        end
    end

    return false
end

local function GetNextFoodWindowTransform(self)
    local furnitureInfoList = DataCenter.FurnitureManager:GetFurnitureByFurnitureId(FurnitureType.FoodWindow)
    if #furnitureInfoList > 0 then
        local furnitureInfo = furnitureInfoList[1]
        self.foodWindowIndex = self.foodWindowIndex % CityResidentDefines.RestaurantFoodWindowCount + 1
        local tf = self:GetFurnitureInteractTransform(furnitureInfo.uuid, self.foodWindowIndex)
        return tf
    end
    return nil
end

-- 返回 0 代表没有该句
local function GetResidentTalkDialog(self, bIdOrFId, level, type)
    bIdOrFId = bIdOrFId or 0
    level = level or 0
    local levelId = bIdOrFId + level
    if self.talkDialogCache == nil then
        self.talkDialogCache = {}
    end
    if self.talkDialogCache[levelId] == nil then
        self.talkDialogCache[levelId] = {}
    end
    if self.talkDialogCache[levelId][type] == nil then
        local maxLevelDialog = nil
        local maxLevel = 0
        LocalController:instance():visitTable(TableName.ResidentTalk, function(_, lineData)
            if self.talkDialogCache[levelId][type] then
                return
            end
            if tonumber(lineData.type) == type then
                local strs = string.split(tostring(lineData.buildID), ";")
                local dialogs = string.split(tostring(lineData.dialog), ";")
                for _, str in ipairs(strs) do
                    local lineLevelId = tonumber(str) or 0
                    local lineId = DataCenter.BuildManager:GetBuildId(lineLevelId)
                    local lineLevel = DataCenter.BuildManager:GetBuildLevel(lineLevelId)
                    if lineId == bIdOrFId then
                        if lineLevel == level then
                            self.talkDialogCache[levelId][type] = dialogs
                            break
                        end
                        if lineLevel > maxLevel then
                            maxLevelDialog = dialogs
                            maxLevel = lineLevel
                        end
                    end
                end
            end
        end)
        if self.talkDialogCache[levelId][type] == nil then
            self.talkDialogCache[levelId][type] = maxLevelDialog or {}
        end
    end
    return self.talkDialogCache[levelId][type]
end

local function TryResidentTalk(self, param)
    if not self.isInCity then
        return
    end

    -- 检查引导或大本等级
    local guideId = LuaEntry.DataConfig:TryGetNum("opinion_raise","k1")
    local needMainLv = LuaEntry.DataConfig:TryGetNum("opinion_raise","k2")
    if not DataCenter.GuideManager:IsDoneThisGuide(guideId) and DataCenter.BuildManager.MainLv < needMainLv then
        return
    end

    -- 检查正在说话
    local hudItem = DataCenter.CityHudManager:GetHudItem(param.rUuid, CityHudType.Speak)
    if hudItem then
        return
    end

    -- 检查建筑或家具等级
    local dialogs = self:GetResidentTalkDialog(param.buildId or param.furnitureId, param.level, param.type)
    if table.IsNullOrEmpty(dialogs) then
        return
    end

    local curTime = UITimeManager:GetInstance():GetServerTime()
    local nextTime = 0
    if self.talkTypeTimes[param.type] == nil then
        self.talkTypeTimes[param.type] = {}
    end
    if self.talkSingleNextTime[param.rUuid] == nil then
        self.talkSingleNextTime[param.rUuid] = {}
    end

    local data = self:GetData(param.rUuid)
    if data and data.type == CityResidentDefines.Type.Resident then
        local checkTypeTime
        local checkSingleTime
        local checkMaxCount
        local checkTypeMaxCount
        
        if param.type == CityResidentDefines.TalkTriggerType.SetWorkBatch or
           param.type == CityResidentDefines.TalkTriggerType.LevelUp then
            checkTypeTime = false
            checkSingleTime = false
            checkMaxCount = false
            checkTypeMaxCount = false
        elseif param.type == CityResidentDefines.TalkTriggerType.SetCareerHunter or
               param.type == CityResidentDefines.TalkTriggerType.SetCareerSawyer or
               param.type == CityResidentDefines.TalkTriggerType.SetCareerChef or
               param.type == CityResidentDefines.TalkTriggerType.SetCareerSmith or
               param.type == CityResidentDefines.TalkTriggerType.SetCareerPowerman or
               param.type == CityResidentDefines.TalkTriggerType.SetCareerDoctor or
               param.type == CityResidentDefines.TalkTriggerType.SetCareerBartender then
            checkTypeTime = false
            checkSingleTime = false
            checkMaxCount = false
            checkTypeMaxCount = true
        else
            checkTypeTime = true
            checkSingleTime = true
            checkMaxCount = true
            checkTypeMaxCount = false
        end

        if checkTypeTime then
            -- 检查类型间隔
            nextTime = self.talkTypeNextTimes[param.type] or 0
            if curTime < nextTime then
                return
            end
        end

        if checkSingleTime then
            -- 检查自己类型间隔
            nextTime = self.talkSingleNextTime[param.rUuid][param.type] or 0
            if curTime < nextTime then
                return
            end
        end

        if checkMaxCount then
            -- 检查最大数量
            local minTime = curTime - CityResidentDefines.ResidentTalkDuration * 1000
            local remainTimes = {}
            for _, time in ipairs(self.talkTimes) do
                if time >= minTime then
                    table.insert(remainTimes, time)
                end
            end
            self.talkTimes = remainTimes
            if #remainTimes >= CityResidentDefines.ResidentTalkCount then
                return
            end
        end

        if checkTypeMaxCount then
            -- 检查类型最大数量
            local minTime = curTime - param.duration * 1000
            local remainTimes = {}
            for _, time in ipairs(self.talkTypeTimes[param.type]) do
                if time >= minTime then
                    table.insert(remainTimes, time)
                end
            end
            self.talkTypeTimes[param.type] = remainTimes
            if #remainTimes >= param.typeMaxCount then
                return
            end
        end
    end
    
    -- 成功说话
    local dialog = table.randomArrayValue(dialogs)
    self.talkTypeNextTimes[param.type] = curTime + math.random(CityResidentDefines.ResidentTalkIntervalMin, CityResidentDefines.ResidentTalkIntervalMax) * 1000
    self.talkSingleNextTime[param.rUuid][param.type] = curTime + CityResidentDefines.ResidentTalkSingleInterval * 1000
    table.insert(self.talkTimes, curTime)
    table.insert(self.talkTypeTimes[param.type], curTime)
    local duration = param.duration or CityResidentDefines.ResidentTalkDuration
    self:ResidentSpeak(param.rUuid, Localization:GetString(dialog), duration, param)
end

local function ResidentSpeak(self, uuid, text, duration, param)
    if not self.isInCity then
        return
    end
    
    local data = self:GetData(uuid)
    if data == nil or not data:HasObj() or data:IsDead() then
        return
    end
    if data.type == CityResidentDefines.Type.Resident and data.residentData:IsReady() then
        return
    end
    
    param = param or {}
    local hudParam = {}
    hudParam.uuid = uuid
    hudParam.GetPos = function() return data:GetPos() end
    hudParam.type = CityHudType.Speak
    hudParam.text = text
    hudParam.offset = param.offset or Vector3.New(0, 60, 0)
    hudParam.worldOffset = param.worldOffset or Vector3.New(0, 0, 0)
    hudParam.duration = duration
    hudParam.updateEveryFrame = true
    hudParam.layer = CityHudLayer.Speak
    hudParam.location = param.location or CityHudLocation.UI
    hudParam.bgType = param.bgType or 1
    DataCenter.CityHudManager:Create(hudParam)
end

local function ResidentEmo(self, uuid, emoType, duration)
    if not self.isInCity then
        return
    end
    
    local data = self:GetData(uuid)
    if data == nil or not data:HasObj() or data.residentData:IsReady() then
        return
    end
    
    local hudParam = {}
    hudParam.uuid = uuid
    hudParam.GetPos = function() return data:GetPos() end
    hudParam.type = CityHudType.Emoji
    hudParam.emoType = emoType
    hudParam.offset = Vector3.New(50, 80, 0)
    hudParam.duration = duration
    hudParam.updateEveryFrame = true
    hudParam.layer = CityHudLayer.Speak
    hudParam.location = CityHudLocation.UI
    DataCenter.CityHudManager:Create(hudParam)
end

local function ScareResidentsAtPos(self, pos)
    local dataList = self:GetDataListInRange(CityResidentDefines.Type.Resident, pos, self:GetResidentScareRange())
    for _, data in ipairs(dataList) do
        if not data:IsScared() then
            self:ResidentScare(data.uuid)
        end
    end
end

local function ScareResidentsByBUuid(self, bUuid)
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data.atBUuid == bUuid then
            self:ResidentScare(data.uuid)
        end
    end
end

local function ResidentScare(self, uuid)
    local data = self:GetData(uuid)
    if data == nil or not data:HasObj() or
       data.isGuideControl or data.residentData:IsReady() or
       data:IsDead() or data.residentData.deadReason ~= VitaDefines.ResidentDeadReason.None then
        return
    end
    if data.state == CityResidentDefines.State.ScareHide and not data:IsInDestroyedBuilding() then
        return
    end
    data:SetState(CityResidentDefines.State.Scare)
end

local function SetMoverUpdateInterval(self, updateInterval)
    if CS.CityResidentMover.SetUpdateInterval then
        CS.CityResidentMover.SetUpdateInterval(updateInterval)
    end
end

local function GetBetrayPos(self, betrayIndex)
    if self.betrayPosCache == nil then
        self.betrayPosCache = { fromPoses = {}, toPoses = {} }
        local cfgStr = LuaEntry.DataConfig:TryGetStr("people_work_config", "k17")
        local strs = string.split(cfgStr, "|")
        for i, str in ipairs(strs) do
            local posStrs = string.split(str, ";")
            for j, posStr in ipairs(posStrs) do
                local spls = string.split(posStr, ",")
                local x = tonumber(spls[1])
                local y = tonumber(spls[2])
                local z = tonumber(spls[3])
                local pos = Vector3.New(x, y, z)
                if i == 1 then
                    self.betrayPosCache.fromPoses[j] = pos
                elseif i == 2 then
                    self.betrayPosCache.toPoses[j] = pos
                end
            end
        end
    end

    if betrayIndex <= 0 or betrayIndex > #self.betrayPosCache.toPoses then
        return nil, nil
    end
    local fromPos = table.randomArrayValue(self.betrayPosCache.fromPoses)
    local toPos = self.betrayPosCache.toPoses[betrayIndex]
    return fromPos, toPos
end

local function GetReadyQueuePos(self, readyIndex)
    if self.readyQueuePosCache == nil then
        self.readyQueuePosCache = { fromPoses = {}, toPoses = {} }
        local cfgStr = LuaEntry.DataConfig:TryGetStr("people_comein", "k1")
        local strs = string.split(cfgStr, "|")
        for i, str in ipairs(strs) do
            local posStrs = string.split(str, ";")
            for j, posStr in ipairs(posStrs) do
                local spls = string.split(posStr, ",")
                local x = tonumber(spls[1])
                local y = tonumber(spls[2])
                local z = tonumber(spls[3])
                local pos = Vector3.New(x, y, z)
                if i == 1 then
                    self.readyQueuePosCache.fromPoses[j] = pos
                elseif i == 2 then
                    self.readyQueuePosCache.toPoses[j] = pos
                end
            end
        end
    end

    if readyIndex <= 0 or readyIndex > #self.readyQueuePosCache.toPoses then
        return nil, nil
    end
    local fromPos = table.randomArrayValue(self.readyQueuePosCache.fromPoses)
    local toPos = self.readyQueuePosCache.toPoses[readyIndex]
    return fromPos, toPos
end

local function GetReadyQueueTime(self, type)
    if self.readyQueueTimeCache == nil then
        self.readyQueueTimeCache = {}
        local cfgStr = LuaEntry.DataConfig:TryGetStr("people_comein", "k2")
        local strs = string.split(cfgStr, ";")
        for i, str in ipairs(strs) do
            self.readyQueueTimeCache[i] = tonumber(str) * 60
        end
    end
    
    return self.readyQueueTimeCache[type]
end

local function SetReadyQueueComeSwitch(self, isOn)
    self.readyQueueComeSwitch = isOn
    
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data.residentData:IsReady() then
            data.immediate = true
            if isOn then
                data:SetState(CityResidentDefines.State.ReadyQueue)
            else
                data:SetState(CityResidentDefines.State.ReadyHide)
            end
        end
    end
end

local function SetReadyQueueHudSwitch(self, isOn)
    self.readyQueueHudSwitch = isOn

    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data.residentData:IsReady() then
            data:CheckShowReadyQueueHud()
        end
    end
end

--是否有小人正在排队
local function IsResidentQueueCome(self)
    local residentCount = DataCenter.VitaManager:GetResidentCount()
    local residentMaxCount = DataCenter.VitaManager:GetResidentMaxCount()
    local residentReadyCount = #DataCenter.VitaManager:GetReadyResidentDataList()
    local readyCanCome = DataCenter.CityResidentManager.readyCanCome
    if residentReadyCount > 0 and residentCount < residentMaxCount and readyCanCome then
        return true
    end
    return false
end

local function GetCurrentCityMask(self)
    return 1
end

-- 播放小人升级表现
local function PlayResidentLevelUp(self, uuid)
    if not self:IsEngaged() then
        return
    end
    
    local data = self:GetData(uuid)
    if data == nil or not data:HasObj() or data:IsDead() then
        return
    end
    
    local curTime = UITimeManager:GetInstance():GetServerTime()
    table.insert(self.levelUpHudReduceCountTimes, curTime)
    
    DataCenter.CityHudManager:Destroy(uuid, CityHudType.ResidentLevelUp)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIVitaResidentLevelUp)
    
    -- 给予资源
    --local hudParam = {}
    --hudParam.uuid = uuid
    --hudParam.type = CityHudType.ResidentGive
    --hudParam.GetPos = function() return data:GetPos() end
    --hudParam.duration = 1
    --hudParam.updateEveryFrame = true
    --hudParam.worldOffset = Vector3.New(0, 0.5, 0)
    --hudParam.location = CityHudLocation.World
    --DataCenter.CityHudManager:Create(hudParam)
    -- 特效
    self:ShowEffect("Assets/Main/Prefab_Dir/Effect/Eff_PVE_buff.prefab", data.obj.transform, Vector3.zero, 5)
    -- 小人说话
    local param = {}
    param.type = CityResidentDefines.TalkTriggerType.LevelUp
    param.rUuid = uuid
    DataCenter.CityResidentManager:TryResidentTalk(param)
end

local function GetZombieChaseRange(self)
    if self.zombieChaseRange == nil then
        self.zombieChaseRange = {}
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k1")
        local spls = string.split(str, "|")
        self.zombieChaseRange[VitaDefines.DayNight.Day] = tonumber(spls[1]) or 0
        self.zombieChaseRange[VitaDefines.DayNight.Night] = tonumber(spls[2]) or 0
        self.zombieChaseRange[VitaDefines.DayNight.LateAtNight] = tonumber(spls[2]) or 0
    end
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local dayNight = DataCenter.VitaManager:GetDayNight(curTime)
    return self.zombieChaseRange[dayNight]
end

local function GetZombieAttackRange(self)
    return CityResidentDefines.ZombieAttackRange
end

local function GetZombieAttackDamage(self)
    if self.zombieAttackDamage == nil then
        self.zombieAttackDamage = LuaEntry.DataConfig:TryGetNum("safety_area", "k2")
    end
    return self.zombieAttackDamage
end

local function GetZombieWalkSpeed(self)
    if self.zombieWalkSpeed == nil then
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k3")
        local spls = string.split(str, "|")
        self.zombieWalkSpeed = tonumber(spls[1]) or 1
    end
    return self.zombieWalkSpeed
end

local function GetZombieChaseSpeed(self)
    if self.zombieChaseSpeed == nil then
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k3")
        local spls = string.split(str, "|")
        self.zombieChaseSpeed = tonumber(spls[2]) or 1
    end
    return self.zombieChaseSpeed
end

local function GetZombieRetreatSpeed(self)
    if self.zombieRetreatSpeed == nil then
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k3")
        local spls = string.split(str, "|")
        self.zombieRetreatSpeed = tonumber(spls[3]) or 1
    end
    return self.zombieRetreatSpeed
end

local function GetResidentScareRange(self)
    if self.residentScareRange == nil then
        self.residentScareRange = {}
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k4")
        local spls = string.split(str, "|")
        self.residentScareRange[VitaDefines.DayNight.Day] = tonumber(spls[1]) or 0
        self.residentScareRange[VitaDefines.DayNight.Night] = tonumber(spls[2]) or 0
        self.residentScareRange[VitaDefines.DayNight.LateAtNight] = tonumber(spls[2]) or 0
    end
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local dayNight = DataCenter.VitaManager:GetDayNight(curTime)
    return self.residentScareRange[dayNight]
end

local function GetResidentWalkSpeed(self)
    if self.residentWalkSpeed == nil then
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k5")
        local spls = string.split(str, "|")
        self.residentWalkSpeed = tonumber(spls[1]) or 1
    end
    return self.residentWalkSpeed
end

local function GetResidentRunSpeed(self)
    if self.residentRunSpeed == nil then
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k5")
        local spls = string.split(str, "|")
        self.residentRunSpeed = tonumber(spls[2]) or 1
    end
    return self.residentRunSpeed
end

local function GetResidentInjuredStamina(self)
    if self.residentInjuredStamina == nil then
        self.residentInjuredStamina = LuaEntry.DataConfig:TryGetNum("safety_area", "k6")
    end
    return self.residentInjuredStamina
end

local function GetZombieMaxCount(self)
    if self.zombieMaxCount == nil then
        self.zombieMaxCount = LuaEntry.DataConfig:TryGetNum("safety_area", "k10")
    end
    return self.zombieMaxCount
end

local function GetZombieInvadeMaxCount(self)
    if self.zombieInvadeMaxCount == nil then
        self.zombieInvadeMaxCount = LuaEntry.DataConfig:TryGetNum("safety_area", "k11")
    end
    return self.zombieInvadeMaxCount
end

local function GetZombieInvadeTime(self)
    if self.zombieInvadeTime == nil then
        self.zombieInvadeTime = {}
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k15")
        local spls = string.split(str, ",")
        if #spls == 2 then
            self.zombieInvadeTime[1] = (tonumber(spls[1]) or 0) * 60
            self.zombieInvadeTime[2] = (tonumber(spls[2]) or 0) * 60
        end
    end
    return (self.zombieInvadeTime[1] or 0), (self.zombieInvadeTime[2] or 0)
end

local function GetZombieMaxStamina(self)
    if self.zombieMaxStamina == nil then
        self.zombieMaxStamina = LuaEntry.DataConfig:TryGetNum("zombie_hunter", "k1")
    end
    if self.zombieMaxStamina == nil then
        self.zombieMaxStamina = 1 -- default
    end
    return self.zombieMaxStamina
end

local function GetZombieRetreatLifetime(self)
    if self.zombieRetreatLifetime == nil then
        self.zombieRetreatLifetime = LuaEntry.DataConfig:TryGetNum("safety_area", "k16")
    end
    return self.zombieRetreatLifetime
end

local function AddFireBody(self, uuid)
    if not table.hasvalue(self.fireBodyUuids, uuid) then
        table.insert(self.fireBodyUuids, uuid)
    end
end

local function RemoveFireBody(self, uuid)
    table.removebyvalue(self.fireBodyUuids, uuid)
end

local function IsFireBody(self, uuid)
    return table.hasvalue(self.fireBodyUuids, uuid)
end

local function GetZombieSpawnPosDict(self, mask)
    if self.zombieSpawnPosDict[mask] == nil then
        self:InitZombieSpawnPosDict(mask)
    end
    return self.zombieSpawnPosDict[mask] or {}
end

local function InitZombieSpawnPosDict(self, mask)
    local wayPoints = WayPointUtil.GetWayPointsByMask(mask, CityResidentDefines.WayPointFlag.ZombieSpawn)
    if wayPoints == nil then
        return
    end

    self.zombieSpawnPosDict[mask] = {}
    for i = 0, wayPoints.Count - 1 do
        local wayPoint = wayPoints[i]
        local id = tonumber(WayPointUtil.GetWayPointArg(wayPoint, "spawnId"))
        local pos = wayPoint.pos
        local weight = tonumber(GetTableData(TableName.CityZombieSpawn, id, "weight")) or 0
        self.zombieSpawnPosDict[mask][id] = { id = id, pos = pos, weight = weight }
        Logger.Log("CityResidentManager Record zombieSpawnPosDict mask = " .. mask .. ", id = " .. id)
    end
end

local function SetPeace(self, isPeace)
    if not self:IsEngaged() then
        return
    end
    
    self.isPeace = isPeace
    
    if isPeace then
        self:OnZombieRetreat()
        for _, data in pairs(self.dataDict) do
            data:Refresh()
        end
    end
end

local function IsPeace(self)
    return self.isPeace
end

local function TryAutoReleaseBetrayResident(self)
    if self.betrayStartTime == 0 then
        return
    end
    local curTime = UITimeManager:GetInstance():GetServerTime()
    if curTime - self.betrayStartTime >= CityResidentDefines.ResidentAutoBetrayTime * 1000 then
        self:ReleaseBetrayResident()
    end
end

local function ReleaseBetrayResident(self)
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data.residentData.deadReason == VitaDefines.ResidentDeadReason.Betray then
            data:SetState(CityResidentDefines.State.BetrayLeave)
        end
    end
    self.betrayStartTime = 0
end

local function GetHeroSearchZombieRange(self)
    if self.heroSearchZombieRangeCache == nil then
        self.heroSearchZombieRangeCache = {}
        local cfgStr = LuaEntry.DataConfig:TryGetStr("zombie_hunter", "k2")
        for i, str in ipairs(string.split(cfgStr, "|")) do
            local spls = string.split(str, ";")
            if #spls == 2 then
                self.heroSearchZombieRangeCache[i] = { lv = tonumber(spls[1]), range = tonumber(spls[2]) }
            end
        end
    end
    local mainLv = DataCenter.BuildManager.MainLv
    if self.mainLvHeroSearchZombieRangeCache == nil then
        self.mainLvHeroSearchZombieRangeCache = {}
    end
    if self.mainLvHeroSearchZombieRangeCache[mainLv] == nil then
        -- cache mainLv to range
        for _, v in ipairs(self.heroSearchZombieRangeCache) do
            if mainLv <= v.lv then
                self.mainLvHeroSearchZombieRangeCache[mainLv] = v.range
                break
            end
        end
    end
    if self.mainLvHeroSearchZombieRangeCache[mainLv] == nil then
        self.mainLvHeroSearchZombieRangeCache[mainLv] = 6 -- default
    end
    return self.mainLvHeroSearchZombieRangeCache[mainLv]
end

local function GetSafeRadius(self)
    local mainLv = DataCenter.BuildManager.MainLv
    local state = DataCenter.VitaManager:GetFurnaceState()
    if state == VitaDefines.FurnaceState.OpenWithBooster then
        mainLv = mainLv + 2
    end
    if self.safeRadiusCache == nil then
        self.safeRadiusCache = {}
    end
    if self.safeRadiusCache[mainLv] == nil then
        local cfgStr = LuaEntry.DataConfig:TryGetStr("safety_area", "k12")
        local maxRadius = 0
        for _, str in ipairs(string.split(cfgStr, "|")) do
            local spls = string.split(str, ";")
            if #spls == 2 then
                local lv = tonumber(spls[1])
                local radius = tonumber(spls[2])
                maxRadius = math.max(maxRadius, radius)
                if self.safeRadiusCache[mainLv] == nil and mainLv <= lv then
                    self.safeRadiusCache[mainLv] = radius
                end
            end
        end
        if self.safeRadiusCache[mainLv] == nil then
            self.safeRadiusCache[mainLv] = maxRadius
        end
    end
    return self.safeRadiusCache[mainLv]
end

local function GetBrokenInvadeWayPoint(self, spawnId)
    local mask = self:GetCurrentCityMask()
    local wayPoints = WayPointUtil.GetWayPointsByMask(mask, CityResidentDefines.WayPointFlag.Invade, spawnId)
    if wayPoints and wayPoints.Count > 0 then
        for i = 0, wayPoints.Count - 1 do
            local wayPoint = wayPoints[i]
            local wallId = tonumber(WayPointUtil.GetWayPointArg(wayPoint, "wallId"))
            if wallId then
                local wallData = DataCenter.CityWallManager:GetData(wallId)
                if wallData and wallData:IsBroken() then
                    return wayPoint
                end
            end
        end
    end
    return nil
end

local function GetRandomInvadeWayPoint(self, spawnId)
    local mask = self:GetCurrentCityMask()
    local wayPoints = WayPointUtil.GetWayPointsByMask(mask, CityResidentDefines.WayPointFlag.Invade, spawnId)
    if wayPoints and wayPoints.Count > 0 then
        local ran = math.random(0, wayPoints.Count - 1)
        return wayPoints[ran]
    end
    return nil
end

local function ResetSafeWayPoints(self, mask)
    pcall(function()
        Logger.Log("CityResidentManager ResetSafeWayPoints mask = " .. mask)
        local mainPosX = 101
        local mainPosZ = 101
        local safeRadiusSqr = self:GetSafeRadius() ^ 2
        local wayPoints = WayPointUtil.GetWayPointsByMask(mask, CityResidentDefines.WayPointFlag.All)
        if wayPoints and wayPoints.Count > 0 then
            for i = 0, wayPoints.Count - 1 do
                local wayPoint = wayPoints[i]
                local disSqr = (wayPoint.pos.x - mainPosX) ^ 2 + (wayPoint.pos.z - mainPosZ) ^ 2
                if disSqr < safeRadiusSqr then
                    wayPoint.flag = wayPoint.flag | CityResidentDefines.WayPointFlag.SafeHide
                end
            end
            Logger.Log("CityResidentManager ResetSafeWayPoints Success!")
        end
    end)
end

local function RefreshOverwork(self)
    self.overworkDict = {}
    self.overworkUuids = {}
    
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and
           not data:IsDead() and not data.residentData:IsReady() and not data.residentData:IsSick()
        then
            local furnitureInfo = DataCenter.FurnitureManager:GetFurnitureByUuid(data.residentData.fUuid)
            if furnitureInfo then
                local bUuid = furnitureInfo.bUuid
                if self.overworkDict[bUuid] == nil then
                    self.overworkDict[bUuid] = data.uuid
                    table.insert(self.overworkUuids, data.uuid)
                end
            end
        end
    end
end

local function UseNewPathMethod(self)
    if self.useNewPathMethod == nil then
        local ok = pcall(function()
            CS.CityResidentMover.UseNewMethod()
        end)
        self.useNewPathMethod = ok
        Logger.Log("CityResident UseNewPathMethod: " .. (ok and "true" or "false"))
    end
    return self.useNewPathMethod
end

local function GetReviveCost(self)
    if self.reviveCost == nil then
        self.reviveCost = {}
        local str = LuaEntry.DataConfig:TryGetStr("safety_area", "k17")
        local spls = string.split(str, ";")
        self.reviveCost.stamina = tonumber(spls[1]) or 0
        self.reviveCost.mood = tonumber(spls[2]) or 0
    end
    return self.reviveCost
end

local function CanShowMainSafe(self)
    local vitaData = DataCenter.VitaManager:GetData()
    if vitaData == nil or vitaData.furnaceState == VitaDefines.FurnaceState.Close or vitaData.furnaceState == VitaDefines.FurnaceState.CloseWithBooster then
        return false
    end
    
    --if not DataCenter.CityResidentManager.canSpawnZombie then
    --    return false
    --end
    
    if DataCenter.BuildManager.showSafe then
        return true
    end

    local mainLv = DataCenter.BuildManager.MainLv or 0
    if mainLv < 3 then
        return false
    end
    
    if not DataCenter.CityResidentManager:IsZombieInvade() then
        return false
    end
    
    local hideMainLv = LuaEntry.DataConfig:TryGetNum("safety_area", "k18")
    if mainLv >= hideMainLv then
        local attackData = DataCenter.CitySiegeManager:GetAttackData()
        if attackData:GetState() ~= CitySiegeAttackState.Playing then
            return false
        end
    end
    
    return true
end

local function GetResidentWantMaxCount(self)
    if self.residentWantMaxCount == nil then
        self.residentWantMaxCount = LuaEntry.DataConfig:TryGetNum("people_work_config", "k18")
    end
    return self.residentWantMaxCount
end

local function GetResidentWantDuration(self)
    if self.residentWantDuration == nil then
        self.residentWantDuration = LuaEntry.DataConfig:TryGetNum("people_work_config", "k19")
    end
    return self.residentWantDuration
end

local function ClearAllEffects(self)
    for _, req in pairs(self.effReqDict) do
        req:Destroy()
    end
end

local function ShowEffect(self, path, parent, pos, duration)
    self.effectIndex = (self.effectIndex or 0) + 1
    local req = Resource:InstantiateAsync(path)
    req:completed('+', function(_)
        local tf = req.gameObject.transform
        tf:SetParent(parent)
        tf.localPosition = pos
        TimerManager:GetInstance():DelayInvoke(function()
            req:Destroy()
        end, duration)
    end)
    self.effReqDict[self.effectIndex] = req
end

local function OnDataChange()
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident then
            data:CheckShowStamina()
        end
    end
end

local function OnSegmentChange()
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    self.occupyMgr:OnSegmentChange()
    self.talkTypeNextTimes = {}

    local curSeg = DataCenter.VitaManager:GetCurSegment()
    if curSeg.type == VitaDefines.SegmentType.Rest or curSeg.type == VitaDefines.SegmentType.Sleep then
        self:RefreshOverwork()
    end

    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident then
            data.eaten = false
            data.overworked = false
            data.drunkEndTime = 0
            data:Refresh()
        end
    end
end

local function OnDayNightChange()
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end

    self.animalMgr:OnDayNightChange()
end

local function OnZombieInvadeChange(self)
    if not self:IsZombieInvade() then
        self:SetPeace(false)
        self:OnZombieRetreat()
    end
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Zombie then
            data:Refresh()
        end
    end
end

local function OnReadyQueueTimeChange()
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end

    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident and data.residentData:IsReady() then
            data:Refresh()
        end
    end
end

local function OnShowFurniture(bUuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    self.focusBUuid = bUuid
    DataCenter.CityHudManager:RefreshAll()
end

local function OnHideFurniture(bUuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    self.focusBUuid = 0
    DataCenter.CityHudManager:RefreshAll()
end

local function OnEnterWorld()
    local self = DataCenter.CityResidentManager
    self.isInCity = false
    self:DestroyAll()
    self:ClearAllEffects()
end

local function OnEnterCity()
    DataCenter.GuideManager:SetWaitingMessage(WaitMessageFinishType.ResidentLoad, true)
    local self = DataCenter.CityResidentManager
    self.isInCity = true
    self:CreateAll(function()
        --self:RefreshAll()
        DataCenter.GuideManager:SetWaitingMessage(WaitMessageFinishType.ResidentLoad, nil)
        EventManager:GetInstance():Broadcast(EventId.GuideWaitMessage)
    end)
end

local function OnPveLevelEnter()
    local self = DataCenter.CityResidentManager
    self.isInCity = false
    self:DestroyAll()
    self:ClearAllEffects()
end

local function OnPveLevelExit()
    if not SceneUtils.GetIsInCity() then
        return
    end
    local self = DataCenter.CityResidentManager
    self.isInCity = true
    self:CreateAll(function()
        --self:RefreshAll()
    end)
end

local function OnBuildInView(bUuid)
    local self = DataCenter.CityResidentManager
    local buildData = DataCenter.BuildManager:GetBuildingDataByUuid(bUuid)
    if buildData and table.hasvalue(CityResidentDefines.ScareHideBuildIds, buildData.itemId) then
        local cityBuilding = CS.SceneManager.World:GetBuildingByPoint(buildData.pointId)
        if cityBuilding then
            local tf = cityBuilding.transform
            CS.CityResidentPathUtil.RecordWayPoints(bUuid, "Path_" .. buildData.itemId, tf.position, tf.rotation)
            if self.buildInViewTimer then
                self.buildInViewTimer:Stop()
            end
            self.buildInViewTimer = TimerManager:GetInstance():DelayInvoke(function()
                self:RefreshAll()
                self.buildInViewTimer = nil
            end, 1)
        end
    end
end

local function OnBuildOutView()
    
end

local function OnFurnitureUpgrade(fUuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    local curSeg = DataCenter.VitaManager:GetCurSegment()
    if curSeg.type == VitaDefines.SegmentType.Sleep then
        local furnitureInfo = DataCenter.FurnitureManager:GetFurnitureByUuid(fUuid)
        if furnitureInfo and furnitureInfo.fId == FurnitureType.Bed then
            local noBedUuids = self:GetNoBedResidentUuids()
            for _, rUuid in ipairs(noBedUuids) do
                local data = self:GetData(rUuid)
                data:Refresh()
            end
        end
    end
end

local function OnResidentEnterBuilding(param)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    local buildData = DataCenter.BuildManager:GetBuildingDataByUuid(param.bUuid)
    if buildData == nil then
        return
    end

    local type = nil
    if buildData.itemId == BuildingTypes.DS_HOUSE_1 or
       buildData.itemId == BuildingTypes.DS_HOUSE_2 or
       buildData.itemId == BuildingTypes.DS_HOUSE_3 then
        type = CityResidentDefines.TalkTriggerType.EnterHouse
    end

    if type then
        param.type = type
        param.buildId = buildData.itemId
        param.level = buildData.level
        self:TryResidentTalk(param)
    end
end

local function OnResidentExitBuilding(param)
    
end

local function OnResidentEnterFurniture(param)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    local furnitureInfo = DataCenter.FurnitureManager:GetFurnitureByUuid(param.fUuid)
    if furnitureInfo == nil then
        return
    end

    local type = nil
    if furnitureInfo.fId == FurnitureType.Bed then
        type = CityResidentDefines.TalkTriggerType.EnterBed
    elseif furnitureInfo.fId == FurnitureType.Pool then
        type = CityResidentDefines.TalkTriggerType.EnterPool
    elseif furnitureInfo.fId == FurnitureType.Desk then
        type = CityResidentDefines.TalkTriggerType.EnterDesk
    elseif furnitureInfo.fId == FurnitureType.SawingTable then
        type = CityResidentDefines.TalkTriggerType.EnterSawingTable
    elseif furnitureInfo.fId == FurnitureType.DiningTable then
        type = CityResidentDefines.TalkTriggerType.EnterDiningTable
    elseif furnitureInfo.fId == FurnitureType.HuntingTool then
        type = CityResidentDefines.TalkTriggerType.EnterHuntingTool
    elseif furnitureInfo.fId == FurnitureType.ElectricGenerator then
        type = CityResidentDefines.TalkTriggerType.EnterElectricGenerator
    elseif furnitureInfo.fId == FurnitureType.ForgingTable then
        type = CityResidentDefines.TalkTriggerType.EnterForgingTable
    elseif furnitureInfo.fId == FurnitureType.BarSeat then
        type = CityResidentDefines.TalkTriggerType.EnterBarSeat
    elseif furnitureInfo.fId == FurnitureType.CookingBench then
        type = CityResidentDefines.TalkTriggerType.EnterCookingBench
    end

    if type then
        param.type = type
        param.furnitureId = furnitureInfo.fId
        param.level = furnitureInfo.lv
        self:TryResidentTalk(param)
    end
end

local function OnResidentExitFurniture(param)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    local furnitureInfo = DataCenter.FurnitureManager:GetFurnitureByUuid(param.fUuid)
    if furnitureInfo == nil then
        return
    end

    local type = nil
    if furnitureInfo.fId == FurnitureType.Bed then
        type = CityResidentDefines.TalkTriggerType.ExitBed
    end

    if type then
        param.type = type
        param.furnitureId = furnitureInfo.fId
        param.level = furnitureInfo.lv
        self:TryResidentTalk(param)
    end
end

local function OnSetResidentWork(uuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    local curSeg = DataCenter.VitaManager:GetCurSegment()
    if curSeg.type ~= VitaDefines.SegmentType.Work then
        return
    end
    
    local data = self:GetData(uuid)
    if data == nil or data.residentData:IsSick() or data.residentData:IsStrike() or data:IsDead() then
        return
    end
    
    local furnitureInfo = DataCenter.FurnitureManager:GetFurnitureByUuid(data.residentData.fUuid)
    if furnitureInfo == nil or data.atBUuid == furnitureInfo.bUuid then
        return
    end
    
    local wayPoint = WayPointUtil.GetOneWayPointByMask(furnitureInfo.bUuid, CityResidentDefines.WayPointFlag.Entrance)
    if wayPoint == nil then
        return
    end
    
    local x = Mathf.RandomFloat(-0.25, 0.25)
    local z = Mathf.RandomFloat(-0.25, 0.25)
    local pos = wayPoint.pos + Vector3.New(x, 0, z)
    data:SetPos(pos)
    data.atBUuid = furnitureInfo.bUuid
    data:Refresh()
    
    if DataCenter.VitaManager:IsLevelUpEnabled() then
        -- 小人说话
        local career = data:GetCareer()
        local param = {}
        param.type = CityResidentDefines.TalkTriggerType["SetCareer" .. career]
        param.rUuid = data.uuid
        param.duration = LuaEntry.DataConfig:TryGetNum("opinion_raise","k3")
        param.typeMaxCount = LuaEntry.DataConfig:TryGetNum("opinion_raise","k4")
        if param.type then
            self:TryResidentTalk(param)
        end
    end
end

local function OnSetResidentWorkBatch(uuids)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    if #uuids == 0 then
        return
    end
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local dayNight = DataCenter.VitaManager:GetDayNight(curTime)
    if dayNight == VitaDefines.DayNight.LateAtNight then
        return
    end
    local param = {}
    param.type = CityResidentDefines.TalkTriggerType.SetWorkBatch
    param.rUuid = table.randomArrayValue(uuids)
    param.duration = CityResidentDefines.ResidentTalkDuration * 1.5
    self:TryResidentTalk(param)
end

local function OnZombieAttackDead(uuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
end

local function OnMainLvUp()
    local self = DataCenter.CityResidentManager
    local k7Str = LuaEntry.DataConfig:TryGetStr("safety_area", "k7")
    for _, str in ipairs(string.split(k7Str, "|")) do
        local spls = string.split(str, ";")
        if #spls == 2 then
            if DataCenter.BuildManager.MainLv <= tonumber(spls[1]) then
                self.expandLevel = tonumber(spls[2])
                return
            end
        end
    end
    local mask = self:GetCurrentCityMask()
    self:ResetSafeWayPoints(mask)
end

local function OnResidentDie(self, uuid)
    local deadData = self:GetData(uuid)
    if deadData == nil then
        return
    end
    
    local info = {}
    info.uuid = uuid
    info.id = deadData.residentData.id
    info.pos = deadData:GetPos()
    info.rot = deadData:GetRot()
    self.deadInfoDict[uuid] = info
    
    for _, data in pairs(self.dataDict) do
        if data.uuid ~= uuid and data.type == CityResidentDefines.Type.Resident and not data.residentData:IsReady() and not data:IsDead() then
            local hudParam = {}
            hudParam.type = CityHudType.PopText
            hudParam.pos = data:GetPos()
            hudParam.icon = string.format(LoadPath.UIVita, "UItemperature_icon_mood03")
            hudParam.text = "<color=red>" .. CityResidentDefines.ResidentDieMood .. "</color>"
            hudParam.offset = Vector3.New(0, 50, 0)
            hudParam.duration = 1
            hudParam.location = CityHudLocation.World
            DataCenter.CityHudManager:Create(hudParam)
            data.residentData:ChangeMood(-10)
        end
    end
end

local function OnZombieRetreat(self)
    -- 小人说话
    for _, data in pairs(self.dataDict) do
        if data.type == CityResidentDefines.Type.Resident then
            local param = {}
            param.type = CityResidentDefines.TalkTriggerType.ZombieRetreat
            param.rUuid = data.uuid
            self:TryResidentTalk(param)
            break
        end
    end

    -- 小人死亡统计
    local deadIds = {}
    for _, info in pairs(self.deadInfoDict) do
        local data = self:GetData(info.uuid)
        if data then
            if data.residentData.deadReason == VitaDefines.ResidentDeadReason.Zombie then
                -- 真死，显示火把
                table.insert(deadIds, info.id)
            else
                -- 假死，站起来
                data:Revive()
            end
        end
    end
    if #deadIds > 0 then
        --UIManager:GetInstance():OpenWindow(UIWindowNames.UIVitaResidentDead, NormalPanelAnim, deadIds)
    end
end

local function OnResidentDeadReason(self, uuid)
    local curTime = UITimeManager:GetInstance():GetServerTime()
    local data = self:GetData(uuid)
    if data and data.residentData.deadReason == VitaDefines.ResidentDeadReason.Betray then
        local dict = {}
        for _, otherData in pairs(self.dataDict) do
            if otherData.uuid ~= uuid and otherData.type == CityResidentDefines.Type.Resident and
               otherData.residentData.deadReason == VitaDefines.ResidentDeadReason.Betray then
                dict[otherData.betrayIndex] = true
            end
        end
        for i = 1, DataCenter.VitaManager:GetResidentMaxCount() do
            if dict[i] == nil then
                data.betrayIndex = i
                break
            end
        end
        data:Refresh()
        self.betrayStartTime = curTime
        DataCenter.VitaManager:PushMatter(VitaDefines.Matter.ResidentBetray)
    end
end

local function OnResidentTaskFinish(uuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end
    
    local data = self:GetData(uuid)
    if data then
        data:Refresh()
        data:CheckShowDanger()

        -- 小人说话
        local param = {}
        param.type = CityResidentDefines.TalkTriggerType.StrikeEnd
        param.rUuid = data.uuid
        self:TryResidentTalk(param)
    end
end

local function OnCityWallBroken(wallId)
    --local self = DataCenter.CityResidentManager
    --if not self:IsEngaged() then
    --    return
    --end
    --
    --if not self:IsZombieInvade() then
    --    return
    --end
    --
    --local mask = DataCenter.CityResidentManager:GetCurrentCityMask()
    --local wayPoint = WayPointUtil.GetOneWayPointByMask(mask, CityResidentDefines.WayPointFlag.Invade, "wallId=" .. wallId)
    --if wayPoint then
    --    local spawnId = tonumber(WayPointUtil.GetWayPointArg(wayPoint, "spawnId"))
    --    for _, data in pairs(self.dataDict) do
    --        if data.type == CityResidentDefines.Type.Zombie and not data:IsDead() and data.spawnId == spawnId then
    --            data:SetState(CityResidentDefines.ZombieState.Invade)
    --        end
    --    end
    --end
end

local function OnResidentMoveComplete(uuid)
    local self = DataCenter.CityResidentManager
    if not self:IsEngaged() then
        return
    end

    local data = self:GetData(uuid)
    if data then
        data:OnMoveComplete()
    end
end

local function OnCityPathRecorded(self)
    local mask = self:GetCurrentCityMask()
    self:ResetSafeWayPoints(mask)
end

CityResidentManager.__init = __init
CityResidentManager.__delete = __delete
CityResidentManager.AddListeners = AddListeners
CityResidentManager.RemoveListeners = RemoveListeners

CityResidentManager.Init = Init
CityResidentManager.IsEngaged = IsEngaged
CityResidentManager.CanDoGuide = CanDoGuide
CityResidentManager.OnUpdate = OnUpdate
CityResidentManager.TimerAction = TimerAction
CityResidentManager.Save = Save
CityResidentManager.Load = Load
CityResidentManager.GetBank = GetBank
CityResidentManager.GetData = GetData
CityResidentManager.GetDataByIndex = GetDataByIndex
CityResidentManager.GetDataById = GetDataById
CityResidentManager.GetDataByCareer = GetDataByCareer
CityResidentManager.GetDataListByCareer = GetDataListByCareer
CityResidentManager.GetDataListByType = GetDataListByType
CityResidentManager.GetDataListByState = GetDataListByState
CityResidentManager.GetDataListInRange = GetDataListInRange
CityResidentManager.AddData = AddData
CityResidentManager.RemoveData = RemoveData
CityResidentManager.RemoveAllByType = RemoveAllByType
CityResidentManager.CreateObject = CreateObject
CityResidentManager.CreateAll = CreateAll
CityResidentManager.DestroyObject = DestroyObject
CityResidentManager.DestroyAll = DestroyAll
CityResidentManager.RefreshAll = RefreshAll
CityResidentManager.Refresh = Refresh
CityResidentManager.PauseAll = PauseAll
CityResidentManager.ResumeAll = ResumeAll
CityResidentManager.SetActiveAll = SetActiveAll
CityResidentManager.CheckZombieInvade = CheckZombieInvade
CityResidentManager.IsZombieInvade = IsZombieInvade
CityResidentManager.SpawnZombie = SpawnZombie
CityResidentManager.HeroSearchZombie = HeroSearchZombie
CityResidentManager.ZombieTryEscapeFromSafe = ZombieTryEscapeFromSafe
CityResidentManager.ZombieScareResident = ZombieScareResident
CityResidentManager.ZombieSearchResident = ZombieSearchResident
CityResidentManager.CheckNoBed = CheckNoBed
CityResidentManager.CheckReadyQueue = CheckReadyQueue
CityResidentManager.ThreatWhenCameraInFog = ThreatWhenCameraInFog
CityResidentManager.CheckLevelUp = CheckLevelUp
CityResidentManager.UpdateAreaMatrix = UpdateAreaMatrix
CityResidentManager.GetZombieCount = GetZombieCount
CityResidentManager.GetInvadeZombieCount = GetInvadeZombieCount
CityResidentManager.GetNextZombieUuid = GetNextZombieUuid
CityResidentManager.GetCanBeAttackZombie = GetCanBeAttackZombie
CityResidentManager.GetFireBody = GetFireBody
CityResidentManager.GetSelectedHeroUuids = GetSelectedHeroUuids
CityResidentManager.SetSelectedHeroUuids = SetSelectedHeroUuids
CityResidentManager.SetHeroOn = SetHeroOn
CityResidentManager.CheckHeroes = CheckHeroes
CityResidentManager.GetHeroSpawnPos = GetHeroSpawnPos
CityResidentManager.SetCanSpawnZombie = SetCanSpawnZombie
CityResidentManager.GetNoBedResidentUuids = GetNoBedResidentUuids
CityResidentManager.GetNoBedPos = GetNoBedPos
CityResidentManager.GetResidentPrefab = GetResidentPrefab
CityResidentManager.GetZombiePrefab = GetZombiePrefab
CityResidentManager.GetFurnitureInteractTransform = GetFurnitureInteractTransform
CityResidentManager.GetRandomSickBedByBUuid = GetRandomSickBedByBUuid
CityResidentManager.IsHeroUnlocked = IsHeroUnlocked
CityResidentManager.GetNextFoodWindowTransform = GetNextFoodWindowTransform
CityResidentManager.GetResidentTalkDialog = GetResidentTalkDialog
CityResidentManager.TryResidentTalk = TryResidentTalk
CityResidentManager.ResidentSpeak = ResidentSpeak
CityResidentManager.ResidentEmo = ResidentEmo
CityResidentManager.ScareResidentsAtPos = ScareResidentsAtPos
CityResidentManager.ScareResidentsByBUuid = ScareResidentsByBUuid
CityResidentManager.ResidentScare = ResidentScare
CityResidentManager.SetMoverUpdateInterval = SetMoverUpdateInterval
CityResidentManager.GetBetrayPos = GetBetrayPos
CityResidentManager.GetReadyQueuePos = GetReadyQueuePos
CityResidentManager.GetReadyQueueTime = GetReadyQueueTime
CityResidentManager.SetReadyQueueComeSwitch = SetReadyQueueComeSwitch
CityResidentManager.SetReadyQueueHudSwitch = SetReadyQueueHudSwitch
CityResidentManager.IsResidentQueueCome = IsResidentQueueCome
CityResidentManager.GetCurrentCityMask = GetCurrentCityMask
CityResidentManager.PlayResidentLevelUp = PlayResidentLevelUp
CityResidentManager.GetZombieChaseRange = GetZombieChaseRange
CityResidentManager.GetZombieAttackRange = GetZombieAttackRange
CityResidentManager.GetZombieAttackDamage = GetZombieAttackDamage
CityResidentManager.GetZombieWalkSpeed = GetZombieWalkSpeed
CityResidentManager.GetZombieChaseSpeed = GetZombieChaseSpeed
CityResidentManager.GetZombieRetreatSpeed = GetZombieRetreatSpeed
CityResidentManager.GetResidentScareRange = GetResidentScareRange
CityResidentManager.GetResidentWalkSpeed = GetResidentWalkSpeed
CityResidentManager.GetResidentRunSpeed = GetResidentRunSpeed
CityResidentManager.GetResidentInjuredStamina = GetResidentInjuredStamina
CityResidentManager.GetZombieMaxCount = GetZombieMaxCount
CityResidentManager.GetZombieInvadeMaxCount = GetZombieInvadeMaxCount
CityResidentManager.GetZombieInvadeTime = GetZombieInvadeTime
CityResidentManager.GetZombieMaxStamina = GetZombieMaxStamina
CityResidentManager.GetZombieRetreatLifetime = GetZombieRetreatLifetime
CityResidentManager.AddFireBody = AddFireBody
CityResidentManager.RemoveFireBody = RemoveFireBody
CityResidentManager.IsFireBody = IsFireBody
CityResidentManager.GetZombieSpawnPosDict = GetZombieSpawnPosDict
CityResidentManager.InitZombieSpawnPosDict = InitZombieSpawnPosDict
CityResidentManager.SetPeace = SetPeace
CityResidentManager.IsPeace = IsPeace
CityResidentManager.TryAutoReleaseBetrayResident = TryAutoReleaseBetrayResident
CityResidentManager.ReleaseBetrayResident = ReleaseBetrayResident
CityResidentManager.GetHeroSearchZombieRange = GetHeroSearchZombieRange
CityResidentManager.GetSafeRadius = GetSafeRadius
CityResidentManager.GetBrokenInvadeWayPoint = GetBrokenInvadeWayPoint
CityResidentManager.GetRandomInvadeWayPoint = GetRandomInvadeWayPoint
CityResidentManager.ResetSafeWayPoints = ResetSafeWayPoints
CityResidentManager.RefreshOverwork = RefreshOverwork
CityResidentManager.UseNewPathMethod = UseNewPathMethod
CityResidentManager.GetReviveCost = GetReviveCost
CityResidentManager.CanShowMainSafe = CanShowMainSafe
CityResidentManager.GetResidentWantMaxCount = GetResidentWantMaxCount
CityResidentManager.GetResidentWantDuration = GetResidentWantDuration
CityResidentManager.GetResidentDodgeRate = GetResidentDodgeRate

-- effect
CityResidentManager.ClearAllEffects = ClearAllEffects
CityResidentManager.ShowEffect = ShowEffect

CityResidentManager.OnDataChange = OnDataChange
CityResidentManager.OnSegmentChange = OnSegmentChange
CityResidentManager.OnDayNightChange = OnDayNightChange
CityResidentManager.OnZombieInvadeChange = OnZombieInvadeChange
CityResidentManager.OnReadyQueueTimeChange = OnReadyQueueTimeChange
CityResidentManager.OnShowFurniture = OnShowFurniture
CityResidentManager.OnHideFurniture = OnHideFurniture
CityResidentManager.OnEnterWorld = OnEnterWorld
CityResidentManager.OnEnterCity = OnEnterCity
CityResidentManager.OnPveLevelEnter = OnPveLevelEnter
CityResidentManager.OnPveLevelExit = OnPveLevelExit
CityResidentManager.OnBuildInView = OnBuildInView
CityResidentManager.OnBuildOutView = OnBuildOutView
CityResidentManager.OnFurnitureUpgrade = OnFurnitureUpgrade
CityResidentManager.OnResidentEnterBuilding = OnResidentEnterBuilding
CityResidentManager.OnResidentExitBuilding = OnResidentExitBuilding
CityResidentManager.OnResidentEnterFurniture = OnResidentEnterFurniture
CityResidentManager.OnResidentExitFurniture = OnResidentExitFurniture
CityResidentManager.OnSetResidentWork = OnSetResidentWork
CityResidentManager.OnSetResidentWorkBatch = OnSetResidentWorkBatch
CityResidentManager.OnZombieAttackDead = OnZombieAttackDead
CityResidentManager.OnMainLvUp = OnMainLvUp
CityResidentManager.OnResidentDie = OnResidentDie
CityResidentManager.OnZombieRetreat = OnZombieRetreat
CityResidentManager.OnResidentDeadReason = OnResidentDeadReason
CityResidentManager.OnResidentTaskFinish = OnResidentTaskFinish
CityResidentManager.OnCityWallBroken = OnCityWallBroken
CityResidentManager.OnResidentMoveComplete = OnResidentMoveComplete
CityResidentManager.OnCityPathRecorded = OnCityPathRecorded

return CityResidentManager
