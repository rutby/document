---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mac.
--- DateTime: 9/2/21 3:25 PM
---
--[[
    推送工具类,仅限于建筑等级，推送次数这种基础层的处理
]]
local rapidjson = require "rapidjson"

local PushUtil = BaseClass("PushUtil")

function PushUtil:__init()
    --[[
        一个pushId可能对应多个pushType
        对应的结构是 { pushId = {list}, ... }
    ]]
    self._pushInfoDic = {} 
end

function PushUtil:pushNotice( noticeInfo )
    -- 在每次触发推送的时候,先检测之前的是否需要移除,放在这个地方,看下后续推送的逻辑处理是否有问题,待定
    self:CanclePush(noticeInfo)
    if (noticeInfo:GetPushTime() <= 0) then
        return
    end
    local pushId = noticeInfo:GetPushId()
    local pushItem = LocalController:instance():getLine(TableName.APS_PUSH,pushId)
    -- 做一次和对应建筑等级的判定
    -- TODO
    -- 次数限制
    local push_times = pushItem:getValue("times")
    if (not string.IsNullOrEmpty(push_times)) then
        push_times = tonumber(push_times)
        if push_times>1 then --函数开始时已经取消了前一个推送，push_times ==1 的推送当前值一定小于0，不需要再进行检测
            local curTime = CS.PushNoticeManager.GetPushCountById(pushId)
            if (curTime >= push_times) then
                return
            end
        end
        
    end
    -- 周期内只能推一次
    local intervalTime = 0
    local type_value = pushItem:getValue("type_value")
    if (not string.IsNullOrEmpty(type_value)) then
        intervalTime = tonumber(type_value) * 60
    end
    self:PushNoticeToList(noticeInfo, intervalTime)
end

function PushUtil:PushNoticeToList(noticeInfo, intervalTime)
    local pushId = noticeInfo:GetPushId()
    if (self._pushInfoDic[pushId] == nil) then
        self._pushInfoDic[pushId] = {}
    end
    local notice_list = self._pushInfoDic[pushId]
    local notice_cnt = table.count(notice_list)
    local isNeedAdd = false
    if (intervalTime > 0 and notice_cnt > 0) then

        -- 在排序完成之后遍历当前队列,看根据现在的时间能否还插入进去
        for index = 1, notice_cnt do
            if (index == 1 and (notice_list[index]:GetPushTime() - noticeInfo:GetPushTime() > intervalTime)) then
                notice_list[#notice_list+1] = noticeInfo
                isNeedAdd = true
                break
            elseif (index == notice_cnt and (noticeInfo:GetPushTime() - notice_list[index]:GetPushTime() > intervalTime) ) then
                notice_list[#notice_list+1] = noticeInfo
                isNeedAdd = true
                break
            elseif ( (noticeInfo:GetPushTime() - notice_list[index]:GetPushTime() > intervalTime) and
                    (notice_list[index+1]:GetPushTime() - noticeInfo:GetPushTime() > intervalTime) ) then
                isNeedAdd = true
                notice_list[#notice_list+1] = noticeInfo
                break
            end
        end

        -- 然后按照时间排序,这样下次可以直接进行上面的处理
        if (isNeedAdd) then
            table.sort(notice_list, function (param1, param2)
                if (param1:GetPushTime() > param2:GetPushTime()) then
                    return 1
                elseif param1:GetPushTime() == param2:GetPushTime() then
                    return 0
                elseif param1:GetPushTime() == param2:GetPushTime() then
                    return -1
                end
            end)
        end
    else
        isNeedAdd = true
        notice_list[#notice_list+1] = noticeInfo
    end
    if (isNeedAdd) then
        local param = {}
        param["type"] = noticeInfo:GetPushType()
        param["time"] = noticeInfo:GetPushTime()
        param["body"] = noticeInfo:GetPushBody()
        param["soundKey"] = ""
        param["pushType"] = noticeInfo:GetPushType()
        param["playerMark"] = 1
        param["gameUid"] = LuaEntry.Player.uid
        param["pushId"] = noticeInfo:GetPushId()
        local strJson = rapidjson.encode(param)
        local ok, errorMsg = xpcall(function()
            CS.PushNoticeManager.PushNotice(strJson)
        end, debug.traceback)
        if not ok then
            local now = UITimeManager:GetInstance():GetServerSeconds()
            CommonUtil.SendErrorMessageToServer(now, now, errorMsg)
            Logger.LogError(errorMsg)
        end
        
    end
    
end

function PushUtil:CanclePush( noticeInfo )
    local pushId = noticeInfo:GetPushId()
    if (self._pushInfoDic[pushId] == nil) then
        return
    end
    local param = {}
    param["type"] = noticeInfo:GetPushType()
    CS.PushNoticeManager.CancelNotice(param)
    local notice_list = self._pushInfoDic[pushId]
    for index, noticeItem in pairs(notice_list) do
        if(noticeItem:GetPushType() == noticeInfo:GetPushType()) then
            notice_list[index] = nil
        end
    end
    if (table.count(notice_list) == 0) then
        self._pushInfoDic[pushId] = nil
    end
end



return PushUtil