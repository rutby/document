---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/9/13 19:30
---战报数据
local PveReportMgr = BaseClass("PveReportMgr")
local PveRoundReportItem = require("Scene.BattlePveModule.PveReportModule.PveReportItem")
local PveReportCampData = require("Scene.BattlePveModule.PveReportModule.PveReportCampData")
local Const= require "Scene.BattlePveModule.Const"

function PveReportMgr:__init()
    self.m_selfCamp = PveReportCampData.New()
    self.m_enemyCamp = PveReportCampData.New()
    self.m_startRoundIndex = IntMaxValue
    self.m_endRoundIndex = 0
    self.m_currentIndex = 0
    self.m_selfIndex = 0

    self.m_time = 0
    self.m_isStart = false
end

--暂时先处理普通攻击，后续再支持技能和buff
function PveReportMgr:ParseData(data,selfHealth,enemyHealth,needExchange)
    self:InitPlayerInfo(data["playerInfos"],needExchange)

    local roundReports = data["roundReports"] or {}
    local effectReports = data["effectReports"] or {}

    for i, v in ipairs(roundReports) do
        self:AddItem(v)
    end

    for i, v in ipairs(effectReports) do
        self:AddItem(v["baseReport"],v["time"])
    end

    self.m_selfCamp:InitData(self.m_startRoundIndex,self.m_endRoundIndex,selfHealth)
    self.m_enemyCamp:InitData(self.m_startRoundIndex,self.m_endRoundIndex,enemyHealth)

    self.m_selfCamp:CalculateNormalDamage()
    self.m_enemyCamp:CalculateNormalDamage()
end

function PveReportMgr:InitPlayerInfo(info,needExchange)
    local isSelfFlag = true
    if needExchange then
        isSelfFlag = false
    end
    for _, userinfo in pairs(info) do
        if userinfo["isSelf"] == isSelfFlag then
            self.m_selfIndex = userinfo["index"]
            break
        end
    end
end

function PveReportMgr:AddItem(itemData,buffTime)
    local item = PveRoundReportItem.New(itemData,buffTime)
    if item:GetTriggerIndex() == self.m_selfIndex then
        self.m_selfCamp:AddRoundItem(item)
    else
        self.m_enemyCamp:AddRoundItem(item)
    end

    local roundIndex = item:GetRoundIndex()
    self.m_startRoundIndex = self.m_startRoundIndex > roundIndex and roundIndex or self.m_startRoundIndex
    self.m_endRoundIndex = self.m_endRoundIndex < roundIndex and roundIndex or self.m_endRoundIndex
end


function PveReportMgr:OnUpdate(deltaTime)
    if not self.m_isStart then
        return
    end

    self.m_time = self.m_time + deltaTime

    local round = toInt(self.m_time)

    if round > self.m_currentIndex then
        self:PlayRound() --进入到了下一个回合
    end
end

function PveReportMgr:StartRound()
    self.m_isStart = true
    self.m_time = self.m_startRoundIndex
    self.m_currentIndex = self.m_startRoundIndex

    self.m_selfCamp:PlayRound(self.m_currentIndex)
    self.m_enemyCamp:PlayRound(self.m_currentIndex)
end

function PveReportMgr:StopRound()
    self.m_isStart = false
end

function PveReportMgr:PlayRound()
    if self.m_currentIndex >= self.m_endRoundIndex then
        return
    end

    self.m_currentIndex = self.m_currentIndex + 1

    self.m_selfCamp:PlayRound(self.m_currentIndex)
    self.m_enemyCamp:PlayRound(self.m_currentIndex)

    self:SetBuffStateForUI()
end
--触发BUFF
function PveReportMgr:SetBuffStateForUI()
    local leftActiveBuffs,leftBuffs = self.m_selfCamp:GetActiveBuffs()
    local rightActiveBuffs,rightBuffs = self.m_enemyCamp:GetActiveBuffs()

    for _, buffStr in ipairs(leftActiveBuffs) do
        EventManager:GetInstance():Broadcast(EventId.PVEBattleShowLeftBuff,buffStr)
    end
    for _, buffStr in ipairs(rightActiveBuffs) do
        EventManager:GetInstance():Broadcast(EventId.PVEBattleShowRightBuff,buffStr)
    end

    EventManager:GetInstance():Broadcast(EventId.PVEBattleSetLeftBuffData,leftBuffs)
    EventManager:GetInstance():Broadcast(EventId.PVEBattleSetRightBuffData,rightBuffs)
end

--分配伤害，同时会从伤害池中扣除
function PveReportMgr:AssignNormalDamage(heroInfo,enemyHealth,isSelf)
    local campData
    if isSelf then
        campData = self.m_selfCamp
    else
        campData = self.m_enemyCamp
    end

    local lastAttackTime = heroInfo:GetLastAttackTime()
    local attackTime = self.m_time - lastAttackTime
    --上次攻击回合
    local startRoundIndex = Mathf.Clamp(Mathf.Floor(lastAttackTime),self.m_startRoundIndex,self.m_endRoundIndex)

    local roundAttackTime               --本次攻击在每回合占用的时间
    local leftAttackTime = attackTime   --剩余攻击时间，需要把攻击时间在每回合中分配
    local totalDamage = 0               --总伤害
    for i = startRoundIndex, self.m_currentIndex do
        if lastAttackTime + leftAttackTime > (i + 1) and lastAttackTime < (i + 1)then --一个回合时间是1秒，i + 1 就是下个回合时间，用于判断攻击时间是否跨回合
            roundAttackTime = Mathf.Max((i + 1) - lastAttackTime,0)

            leftAttackTime = leftAttackTime - roundAttackTime

            lastAttackTime = lastAttackTime + roundAttackTime     --更新上次攻击时间
        else
            roundAttackTime = leftAttackTime
        end
        local roundAttackRatio = heroInfo:GetPowerRatio() * attackTime * (roundAttackTime / attackTime)
        local damage = roundAttackRatio * campData:GetNormalDamageByRound(i)

        totalDamage = totalDamage + damage
    end

    totalDamage = Mathf.Ceil(totalDamage)

    local wholeDamage = totalDamage
    if totalDamage > enemyHealth then
        --总伤害已经超出了敌人血量，多余的伤害就先不扣除
        totalDamage = enemyHealth
    end

    return campData:AssignNormalDamage(totalDamage), totalDamage, wholeDamage
end
--添加技能没有打出去的伤害
function PveReportMgr:AddSkillDamage(isPlayer,skillDamage)
    if isPlayer then
        self.m_selfCamp:AddSkillDamage(skillDamage)
    else
        self.m_enemyCamp:AddSkillDamage(skillDamage)
    end
end

function PveReportMgr:GetCampHealth(campType)
    if campType == Const.CampType.Player then
        return self.m_selfCamp:GetMaxHealth()
    else
        return self.m_enemyCamp:GetMaxHealth()
    end
end

function PveReportMgr:CheckEnd()
    return self.m_currentIndex >= self.m_endRoundIndex
end
--是否没有伤害了
function PveReportMgr:IsDamageEmpty()
    return self.m_selfCamp:IsDamageEmpty() and self.m_enemyCamp:IsDamageEmpty()
end

function PveReportMgr:GetCurrentIndex()
    return self.m_currentIndex
end

function PveReportMgr:GetMinIndex()
    return self.m_startRoundIndex
end

function PveReportMgr:GetMaxIndex()
    return self.m_endRoundIndex
end

function PveReportMgr:GetTime()
    return self.m_time
end

function PveReportMgr:IsSelfIndex(index)
    return index == self.m_selfIndex
end

function PveReportMgr:ClearData()
    self.m_enemyCamp:ClearData()
    self.m_selfCamp:ClearData()
    self.m_startRoundIndex = IntMaxValue
    self.m_endRoundIndex = 0
    self.m_currentIndex = 0
    self.m_selfIndex = 0

    self.m_time = 0
    self.m_isStart = false
end

return PveReportMgr