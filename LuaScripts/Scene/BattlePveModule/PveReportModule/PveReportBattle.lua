---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/9/20 18:44
---战斗规则相关逻辑
local PveReportBattle = BaseClass("PveReportBattle")
local PveReportHeroInfo = require("Scene.BattlePveModule.PveReportModule.PveReportHeroInfo")
local PveReportHeroObject = require("Scene.BattlePveModule.PveReportModule.PveReportHeroObject")
local Const= require "Scene.BattlePveModule.Const"

function PveReportBattle:__init(reportMgr)
    self.m_reportMgr = reportMgr

    self.m_playerHeroList = {}
    self.m_playerHeroes = {}
    self.m_targetHeroes = {}
    self.__event_handlers = {}
    self.m_isStart = false
end

function PveReportBattle:OnUpdate(deltaTime)
    for _, hero in pairs(self.m_playerHeroes) do
        hero:TopFaceToCamera()
        if self.m_isStart then
            hero:OnUpdate(deltaTime)
        end
    end
    for _, hero in pairs(self.m_targetHeroes) do
        hero:TopFaceToCamera()
        if self.m_isStart then
            hero:OnUpdate(deltaTime)
        end
    end
end

--开始战斗
function PveReportBattle:Start()
    function startHeroes(heroes)
        for _, hero in pairs(heroes) do
            hero:HideLevel()
            hero:Start()
            hero.info:SetAttackTime(self.m_reportMgr:GetMinIndex())
        end
        self:CalculatePowerRatio(heroes,true)
    end
    startHeroes(self.m_playerHeroes)
    startHeroes(self.m_targetHeroes)
    self:InitHeroHealth()

    self.totalDamages = {}
    self:AddEventListeners()

    self.m_isStart = true
end
--停止战斗
function PveReportBattle:Stop()
    self.m_isStart = false
end

function PveReportBattle:AddEventListeners()
    self:AddListener(EventId.SU_PveReportDoSkill,self.CheckPlaySkill)
end

function PveReportBattle:RemoveEventListeners()
    self:RemoveListener(EventId.SU_PveReportDoSkill,self.CheckPlaySkill)
end

function PveReportBattle:AddHero(modelType , standIndex, heroId, power,heroLv,quality,rarity,targetLv,heroUuid,rankId,heroUuidList)
    local heroInfo = PveReportHeroInfo.New(modelType,standIndex,heroId, power,heroUuid)
    local hero = PveReportHeroObject.New(DataCenter.BattleLevel,-1,heroInfo,self)
    local levelBarScale = 1
    local isSelf = true
    if modelType == Const.CampType.Player then
        table.insert(self.m_playerHeroList,hero)
        if heroUuidList ~= nil then
            self:SortPlayerHeroes(heroUuidList)
        else
            self.m_playerHeroes[standIndex] = hero
        end
        levelBarScale = 1.2
        isSelf = true
    else
        self.m_targetHeroes[standIndex] = hero
        levelBarScale = 1.8
        isSelf = false
    end
    local camp = GetTableData(HeroUtils.GetHeroXmlName(), heroId, "camp")
    hero:Create(function()
        hero:ShowLevel(isSelf, camp, heroLv, levelBarScale)
        PveActorMgr:GetInstance():CheckPlayRound()
    end)
end

function PveReportBattle:RemoveHero(modelType,index,heroUuidList)
    local heroes = modelType == Const.CampType.Player and self.m_playerHeroes or self.m_targetHeroes
    local modelObj = heroes[index]
    if (modelObj ~= nil) then
        local i = table.indexof(self.m_playerHeroList, modelObj)
        if i then
            table.remove(self.m_playerHeroList, i)
        end
        modelObj:Destroy()
    end
    heroes[index] = nil
    if modelType == Const.CampType.Player then
        self:SortPlayerHeroes(heroUuidList)
    end
end

function PveReportBattle:SortPlayerHeroes(heroUuidList)
    if heroUuidList ~= nil then
        local newList = {}
        for i, heroUuid in pairs(heroUuidList) do
            for _, hero in pairs(self.m_playerHeroList) do
                if hero:GetHeroUuid() == heroUuid then
                    hero:UpdatePos(i)
                    newList[i] = hero
                end
            end
        end
        self.m_playerHeroes = newList
    end
end

--计算英雄战力比，可以在有英雄死亡的时候重新计算,确保分配伤害正确
function PveReportBattle:CalculatePowerRatio(heroes,isInit)
    local totalPower = 0
    for _, hero in pairs(heroes) do
        if isInit or not hero:IsDead() then
            totalPower = totalPower + hero:GetPower()
        end
    end
    for _, hero in pairs(heroes) do
        if isInit or not hero:IsDead() then
            hero:SetPowerRatio(hero:GetPower() / totalPower)
        end
    end
end
--初始化英雄血量
function PveReportBattle:InitHeroHealth()
    self:AssignHeroHealth(Const.CampType.Player)
    self:AssignHeroHealth(Const.CampType.Target)
end

--分配血量
function PveReportBattle:AssignHeroHealth(campType)
    local totalHealth = self.m_reportMgr:GetCampHealth(campType)
    local heroes
    if campType == Const.CampType.Player then
        heroes = self.m_playerHeroes
    else
        heroes = self.m_targetHeroes
    end

    local heroCount = table.count(heroes)
    local index = 1
    local tempHealth = 0
    local health
    for _, hero in pairs(heroes) do
        if index == heroCount then
            health = totalHealth - tempHealth
        else
            health = Mathf.Floor(hero:GetPowerRatio() * totalHealth)
            tempHealth = tempHealth + health
        end
        hero:InitHealth(health)
        index = index + 1
    end
end

--获取攻击目标
--优先返回对应号位的敌人
--如果对应号位的敌人死亡，则找临近号位，先小后大
function PveReportBattle:SearchAttackTarget(campType,standIndex)
    local heroes = campType == Const.CampType.Player and self.m_targetHeroes or self.m_playerHeroes
    local target = heroes[standIndex]
    if target == nil or target:IsDead() then
        --这个位置没人或者已经死了
        --local heroCount = table.count(heroes)
        for i = 1, 5 do
            target = heroes[standIndex - i]
            if target ~= nil and not target:IsDead() then
                break
            end
            target = heroes[standIndex + i]
            if target ~= nil and not target:IsDead() then
                break
            end
        end
    end
    return target
end
--根据距离获取攻击目标
function PveReportBattle:SearchAttackTargetByRange(campType,pos,range,modelRadius)
    local heroes = campType == Const.CampType.Player and self.m_targetHeroes or self.m_playerHeroes
    local target = nil
    local minDist = IntMaxValue
    modelRadius = modelRadius or 0
    for _, hero in pairs(heroes) do
        if not hero:IsDead() then
            local enemyPos = hero:GetPosition()
            local dist = Vector3.Distance2D_XZ(enemyPos, pos) - hero:GetModelRadius() - modelRadius
            if dist < minDist and dist < range then
                minDist = dist
                target = hero
            end
        end
    end
    return target
end

--攻击敌人
function PveReportBattle:AttackEnemy(attackHero,targetHero)
    local attackInfo = attackHero.info
    local targetInfo = targetHero.info
    --realDamage真实伤害，totalDamage应该打出来的伤害，wholeDamage可溢出的原始伤害
    local realDamage, totalDamage, wholeDamage = self.m_reportMgr:AssignNormalDamage(attackInfo,targetInfo:GetHealth(),attackInfo:GetCampType() == Const.CampType.Player)
    local targetHealth = targetInfo:GetHealth()
    targetInfo:SetHealth(targetInfo:GetHealth() - realDamage)


    attackInfo:SetAttackTime(self.m_reportMgr:GetTime()) --更新攻击时间

    targetHero:BeAttack(realDamage)

    if self.totalDamages[attackInfo:GetCampType()] == nil then
        self.totalDamages[attackInfo:GetCampType()] = 0
    end

    local campTotalDamage = self.totalDamages[attackInfo:GetCampType()] + realDamage
    self.totalDamages[attackInfo:GetCampType()] = campTotalDamage


    --Logger.LogError(string.format("RoundIndex = %s,attackCamp = %s, attackIndex = %s, realDamage = %s, campTotalDamage = %s, targetHealth_old = %s, targetHealth_new = %s,time = %s",
    --        self.m_reportMgr:GetCurrentIndex(),attackInfo:GetCampType(),attackInfo:GetStandIndex(),realDamage,campTotalDamage,targetHealth,targetInfo:GetHealth(),self.m_reportMgr:GetTime()))

    --飘伤害
    if DataCenter.BattleLevel.showHp then
        -- 先不显示敌人的伤害
        if attackHero.info:GetCampType() == Const.CampType.Player then
            local size = 3
            local color = attackHero.info:GetCampType() == Const.CampType.Player and "white" or "red"
            local val = - toInt(wholeDamage)
            local str = string.format("<size=%s><color=%s>%s</color></size>", size, color, val)
            DataCenter.BattleLevel:FlyText(str, targetHero:GetPosition())
        end
    end

    self:CheckTargetDead(targetHero,realDamage)
end

function PveReportBattle:CheckPlaySkill(skill)
    if skill == nil then
        return
    end

    --Logger.LogError("Do Skill: "..skill:GetSkillId()..", heroId:"..skill:GetHeroId()..", triggerId:"..skill:GetTriggerIndex())

    local heroes
    if self.m_reportMgr:IsSelfIndex(skill:GetTriggerIndex()) then
        heroes = self.m_playerHeroes
    else
        heroes = self.m_targetHeroes
    end

    local heroId = skill:GetHeroId()
    local targetHero
    for standIndex, hero in pairs(heroes) do
        if hero:GetHeroId() == heroId then
            targetHero = hero
            break
        end
    end

    if targetHero ~= nil then
        if targetHero:IsDead() then
            --施法者已经死了
            self:DoDeadSkill(skill)
        else
            --没死，触发技能
            targetHero:ReportSkill(skill)
        end
    end
end

function PveReportBattle:CalculateSkill(skill)
    local skillTargets = skill:GetSkillTarget()
    local skillType
    local damage
    local buffs
    local targetIndex
    local targetIndexMap = {}
    local targetData
    for i, skillTarget in ipairs(skillTargets) do
        skillType = skillTarget:GetType()
        targetIndex = skillTarget:GetTargetIndex()

        targetData = targetIndexMap[targetIndex]
        if targetData == nil then
            targetData = {}
            targetIndexMap[targetIndex] = targetData
        end
        if skillType == eMailDetailActionType.ATTACK then
            --伤害
            damage = targetData.damage
            if damage == nil then
            damage = 0
            end
            damage = damage + skillTarget:GetDamage()

            targetData.damage = damage
        elseif skillType == eMailDetailActionType.RECOVER_DAMAGE then
            --加血
            damage = targetData.recoverDamage
            if damage == nil then
                damage = 0
            end
            damage = damage + skillTarget:GetDamage()

            targetData.recoverDamage = damage
        else
            --BUFF
            buffs = targetData.buffs
            if buffs == nil then
                buffs = {}
                targetData.buffs = buffs
            end
            table.insert(buffs,skillTarget)
        end
    end

    return targetIndexMap
end

function PveReportBattle:SkillAttackEnemy(skill,enemy)
    --Logger.LogError("SkillAttackEnemy : "..skill:GetSkillId()..", heroId:"..skill:GetHeroId()..", triggerId:"..skill:GetTriggerIndex())
    local targetIndexMap = self:CalculateSkill(skill)

    for index, data in pairs(targetIndexMap) do
        self:DoSkill(index,data.damage,data.recoverDamage,data.buffs,enemy)
    end
end

function PveReportBattle:DoSkill(targetIndex,skillDamage,skillRecoverDamage,buffs,enemy)
    --Logger.LogError("DoSkill")
    skillDamage = skillDamage or 0
    skillRecoverDamage = skillRecoverDamage or 0

    local heroes
    local isPlayer = self.m_reportMgr:IsSelfIndex(targetIndex)
    if isPlayer then
        heroes = self.m_playerHeroes
    else
        heroes = self.m_targetHeroes
    end

    local heroCount = 0
    local heroList = {}
    for standIndex, hero in pairs(heroes) do
        if not hero:IsDead() then
            heroCount = heroCount + 1
            table.insert(heroList,hero)
        end
    end

    local totalRecoverDamage = skillRecoverDamage
    local damage
    local ratio = 1 / heroCount
    local hero
    local realDamage = 0

    if skillDamage > 0 then
        if enemy ~= nil then
            realDamage = Mathf.Min(skillDamage,enemy.info:GetHealth())

            enemy.info:SetHealth(enemy.info:GetHealth() - realDamage)

            enemy:BeAttack(realDamage)

            --飘伤害
            if DataCenter.BattleLevel.showHp then
                -- 先不显示敌人的伤害
                if enemy.info:GetCampType() == Const.CampType.Target then
                    local size = 8
                    local color = enemy.info:GetCampType() == Const.CampType.Target and "yellow" or "red"
                    local val = - toInt(skillDamage)
                    local str = string.format("<size=%s><color=%s>%s</color></size>", size, color, val)
                    DataCenter.BattleLevel:FlyText(str, enemy:GetPosition())
                end
            end

            if realDamage > 0 then
                self:CheckTargetDead(enemy,realDamage)
            end
        end

        self.m_reportMgr:AddSkillDamage(not isPlayer, skillDamage - realDamage) --把没有打出去的技能伤害补到普攻伤害里
    end

    for i = 1, heroCount do
        hero = heroList[i]

        if skillRecoverDamage > 0 then
            if i < heroCount then
                damage = Mathf.Floor(skillRecoverDamage * ratio)
            else
                damage = totalRecoverDamage
            end

            local currentHealth = hero.info:GetCurBlood()
            local maxHealth = hero.info:GetMaxBlood()
            if currentHealth + damage > maxHealth then
                --加的血超过了最大血量，所以提高最大血量，保证加的血都加上来
                maxHealth = currentHealth + damage
                hero.info:SetMaxHealth(maxHealth)
            end

            hero.info:SetHealth(currentHealth + damage)

            hero:BeAttack(damage)

            hero:PlayAddHpVFX()

            --飘加血
            if DataCenter.BattleLevel.showHp then
                -- 先不显示敌人的加血
                if hero.info:GetCampType() == Const.CampType.Player then
                    local size = 5
                    local color = "green"
                    local val = toInt(damage)
                    local str = string.format("<size=%s><color=%s>%s</color></size>", size, color, val)
                    DataCenter.BattleLevel:FlyText(str, hero:GetPosition())
                end
            end
            
            totalRecoverDamage = totalRecoverDamage - damage
        end

        if buffs ~= nil then
            hero:AddBuff(buffs)
        end
    end
end
--执行死亡者的技能
function PveReportBattle:DoDeadSkill(skill)
    local targetIndexMap = self:CalculateSkill(skill)
    local skillDamage
    local skillRecoverDamage
    local isPlayer
    for targetIndex, data in pairs(targetIndexMap) do
        skillDamage = data.damage or 0
        skillRecoverDamage = data.recoverDamage or 0

        isPlayer = self.m_reportMgr:IsSelfIndex(targetIndex)
        if skillDamage > 0 then
            self.m_reportMgr:AddSkillDamage(not isPlayer, skillDamage) --伤害补充到普通伤害里
        end
        if skillRecoverDamage > 0 then
            local totalRecoverDamage = skillRecoverDamage
            local heroes
            if isPlayer then
                heroes = self.m_playerHeroes
            else
                heroes = self.m_targetHeroes
            end
            local heroCount = 0
            local heroList = {}
            for standIndex, hero in pairs(heroes) do
                if not hero:IsDead() then
                    heroCount = heroCount + 1
                    table.insert(heroList,hero)
                end
            end
            local hero
            local damage
            local ratio = 1 / heroCount
            for i = 1, heroCount do
                hero = heroList[i]

                if i < heroCount then
                    damage = Mathf.Floor(skillRecoverDamage * ratio)
                else
                    damage = totalRecoverDamage
                end

                local currentHealth = hero.info:GetCurBlood()
                local maxHealth = hero.info:GetMaxBlood()
                hero.info:SetMaxHealth(maxHealth + damage)
                hero.info:SetHealth(currentHealth + damage)

                hero:UpdateHPBar(damage)

                totalRecoverDamage = totalRecoverDamage - damage
            end
        end
    end
end

function PveReportBattle:CheckTargetDead(targetHero,damage)
    if targetHero:IsDead() then
        targetHero:Die()

        --重新刷伤害
        if targetHero.info:GetCampType() == Const.CampType.Player then
            self:CalculatePowerRatio(self.m_playerHeroes,false)
        else
            self:CalculatePowerRatio(self.m_targetHeroes,false)
        end

        PveActorMgr:GetInstance():CheckEnd()
    elseif damage == 0 then
        --对方没死，也没打出来伤害，进入容错检测
        if self.m_reportMgr:IsDamageEmpty() then
            --伤害都打完了
            --Logger.LogError("没有伤害了，进行容错战斗结束！")
            PveActorMgr:GetInstance():ShowResult()
        end
    end
end

--检测是否结束
function PveReportBattle:CheckEnd()
    function IsAllDead(heroes)
        local allDead = true
        for _, hero in pairs(heroes) do
            if not hero:IsDead() then
                allDead = false
                break
            end
        end
        return allDead
    end
    return IsAllDead(self.m_targetHeroes) or IsAllDead(self.m_playerHeroes)
end

function PveReportBattle:GetModelListByCamp(campType)
    if campType == Const.CampType.Player then
        return self.m_playerHeroes
    else
        return self.m_targetHeroes
    end
end

function PveReportBattle:GetCreateModelOK()
    local createOk = false
    local playerHeroCount = table.count(self.m_playerHeroes)
    local targetHeroCount = table.count(self.m_targetHeroes)
    if playerHeroCount > 0 and targetHeroCount > 0 then
        for _, hero in pairs(self.m_playerHeroes) do
            if not hero:IsCreateFinish() then
                return false
            end
        end
        for _, hero in pairs(self.m_targetHeroes) do
            if not hero:IsCreateFinish() then
                return false
            end
        end
        createOk = true
    end
    return createOk
end

function PveReportBattle:AddListener(msg_name, callback)
    local bindFunc = function(...) callback(self, ...) end
    self.__event_handlers[msg_name] = bindFunc
    EventManager:GetInstance():AddListener(msg_name, bindFunc)
end

function PveReportBattle:RemoveListener(msg_name, callback)
    local bindFunc = self.__event_handlers[msg_name]
    if not bindFunc then
        --Logger.LogError(msg_name, " not register")
        return
    end
    self.__event_handlers[msg_name] = nil
    EventManager:GetInstance():RemoveListener(msg_name, bindFunc)
end

function PveReportBattle:DestroyHeroes(heroes)
    for _, hero in pairs(heroes) do
        hero:Destroy()
    end
end

function PveReportBattle:Destroy()
    self.m_isStart = false
    self:RemoveEventListeners()
    self:DestroyHeroes(self.m_playerHeroes)
    self:DestroyHeroes(self.m_targetHeroes)
    self.m_playerHeroList = {}
    self.m_playerHeroes = {}
    self.m_targetHeroes = {}
end

function PveReportBattle:IsStart()
    return self.m_isStart
end

function PveReportBattle:GetAllHeroObjects()
    local objs = {}
    for _, hero in pairs(self.m_playerHeroes) do
        table.insert(objs, hero)
    end
    for _, hero in pairs(self.m_targetHeroes) do
        table.insert(objs, hero)
    end
    return objs
end

return PveReportBattle