---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/9/18 18:40
---整个回合的战报数据集合
local PveReportRound = BaseClass("PveReportRound")

function PveReportRound:__init()
    self.m_normals = {}
    self.m_skills = {}
    self.m_buffs = {} --只是用于UI界面显示，真正执行会合并到skill里
    self.m_maxHealth = 0
    self.m_lastHealth = 0
    self.m_damage = 0
    self.m_totalDamage = 0 --本回合最大普通伤害
end

function PveReportRound:AddItem(item)
    if item:IsSubActionItem() and self:CheckAddSubSkill(item) then
    elseif item:GetType() == eMailDetailActionType.USE_SKILL then
        table.insert(self.m_skills,item)
    elseif item:IsBuff() then
        --加buff
        if item:GetType() == eMailDetailActionType.ADD_EFFECT then
            --护盾，增加怒气，不算BUFF，不会显示在UI上
            table.insert(self.m_buffs,item)
        end
        if not self:CheckAddBuff(item) then
            table.insert(self.m_skills,item)
        end
    else
        table.insert(self.m_normals,item)
    end
end
--计算普通伤害
function PveReportRound:CalculateNormalDamage()
    local damage = 0

    for _, item in ipairs(self.m_normals) do
        damage = damage + item:GetDamage()
    end

    self.m_totalDamage = damage
    self.m_damage = damage
end
--分配普通伤害
--返回 伤害，差了多少伤害，需要总池子补足伤害
function PveReportRound:AssignNormalDamage(assignDamage,limitDamage)
    local damage = 0
    local differenceDamage = 0 --没有分配全，差了多少伤害

    if limitDamage ~= nil and limitDamage > 0 then
        if assignDamage > limitDamage then
            assignDamage = limitDamage
        else
            differenceDamage = limitDamage - assignDamage
        end
    end

    if assignDamage <= self.m_damage then
        damage = assignDamage

        self.m_damage = self.m_damage - damage --扣除分配出去的伤害
    else
        damage = self.m_damage --所有伤害都分配出去

        differenceDamage = assignDamage - damage + differenceDamage

        self.m_damage = 0
    end

    return damage,differenceDamage
end

function PveReportRound:GetTotalDamage()
    return self.m_totalDamage
end

function PveReportRound:CheckAddSubSkill(item)
    local tbCnt = table.count(self.m_skills)
    if (tbCnt == 0) then
        return false
    end
    for i = tbCnt, 1, -1 do
        local _action = self.m_skills[i]
        if (_action:IsBelongThisSkill(item)) then
            _action:AddSkillTarget(item)
            return true
        end
    end
    return false
end

function PveReportRound:CheckAddBuff(item)
    local tbCnt = table.count(self.m_skills)
    if (tbCnt == 0) then
        return false
    end
    for i = tbCnt, 1, -1 do
        local skill_item = self.m_skills[i]
        if ( (skill_item:IsSubSkill(item:GetSkillId()) or skill_item:GetSkillId() == item:GetSkillId()) and
                skill_item:GetTriggerIndex() == item:GetTriggerIndex() and
                skill_item:GetHeroId() == item:GetHeroId() ) then
            skill_item:AddSkillTarget(item)
            return true
        end
    end
    return false
end

function PveReportRound:GetActiveBuffs(currentRound)
    local currentActiveBuffs = {}
    local buffs = {}
    local status
    local buffLevel
    for _, buff in ipairs(self.m_buffs) do
        status = buff:GetDamage() or 0
        if status ~= 0 then
            if buff:GetRoundIndex() == currentRound then
                buffLevel = buff:GetSkillLevel() or 1
                table.insert(currentActiveBuffs,tostring(status).."|"..tostring(buffLevel))
            end
            if buff:GetRoundIndex() <= currentRound and currentRound - buff:GetRoundIndex() <= buff:GetBuffTime() then
                buffs[status] = 1
            end
        end

    end
    return currentActiveBuffs,buffs
end

function PveReportRound:GetSkill()
    return self.m_skills
end

function PveReportRound:GetDamage()
    return self.m_damage
end

return PveReportRound