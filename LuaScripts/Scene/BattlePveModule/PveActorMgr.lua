---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/9/22 16:01
---
local Const= require "Scene.BattlePveModule.Const"
local PveActorMgr = BaseClass("PveActorMgr1", Singleton)
local MailBattleReport = require "DataCenter.MailData.DataExtModule.MailBattleReport"
local PveReportParseHelper = require "Scene.BattlePveModule.MailDetailParseModule.PveMailDetailReportParseHelper"
local PveModelMgr = require "Scene.BattlePveModule.ModelModule.PveModelMgr"
local PveLineup = require "Scene.BattlePveModule.PveLineup"
local heroFields = { "hero1", "hero2", "hero3", "hero4", "hero5"}
local PveReportMgr = require "Scene.BattlePveModule.PveReportModule.PveReportMgr"
local PveReportBattle = require "Scene.BattlePveModule.PveReportModule.PveReportBattle"
local Resource = CS.GameEntry.Resource
local Localization = CS.GameEntry.Localization

local EFF_SUMMON_DURATION = 2
local EFF_SUMMON_OFFSET = Vector3.New(0, 3.53, 0)

function PveActorMgr:AddListener(msg_name, callback)
    local bindFunc = function(...) callback(self, ...) end
    self.__event_handlers[msg_name] = bindFunc
    EventManager:GetInstance():AddListener(msg_name, bindFunc)
end

function PveActorMgr:RemoveListener(msg_name, callback)
    local bindFunc = self.__event_handlers[msg_name]
    if not bindFunc then
        Logger.LogError(msg_name, " not register")
        return
    end
    self.__event_handlers[msg_name] = nil
    EventManager:GetInstance():RemoveListener(msg_name, bindFunc)
end

function PveActorMgr:GetSpeed()
    return 1.0 / self:GetSpeedOffset()
end

function PveActorMgr:GetSpeedOffset()
    return self.speedOffset
end

function PveActorMgr:SetSpeedOffset(speed)
    if speed > 0 then
        Setting:SetPrivateInt(SettingKeys.PVE_SPEED_OFFSET, speed)
    end
    self.speedOffset = speed
    if self.m_isPlayRound then
        Time:SetTimeScale(speed)
    end
end

function PveActorMgr:Pause()
    self:SetSpeedOffset(0)
end

function PveActorMgr:Resume()
    local speed = Setting:GetPrivateInt(SettingKeys.PVE_SPEED_OFFSET, 1)
    self:SetSpeedOffset(speed)
end

function PveActorMgr:__init()
    -- 阵型处理
    self.m_lineup = PveLineup.New()
    self.__event_handlers = {}
    -- 详细战报解析类
    self.m_detailReport = PveReportParseHelper.New()

    self.m_reportMgr = PveReportMgr.New()
    self.m_reportBattle = PveReportBattle.New(self.m_reportMgr)

    -- 回合 起始/终止
    self.m_startRoundIdx = 0
    self.m_endRoundIdx = 0
    -- 回合中的技能index
    self.m_skillRoundIdx = 0
    self.m_mailExt = nil
    -- 本轮技能集合,每次playRound的时候获取,不要每执行一次skill的时候再获取了
    self.m_curRoundSkill = {}
    self.m_heroes = {}

    -- 总血量
    self.atkTotalMaxHp = 0
    self.defTotalMaxHp = 0
    -- 总战力
    self.atkTotalPower = 0
    self.defTotalPower = 0
    self.atkTotalCurPower = 0
    self.defTotalCurPower = 0
    self.totalVirtualArmy = 0

    self.atkHp2PowerRatio = nil
    self.defHp2PowerRatio = nil

    --[[
    英雄战力辅助列表 关于战力这块比较恶心。通过GetEmBattleTotalPowerAndHp的方法,我们可以获取到总的战力,但是对于单个英雄的,因为不涉及到编队什么的作用号
    或者其他原因吧,这块顾曲比较清楚,总的战力并不等于通过GetInitPowerByHeroUuid获取到的A,B,C的总和,所以每次loadPlayer获取完英雄的战力后,做一下缓存
    用来做后续对总战力的区分
    ]]
    self.tmpAtkPower = {}

    -- 直接停止战斗
    self.stopPlay = false
    self.speedOffset = 0
    self.showSLevelHeroSkill = false
    self.isWaitPlayRound = false

    self.isHeroesBattleInit = false
    self.effReqList = {}
    self.hasResult = false
    self.m_isSkip = false
end


function PveActorMgr:GetCreateModelOK()
    return self.m_reportBattle:GetCreateModelOK()
end
function PveActorMgr:CheckPlayRound()
    if self.isWaitPlayRound == true and self:GetCreateModelOK() then
        self.isWaitPlayRound = false
        self:HeroesBattleInit()
        self:PlayRound()
    end

end
function PveActorMgr:ResetData()
    self.m_startRoundIdx = 0
    self.m_endRoundIdx = 0
    self.m_skillRoundIdx = 0
    self.m_mailExt = nil
    self.m_curRoundSkill = {}
    self.atkTotalMaxHp = 0
    self.defTotalMaxHp = 0
    self.atkTotalPower = 0
    self.defTotalPower = 0
    self.atkTotalCurPower = 0
    self.defTotalCurPower = 0
    self.totalVirtualArmy = 0
    self.atkHp2PowerRatio = nil
    self.defHp2PowerRatio = nil
    self.tmpAtkPower = {}
    self.stopPlay = false
    self.hasResult = false
    self.speedOffset = Setting:GetPrivateInt(SettingKeys.PVE_SPEED_OFFSET, 1)
    self.m_isPlayRound = false
    self.m_isSkip = false
end

function PveActorMgr:ClearMailExt()
    self.m_mailExt = nil
end

function PveActorMgr:ShowUIPVEHeroAppear(heroId,skillId,isOther)
    if self.showSLevelHeroSkill==false then
        self.showSLevelHeroSkill = true
        if isOther ==false then
            UIManager:GetInstance():OpenWindow(UIWindowNames.UIPVEHeroAppear,heroId,skillId)
        else
            UIManager:GetInstance():OpenWindow(UIWindowNames.UIPVEHeroAppearOther,heroId,skillId)
        end

        return true
    end
    return false
end

function PveActorMgr:ShowSHeroLevelSkill(heroId,skillId,isOther)
    if self.m_lineup~=nil then
        self.m_lineup:ShowSelfAttackTimeLine(isOther)
    end
end

function PveActorMgr:HideSHeroLevelSkill()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEHeroAppear)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEHeroAppearOther)
    if self.m_lineup~=nil then
        self.m_lineup:RemoveTimeLine()
    end
    self.showSLevelHeroSkill = false
end

-- 停止播放的做法为,瞬间做完所有的流程,但是不做效果展示
function PveActorMgr:IsStopPlay()
    return self.stopPlay
end

function PveActorMgr:ForceShowResult()
    self.stopPlay = true
end

function PveActorMgr:Skip()
    if self.m_isSkip then
        return
    end
    self.m_isSkip = true
    self.m_reportMgr:StopRound()
    self:ShowResult()
end

function PveActorMgr:IsSkip()
    return self.m_isSkip
end

function PveActorMgr:GetModelListByCamp(camp)
    --目前没找到除了战斗逻辑外其他外部逻辑有调用，新的战斗对象没有全部兼容老的接口（因为好多没有用）
    --为了避免外部调用到没有的接口报错，所以这里先注释掉
    return {}
end
function PveActorMgr:SetAllSidePower()
    self.atkHp2PowerRatio = nil
    self.defHp2PowerRatio = nil
    local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Player) or {}
    local defList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Target) or {}
    for _, v in pairs(atkList) do
        self.atkTotalPower = self.atkTotalPower + v:GetHeroPower()
    end
    for _, v in pairs(defList) do
        self.defTotalPower = self.defTotalPower + v:GetHeroPower()
    end
    self.atkTotalPower = Mathf.Floor(self.atkTotalPower)
    self.defTotalPower = Mathf.Floor(self.defTotalPower)

    self.atkTotalCurPower = self.atkTotalPower
    self.defTotalCurPower = self.defTotalPower
end

function PveActorMgr:GetHp2PowerRatio( campType )
    if (campType == Const.CampType.Player) then
        if (self.atkHp2PowerRatio == nil) then
            self.atkHp2PowerRatio = self.atkTotalPower / self.atkTotalMaxHp
        end
        return self.atkHp2PowerRatio
    else
        if (self.defHp2PowerRatio == nil) then
            self.defHp2PowerRatio = self.defTotalPower / self.defTotalMaxHp
        end
        return self.defHp2PowerRatio
    end
end

-- 取当前场景，暂时先写到世界，以后怎么做不知道呢
function PveActorMgr:GetCurScene()
    return CS.SceneManager.World
end

function PveActorMgr:GetBattleResult()
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        local result = self.levelParam.battleResult
        if result == true then
            return Const.Result.Win
        else
            return Const.Result.Fail
        end
    end
    if (self.m_mailExt == nil) then
        return Const.Result.NoWar
    end
    if (self.m_mailExt:GetBattleWinInPve()) then
        return Const.Result.Win
    else
        return Const.Result.Fail
    end
end

-- 向服务器发送战斗
function PveActorMgr:SendBattleCmd()
    local heroes = self:GetHeros()
    if (table.count(heroes) == 0) then
        return
    end

    self.m_lineup:HidehHeroSigns()

    local tb = {}
    tb["level"] = self.m_levelId
    tb["heroes"] = heroes
    tb["armys"] = self:GetArmys()
    SFSNetwork.SendMessage(MsgDefines.GetUserFightPve, tb)
end

--矿洞战斗
function PveActorMgr:SendCaveBattleCmd()
    local heroes = self:GetHeros()
    if (table.count(heroes) == 0) then
        return
    end

    self.m_lineup:HidehHeroSigns()

    local mineIndex, formationUuid = DataCenter.MineCaveManager:GetBattleParam()
    local armys = self:GetArmys()
    local powerStr = ""
    local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Player) or {}
    for _, model in pairs(atkList) do
        local _heroId = model:GetHeroId()
        local _power = model:GetHeroPower()
        powerStr = powerStr .. _heroId .. ";" .. _power .. "|"
    end
    SFSNetwork.SendMessage(MsgDefines.BeginPvpCaveFight, mineIndex, formationUuid, heroes, armys, powerStr)
end

function PveActorMgr:SendArenaSetDefenseArmy()
    local heroes = self:GetHeros()
    if (table.count(heroes) == 0) then
        return false
    end

    local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Player) or {}
    local totalPower = 0
    for temp, model in ipairs(atkList) do
        local _power = model:GetHeroPower()
        totalPower = totalPower + _power
    end

    DataCenter.ArenaManager:SendSetDefenseArmy(heroes, totalPower)
    return true
end

function PveActorMgr:SendArenaBattle()
    local heroes = self:GetHeros()
    if (table.count(heroes) == 0) then
        return false
    end

    local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Player) or {}
    local totalPower = 0
    for temp, model in ipairs(atkList) do
        local _power = model:GetHeroPower()
        totalPower = totalPower + _power
    end

    local enemyInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
    local type = enemyInfo.type
    local id = 0
    if type == 0 then
        id = enemyInfo.armyId
    else
        id = enemyInfo.uid
    end
    SFSNetwork.SendMessage(MsgDefines.StartArenaBattle, id, type, heroes, totalPower)
end

function PveActorMgr:SendArenaGetEnemyCampEffect()

    local enemyInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
    local type = enemyInfo.type
    local id = 0
    if type == 0 then
        id = enemyInfo.armyId
    else
        id = enemyInfo.uid
    end
    SFSNetwork.SendMessage(MsgDefines.GetArenaUserEffect, id, type)
end

function PveActorMgr:SetCamera()
    local camera = DataCenter.BattleLevel.pveCamera
    local s = camera:GetComponent(typeof(CS.BitBenderGames.MobileTouchCamera))
    self.oldPos = camera.transform.position
    self.oldRot = camera.transform.rotation
    self.oldEnable = s.enabled
    s.enabled = false

    local angle, newY = 40, 16
    local length = newY / math.tan(angle * math.pi / 180)
    local curTarget = CS.SceneManager.World.CurTarget
    camera.transform.position = Vector3.New(self.oldPos.x, newY, curTarget.z - length)
    camera.transform.rotation = Quaternion.Euler(angle, 0, 0)
end

function PveActorMgr:RestoreCamera()
    local camera = DataCenter.BattleLevel.pveCamera
    local s = camera:GetComponent(typeof(CS.BitBenderGames.MobileTouchCamera))
    s.enabled = self.oldEnable
    camera.transform.position = self.oldPos
    camera.transform.rotation = self.oldRot
end

function PveActorMgr:GetCurMonsterId()
    return GetTableData(TableName.Pve, self.levelParam.levelId, "monster")
end

function PveActorMgr:GetLeftHeadParam()
    local headParam = {}
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        headParam = self.levelParam.leftHeadParam
    else
        headParam.uid = LuaEntry.Player.uid
        headParam.pic = LuaEntry.Player.pic
        headParam.picVer = LuaEntry.Player.picVer
        headParam.name = ""
    end
    return headParam
end
function PveActorMgr:GetRightHeadParam()
    local headParam = {}
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        headParam = self.levelParam.rightHeadParam
    else
        local entranceType = DataCenter.BattleLevel:GetEntranceType()
        if entranceType == PveEntrance.MineCave then
            local mineIndex, formationUuid, tempID = DataCenter.MineCaveManager:GetBattleParam()
            local caveInfo = DataCenter.MineCaveManager:GetMineInfo(mineIndex)
            if caveInfo~=nil and caveInfo.ownerUid~=nil and caveInfo.ownerUid~="" then
                headParam.uid = caveInfo.ownerUid
                headParam.pic = caveInfo.ownerPic
                headParam.picVer = caveInfo.ownerPicVer
            else
                headParam.monsterPic = "Assets/Main/Sprites/UI/UIMail/world_monster_boss_coin.png"
            end
        else
            local monsterPic = DataCenter.MonsterTemplateManager:GetTableValue( self:GetCurMonsterId(), "pic_name")
            local monsterName = DataCenter.MonsterTemplateManager:GetTableValue( self:GetCurMonsterId(), "name")
            headParam.monsterPic = not string.IsNullOrEmpty(monsterPic) and string.format("Assets/Main/Sprites/UI/UIHeadIcon/%s.png",monsterPic) or "Assets/Main/Sprites/UI/UIHeadIcon/player_head_4.png"
            headParam.monsterName = not string.IsNullOrEmpty(monsterName) and Localization:GetString(monsterName) or Localization:GetString(821011)
            if entranceType == PveEntrance.ArenaBattle then
                local arenaRankInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
                if arenaRankInfo~=nil then
                    headParam.uid = arenaRankInfo.uid
                    headParam.pic = arenaRankInfo.pic
                    headParam.picVer = arenaRankInfo.picVer
                end
            end
        end
    end
    return headParam
end

function PveActorMgr:GetCameraRotation()
    if (self.m_mainCamera == nil) then
        self.m_mainCamera = DataCenter.BattleLevel.pveCamera
    end
    return self.m_mainCamera.transform.rotation
end

-- 进入PVE阶段，进入PVE是整个开始
-- tilePos是发生战斗的地点
-- armyId是要进行pve战斗的怪物列表
-- 从表中读取Monster列表，然后放到指定的位置上enemy01-05
function PveActorMgr:Enter(battleLevel, pos, rot, levelParam, isBossLevel)
    self.isHeroesBattleInit = false
    self.m_battleLevel = battleLevel
    self.m_battleTilePos = pos
    self.levelParam = levelParam
    self.hasResult = false
    self.isBossLevel = isBossLevel ~= nil and isBossLevel == 1
    self.m_mailExt = nil
    self.m_isPlayRound = false
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        self:SetArmys(self.levelParam.leftSoliderList)
    end
    UIManager:GetInstance():OpenWindow(UIWindowNames.UIPVEScene, { anim = true, UIMainAnim = UIMainAnimType.AllHide, hideTop = true },levelParam)
    self.m_lineup:Init(pos, 1, rot)
    local guideBgmName = DataCenter.GuideManager:GetGuideBgmName()
    if guideBgmName == nil or guideBgmName == "" then
        SoundUtil.PlayMainSceneBGMusic()
    end
    self:AddListener(EventId.PVE_Lineup_LoadOK, self.OnLineupLoadOK)
    self:AddUpdateTimer()
end

function PveActorMgr:ResetBattle()
    self.levelParam = nil
    if (self.m_delayAttack ~= nil) then
        self.m_delayAttack:Stop()
        self.m_delayAttack = nil
    end
    if (self.m_delayAttack1 ~= nil) then
        self.m_delayAttack1:Stop()
        self.m_delayAttack1 = nil
    end
    self:HideSHeroLevelSkill()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPveBattleSoldierList)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEScene, { anim = true, UIMainAnim = UIMainAnimType.AllHide })
    self.m_lineup:Destroy()
    -- 清除双方模型
    if self.m_modelMgr then self.m_modelMgr:Destroy() end
    self:RemoveListener(EventId.PVE_Lineup_LoadOK, self.OnLineupLoadOK)
    self:ResetData()
    self.m_heroes = {}
    -- 清除特效
    for _, req in ipairs(self.effReqList) do
        req:Destroy()
    end
    self.effReqList = {}
    self.m_reportBattle:Destroy()
    self.m_reportMgr:ClearData()
    Time:SetTimeScale(1)
    self.m_isPlayRound = false
end

-- 离开
function PveActorMgr:Leave()
    self.levelParam = nil
    self.m_mainCamera = nil
    if (self.m_delayAttack ~= nil) then
        self.m_delayAttack:Stop()
        self.m_delayAttack = nil
    end
    if (self.m_delayAttack1 ~= nil) then
        self.m_delayAttack1:Stop()
        self.m_delayAttack1 = nil
    end
    self:HideSHeroLevelSkill()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPveBattleSoldierList)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEScene, { anim = true, UIMainAnim = UIMainAnimType.AllHide })
    self.m_lineup:Destroy()
    -- 清除双方模型
    if self.m_modelMgr then self.m_modelMgr:Destroy() end
    self:RemoveListener(EventId.PVE_Lineup_LoadOK, self.OnLineupLoadOK)
    self:ResetData()
    self.m_heroes = {}
    -- 清除特效
    for _, req in ipairs(self.effReqList) do
        req:Destroy()
    end
    self.effReqList = {}
    self.m_reportBattle:Destroy()
    self.m_reportMgr:ClearData()
    Time:SetTimeScale(1)
    self.m_isPlayRound = false
end

-- 加载阵型OK，此时开始把怪物位置摆放到指定位置
function PveActorMgr:OnLineupLoadOK()
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        -- 加载怪
        self:LodPlackBackTarget()
        self:LodPlackBackSelf()
        TimerManager:GetInstance():DelayInvoke(function()
            PveActorMgr:GetInstance():SendBattlePlayBackCmd()
        end, 1.5)
    else
        -- 加载怪
        self:LoadTarget()
        self:RefreshEnemySigns()
    end
end

function PveActorMgr:IsLineupLoadOK()
    return self.m_lineup:IsLoadOK()
end

function PveActorMgr:SendBattlePlayBackCmd()
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        SFSNetwork.SendMessage(MsgDefines.MailGetFightReportDetail, self.levelParam.bigRoundUuid,nil,self.levelParam.bigRoundIndex, nil)
    end
end
function PveActorMgr:GetIsInPlayBackPveState()
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        return true
    end
    return false
end

function PveActorMgr:LodPlackBackTarget()
    if self.levelParam~=nil then
        if self.levelParam.rightMonsterId ==0 then
            local enemyHero = self.levelParam.rightHero
            local qualities = {}
            local tempAtkPower = {}
            for i,heroData in pairs(enemyHero) do
                local power = heroData.power or 0
                local heroId = heroData.heroId
                local heroLv = heroData.heroLv
                local heroQuality = heroData.heroQuality
                local heroRankId = heroData.rankId
                tempAtkPower[heroId]= power
                local rarity = GetTableData(HeroUtils.GetHeroXmlName(),tonumber(heroId), "rarity")
                qualities[i] = rarity
                self.m_reportBattle:AddHero(Const.CampType.Target, i, tonumber(heroId), tonumber(power),heroLv,heroQuality,rarity,nil,nil,heroRankId)
                local effPos = self:GetStandPosByIndex(Const.CampType.Target, i) + EFF_SUMMON_OFFSET
                --self:CreateEffectObj(UIAssets.PveHeroSummon, effPos, EFF_SUMMON_DURATION)
            end
            local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Target) or {}
            local totalHeroPower = 0
            for _, v in pairs(tempAtkPower) do
                totalHeroPower = totalHeroPower + v
            end
            local realTotalPower = self:GetEmBattleTotalPowerAndHp(false)
            local atkCnt = table.count(tempAtkPower)
            local tmpIndex = 1
            local realHeroPowerList = {}
            local temPower = 0
            for heroId, power in pairs(tempAtkPower) do
                if (tmpIndex == atkCnt) then
                    realHeroPowerList[heroId] = realTotalPower - temPower
                else
                    local realPower = Mathf.Floor(power / totalHeroPower * realTotalPower)
                    realHeroPowerList[heroId] = realPower
                    temPower = temPower + realPower
                end
                tmpIndex = tmpIndex + 1
            end
            for _, model in pairs(atkList) do
                local _heroId = model:GetHeroId()
                local _power = realHeroPowerList[tostring(_heroId)] or 0
                model:SetHeroPower(_power)
            end
            self.m_lineup:RefreshEnemySigns(qualities)
        else
            local monsterId = self.levelParam.rightMonsterId
            local armyId = DataCenter.MonsterTemplateManager:GetTableValue( monsterId, "army")
            local enemyHeros = {}
            local qualities = {}
            for k,v in ipairs(heroFields) do
                local heroInfo = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, v)
                if (string.IsNullOrEmpty(heroInfo)) then
                    goto continue
                end
                -- 英雄1/英雄等级/英雄品质
                local t = string.split(heroInfo, ';')
                if table.count(t) >= 3 then
                    local oneData= {}
                    oneData.heroId = tonumber(t[1])
                    oneData.heroLv = tonumber(t[2])
                    oneData.heroQuality = tonumber(t[3])
                    oneData.rankId = 0
                    if #t>=5 then
                        local rankLv = tonumber(t[4]) or 0
                        local stage = tonumber(t[5]) or 0
                        local curMilitaryRankId = HeroUtils.GetRankIdByLvAndStage(oneData.heroId, rankLv, stage)
                        oneData.rankId = 0
                        if curMilitaryRankId~=nil and curMilitaryRankId>0 then
                            oneData.rankId = curMilitaryRankId
                        end
                    end
                    enemyHeros[#enemyHeros + 1] = oneData

                end
                ::continue::
            end
            local pve_power = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "pve_power")
            local tab_pve_power = string.split(pve_power, '|')
            for i, heroData in pairs(enemyHeros) do
                local power = tab_pve_power[i] or 0
                if power=="" then
                    power = 0
                end
                local heroId = heroData.heroId
                local heroLv = heroData.heroLv
                local heroQuality = heroData.heroQuality
                local heroRankId = heroData.rankId
                local rarity = GetTableData(HeroUtils.GetHeroXmlName(),tonumber(heroId), "rarity")
                qualities[i] = rarity
                -- 英雄1/英雄等级/英雄品质
                self.m_reportBattle:AddHero(Const.CampType.Target, i, tonumber(heroId), tonumber(power),heroLv,heroQuality,rarity,nil,nil,heroRankId)
                local effPos = self:GetStandPosByIndex(Const.CampType.Target, i) + EFF_SUMMON_OFFSET
                --self:CreateEffectObj(UIAssets.PveHeroSummon, effPos, EFF_SUMMON_DURATION)
            end
            self.m_lineup:RefreshEnemySigns(qualities)
        end
    end
end

function PveActorMgr:LodPlackBackSelf()
    if self.levelParam~=nil then
        local hero = self.levelParam.leftHero
        local tempAtkPower = {}
        for i,heroData in pairs(hero) do
            local power = heroData.power or 0
            local heroId = heroData.heroId
            local heroLv = heroData.heroLv
            local heroQuality = heroData.heroQuality
            local heroRankId = heroData.rankId
            tempAtkPower[heroId]= power
            local rarity = GetTableData(HeroUtils.GetHeroXmlName(),tonumber(heroId), "rarity")
            self.m_reportBattle:AddHero(Const.CampType.Player, i, tonumber(heroId), tonumber(power),heroLv,heroQuality,rarity,nil,nil,heroRankId)
            local effPos = self:GetStandPosByIndex(Const.CampType.Player, i) + EFF_SUMMON_OFFSET
            --self:CreateEffectObj(UIAssets.PveHeroSummon, effPos, EFF_SUMMON_DURATION)
            self.m_lineup:SetHeroSignIcon(i,rarity)
        end
        local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Player) or {}
        local totalHeroPower = 0
        for _, v in pairs(tempAtkPower) do
            totalHeroPower = totalHeroPower + v
        end
        local realTotalPower = self:GetEmBattleTotalPowerAndHp(true)
        local atkCnt = table.count(tempAtkPower)
        local tmpIndex = 1
        local realHeroPowerList = {}
        local temPower = 0
        for heroId, power in pairs(tempAtkPower) do
            if (tmpIndex == atkCnt) then
                realHeroPowerList[heroId] = realTotalPower - temPower
            else
                local realPower = Mathf.Floor(power / totalHeroPower * realTotalPower)
                realHeroPowerList[heroId] = realPower
                temPower = temPower + realPower
            end
            tmpIndex = tmpIndex + 1
        end
        for _, model in pairs(atkList) do
            local _heroId = model:GetHeroId()
            local _power = realHeroPowerList[tostring(_heroId)] or 0
            model:SetHeroPower(_power)
        end
    end
end


function PveActorMgr:LoadTarget()
    local model = self:GetEnemyHeros()

    local armyId = 0
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave then
        local _, _, tempID = DataCenter.MineCaveManager:GetBattleParam()
        armyId = tempID
    else
        armyId = self:GetArmyId()
    end

    local tab_pve_power = {}
    if entranceType == PveEntrance.ArenaBattle then
        tab_pve_power = self:GetArenaDefenseHeroPower()
    else
        local pve_power = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "pve_power")
        tab_pve_power = string.split(pve_power, '|')
    end

    for i, heroData in pairs(model) do
        local power = tab_pve_power[i] or 0
        local heroId = heroData.heroId
        local heroLv = heroData.heroLv
        local heroQuality = heroData.heroQuality
        local heroRankId = heroData.rankId
        local rarity = GetTableData(HeroUtils.GetHeroXmlName(),tonumber(heroId), "rarity")
        -- 英雄1/英雄等级/英雄品质
        self.m_reportBattle:AddHero(Const.CampType.Target, i, tonumber(heroId), tonumber(power),heroLv,heroQuality,rarity,nil,nil,heroRankId)
        local effPos = self:GetStandPosByIndex(Const.CampType.Target, i) + EFF_SUMMON_OFFSET
        --self:CreateEffectObj(UIAssets.PveHeroSummon, effPos, EFF_SUMMON_DURATION)
    end

    if entranceType == PveEntrance.MineCave then
        local isTargetPlayer = DataCenter.MineCaveManager:CheckIfEnemyIsPlayer()
        if isTargetPlayer then
            self:ResetTargetHeroPower()
        end
    end
end

function PveActorMgr:GetArenaDefenseHeroPower()
    local arenaRankInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
    local powerTb = {}

    if arenaRankInfo.type == 0 then
        local armyId = LuaEntry.DataConfig:TryGetStr("arena", "k12")
        local strPower = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "pve_power")
        local arrPower = string.split(strPower, "|")
        for i, v in ipairs(arrPower) do
            if not string.IsNullOrEmpty(v) then
                table.insert(powerTb, tonumber(v))
            end
        end
    else
        local virtualPowerTb = {}
        local virtualPower = 0
        local heroes = arenaRankInfo.army.heroes or {}
        local totalPower = arenaRankInfo.power or 0
        for i, heroData in ipairs(heroes) do
            local curPower = 0
            local k1 = LuaEntry.DataConfig:TryGetNum("power_setting", "k1")
            local beyondTimes = HeroUtils.GetBeyondTimesByLevel(heroData.heroLevel)
            local curAtk, curDef = HeroUtils.GetHeroAttr(heroData.heroId,heroData.heroQuality,heroData.heroLevel,beyondTimes,1)
            curPower = Mathf.Round((curAtk + curDef) * k1)
            virtualPower = virtualPower + curPower
            table.insert(virtualPowerTb, curPower)
        end
        for i, v in ipairs(virtualPowerTb) do
            local tempHp = math.modf((v / virtualPower) * totalPower)
            table.insert(powerTb, tempHp)
        end
    end

    return powerTb
end

function PveActorMgr:ResetTargetHeroPower()
    local heroPowerDic = DataCenter.MineCaveManager:GetEnemyPlayerPower()

    local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Target) or {}
    for _, model in pairs(atkList) do
        local _heroId = model:GetHeroId()
        local _power = heroPowerDic[tostring(_heroId)] or 99
        model:SetHeroPower(_power)
    end
end

-- 删除指定索引的Model
function PveActorMgr:RemoveModelObj( modelType, index, heroId ,curHeroes)
    if heroId then
        self.tmpAtkPower[tostring(heroId)] = nil
    end
    self.m_reportBattle:RemoveHero(modelType,index,curHeroes)
    self:ResetHeroPower()
end

function PveActorMgr:SortPlayerHeroes(heroes)
    self.m_reportBattle:SortPlayerHeroes(heroes)
end

-- 模型管理类
function PveActorMgr:GetModelMgr()
    --默认不再用了，外部调用的地方也注释掉了，如果有新的逻辑还在调用，为了避免报错，这里就初始化一下
    if self.m_modelMgr == nil then
        self.m_modelMgr = PveModelMgr.New()
    end
    return self.m_modelMgr
end

-- return self, other  获取双方总血量
function PveActorMgr:GetHealth(mailExt, roundIdx)
    local roundFight = mailExt:GetFightReportByRoundIndex(roundIdx)
    if ( roundFight == nil ) then
        return
    end
    local selfHealth = roundFight:GetTroopHealth(true)
    local otherHealth = roundFight:GetTroopHealth(false)
    return selfHealth, otherHealth
end

function PveActorMgr:ParseMailData(battleContent)
    local mailInfo = {}
    mailInfo["battleContent"] = battleContent
    local ext = MailBattleReport.New()
    ext:ParseContent(mailInfo)
    self.m_mailExt = ext
end

function PveActorMgr:ParseMailDetail(detailContent)
    local selfHealth, otherHealth = self:GetHealth(self.m_mailExt, 1)
    -- 详情数据
    local needExchange = self.levelParam and self.levelParam.needExchange or false

    local tableData1 = PBController.ParsePb1(detailContent, ".protobuf.BattleDetailInfo")
    self.m_reportMgr:ParseData(tableData1, selfHealth,otherHealth,needExchange)
    self.m_startRoundIdx = self.m_reportMgr:GetMinIndex()
    self.m_endRoundIdx = self.m_reportMgr:GetMaxIndex()

    self:SetAtkTotalMaxHp(selfHealth)
    self:SetDefTotalMaxHp(otherHealth)
end

function PveActorMgr:ParseExpInfo(expContent)
    self.expInfoDict = {}
    if expContent ~= nil then
        local reportReward = PBController.ParsePb1(expContent, "protobuf.ReportReward")
        local exps = reportReward["rewardHeroExps"] or {}
        for _, expInfo in pairs(exps) do
            self.expInfoDict[expInfo["heroUuid"]] = expInfo
        end
    end
end

-- 解析战斗数据
function PveActorMgr:ParseData(battleContent, detailContent, expContent)
    self:ResetData()

    self.m_reportMgr:ClearData()
    -- 战报数据
    self:ParseMailData(battleContent)
    -- 详细战报
    self:ParseMailDetail(detailContent)
    -- 英雄经验
    self:ParseExpInfo(expContent)

    EventManager:GetInstance():Broadcast(EventId.PveMineCaveInfoUpdate)

    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave and not DataCenter.MineCaveManager:CheckIfNeedPreloadEnemy() then
        EventManager:GetInstance():Broadcast(EventId.PVE_Lineup_LoadOK)
        TimerManager:GetInstance():DelayInvoke(function()
            if self:IsLineupLoadOK() and self:GetCreateModelOK() then
                self:HeroesBattleInit()
                self:PlayRound()
            else
                self.isWaitPlayRound = true
            end
        end, 1.5)
    else
        -- 双方开始战斗准备
        if self:IsLineupLoadOK() and self:GetCreateModelOK() then
            self:HeroesBattleInit()
            self:PlayRound()
        else
            self.isWaitPlayRound = true
        end
    end

    DataCenter.BattleLevel:OnStartBattle()
    EventManager:GetInstance():Broadcast(EventId.BattleMessageParsed)
end

function PveActorMgr:ParsePlayBackData(detailContent)
    self:ResetData()
    local selfHealth  = 0
    local otherHealth = 0
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        selfHealth = self.levelParam.selfHealth
        otherHealth = self.levelParam.otherHealth
    end
    local needExchange = self.levelParam and self.levelParam.needExchange or false
    -- 详情数据
    self.m_reportMgr:ClearData()
    local tableData1 = PBController.ParsePb1(detailContent, ".protobuf.BattleDetailInfo")
    self.m_reportMgr:ParseData(tableData1, selfHealth,otherHealth,needExchange)
    self.m_startRoundIdx = self.m_reportMgr:GetMinIndex()
    self.m_endRoundIdx = self.m_reportMgr:GetMaxIndex()

    self:SetAtkTotalMaxHp(selfHealth)
    self:SetDefTotalMaxHp(otherHealth)
    self:ParseExpInfo()
    EventManager:GetInstance():Broadcast(EventId.PveMineCaveInfoUpdate)
    if self:IsLineupLoadOK() and self:GetCreateModelOK() then
        self:HeroesBattleInit()
        self:PlayRound()
    else
        self.isWaitPlayRound = true
    end
end

--[[
    我们根据英雄的战力分配伤害系数,
    比如我方为
    A(4)    A1
    B(5)    B1
    C(1)    C1
            D1
    这样的话比如本轮伤害是1000,计算出来A输出400,B-500,C-100 给对位伤害,D1不受伤害,如果A1的血量不够,我们依次传递给下面的
]]
function PveActorMgr:HeroesBattleInit()
    -- (新版)
    self:SetAllSidePower()
    self.isHeroesBattleInit = true
end

function PveActorMgr:GetStandPosByIndex(campType, index)
    if (campType == Const.CampType.Player) then
        return self.m_lineup:GetMyPosPosition(index)
    else
        return self.m_lineup:GetEnemyPosPosition(index)
    end
end

-- 获取heroUuid对应的power值
function PveActorMgr:GetInitPowerByHeroUuid( uuid )
    if uuid == nil then
        return 0
    end
    local curPower = 0
    local heroData = DataCenter.HeroDataManager:GetHeroByUuid(uuid)
    if heroData~=nil then
        local k1 = LuaEntry.DataConfig:TryGetNum("power_setting", "k1")
        local beyondTimes = HeroUtils.GetBeyondTimesByLevel(heroData.level)
        local curAtk, curDef = HeroUtils.GetHeroAttr(heroData.heroId,heroData.quality,heroData.level,beyondTimes,heroData.curMilitaryRankId)
        curPower = Mathf.Round((curAtk + curDef) * k1)
        if heroData.skillDict~=nil then
            for k,v in pairs(heroData.skillDict) do
                if v.level>0 and heroData:IsSkillUnlock(k) then
                    local powerStr = GetTableData(TableName.SkillTab, k, 'power')
                    local strArr = string.split(powerStr,"|")
                    if #strArr>=v.level then
                        curPower = curPower + tonumber(strArr[v.level])
                    end
                end
            end
        end
    end
    return curPower
end

function PveActorMgr:LoadPlayer(index, heroId, power,heroLv,quality,rarity,heroUuid,heroRankId,curHeroes)
    self.tmpAtkPower[tostring(heroId)] = power
    local enemy = self:GetEnemyHeros()
    local targetLv = 0
    if #enemy>=index then
        local emy = enemy[index]
        if emy~=nil then
            targetLv = emy.heroLv
        end
    end
    self.m_reportBattle:AddHero(Const.CampType.Player, index, heroId, power,heroLv,quality,rarity,targetLv,heroUuid,heroRankId,curHeroes)
    local effPos = self:GetStandPosByIndex(Const.CampType.Player, index) + EFF_SUMMON_OFFSET
    --self:CreateEffectObj(UIAssets.PveHeroSummon, effPos, EFF_SUMMON_DURATION)
    self:ResetHeroPower()
end

function PveActorMgr:ResetHeroPower()
    local atkList = self.m_reportBattle:GetModelListByCamp(Const.CampType.Player) or {}
    local totalHeroPower = 0
    for _, v in pairs(self.tmpAtkPower) do
        totalHeroPower = totalHeroPower + v
    end
    local realTotalPower = self:GetEmBattleTotalPowerAndHp(true)
    local atkCnt = table.count(self.tmpAtkPower)
    local tmpIndex = 1
    local realHeroPowerList = {}
    local tmpAtkPower = 0
    for heroId, power in pairs(self.tmpAtkPower) do
        if (tmpIndex == atkCnt) then
            realHeroPowerList[heroId] = realTotalPower - tmpAtkPower
        else
            local power = Mathf.Floor(power / totalHeroPower * realTotalPower)
            realHeroPowerList[heroId] = power
            tmpAtkPower = tmpAtkPower + power
        end
        tmpIndex = tmpIndex + 1
    end
    for _, model in pairs(atkList) do
        local _heroId = model:GetHeroId()
        local _power = realHeroPowerList[tostring(_heroId)] or 0
        model:SetHeroPower(_power)
    end
end

function PveActorMgr:IsFinalRound()
    if (self.m_startRoundIdx == 0) then
        return false;
    end
    return self.m_startRoundIdx == self.m_endRoundIdx
end

-- 获取当前战斗经验加成
function PveActorMgr:GetHeroesGotExpInBattle()
    if (self.m_mailExt == nil) then
        return {}
    end
    return self.m_mailExt:GetHeroExpAddInfo()
end

-- 战斗结算
function PveActorMgr:ShowResult()
    self.m_reportBattle:Stop()
    self.m_reportMgr:StopRound()
    Time:SetTimeScale(1)
    self.hasResult = true
    self:HideSHeroLevelSkill()
    EventManager:GetInstance():Broadcast(EventId.PVEBattleSetLeftBuffData)
    EventManager:GetInstance():Broadcast(EventId.PVEBattleSetRightBuffData)
    local battleResult = self:GetBattleResult()
    local _targetModelList = battleResult == Const.Result.Win and self.m_reportBattle:GetModelListByCamp(Const.CampType.Target) or self.m_reportBattle:GetModelListByCamp(Const.CampType.Player)
    if _targetModelList~=nil then
        for _, modelObj in pairs(_targetModelList) do
            modelObj:DoDead()
        end
    end

    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPveBattleSoldierList)
    UIManager.Instance:DestroyWindow(UIWindowNames.UICampBonus)
    DataCenter.BattleLevel:OnBattleFinish(battleResult)
end

-- 播放回合
--[[
    这块大致的逻辑是每回合的时候首先播放normalAttack,按照回合数从详细战报中直接获取每个人的伤害
    在playSkill的时候,我们就根据子索引值获取不同的actionItem,
    在最后整体播放一次本回合的BUFF

    这个地方有个问题一开始没想好,关于BUFF是按照技能的形式,每回合从详细战报中读出来播,还是挂在人身上.最终还是决定挂在人身上
    这样在BUFF卸载的时候也比较好处理
]]
function PveActorMgr:PlayRound()
    if (self.m_startRoundIdx > self.m_endRoundIdx) then
        -- 战斗结束
        self:ShowResult()
        return
    end
    if self.isBossLevel then
        local param = {}
        param.warningTxt = 830248
        param.callback = function()
            self:StartBattle()
        end
        UIManager:GetInstance():OpenWindow(UIWindowNames.UIPVEHeroBossFightStart, {}, param)
    else
        self:StartBattle()
    end
end

function PveActorMgr:StartBattle()
    self.m_isPlayRound = true
    self.m_reportBattle:Start()
    self.m_reportMgr:StartRound()
    self.m_lineup:SetActive(false)
    if self.speedOffset and self.speedOffset ~= 0 then
        Time:SetTimeScale(self.speedOffset)
    end
end

-- 根据triggerindex计算是属于哪方的
function PveActorMgr:GetCampTypeByTriggerIndex(value)
    if (self.m_detailReport == nil) then
        return Const.CampType.Target
    end
    local needExchange = self.levelParam and self.levelParam.needExchange or false
    return self.m_detailReport:GetCampTypeByTriggerIndex(value, needExchange)
end

function PveActorMgr:Destroy()
    self.m_mainCamera = nil
    if (self.m_delayAttack ~= nil) then
        self.m_delayAttack:Stop()
        self.m_delayAttack = nil
    end
    if (self.m_delayAttack1 ~= nil) then
        self.m_delayAttack1:Stop()
        self.m_delayAttack1 = nil
    end
    self.levelParam = nil
    self:HideSHeroLevelSkill()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPveBattleSoldierList)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEScene)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEResult)

    self.m_lineup:Destroy()
    -- 清除双方模型
    if self.m_modelMgr then self.m_modelMgr:Destroy() end
    if self.__event_handlers[EventId.PVE_Lineup_LoadOK] then
        self:RemoveListener(EventId.PVE_Lineup_LoadOK, self.OnLineupLoadOK)
    end
    self.m_detailReport:ClearData()
    self.m_mailExt = nil
    self.hasResult = false
    self.expInfoDict = nil
    self:RemoveUpdateTimer()
    self.m_reportBattle:Destroy()
    self.m_reportMgr:ClearData()
    Time:SetTimeScale(1)
    self.m_isPlayRound = false
    self:ResetData()
end

-- 获取敌人的英雄列表
function PveActorMgr:GetEnemyHeros()
    -- 通过monster可以获取一个部队信息
    -- 通过部队可以获取到英雄列表
    -- 再去英雄表里获取英雄模型，考虑到英雄的站位，这里使用0进行填充，到时候过滤一下

    --矿洞pve
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    local isTargetPlayer = DataCenter.MineCaveManager:CheckIfEnemyIsPlayer()
    if entranceType == PveEntrance.MineCave and isTargetPlayer then
        local tempHeroes = {}
        if self.m_mailExt._fightRoundList and #self.m_mailExt._fightRoundList > 0 then
            local heroInfoDic = self.m_mailExt._fightRoundList[1]._otherArmyResult._armyObj._tHeroes
            for i, v in pairs(heroInfoDic) do
                local oneData= {}
                oneData.heroId = tonumber(v.heroId)
                oneData.heroLv = tonumber(v.heroLevel)
                oneData.heroQuality = tonumber(v.heroQuality)
                local rankLv = tonumber(v.rankLv) or 0
                local stage = tonumber(v.stage) or 0
                local curMilitaryRankId = HeroUtils.GetRankIdByLvAndStage(oneData.heroId, rankLv, stage)
                oneData.rankId = 0
                if curMilitaryRankId~=nil and curMilitaryRankId>0 then
                    oneData.rankId = curMilitaryRankId
                end
                tempHeroes[#tempHeroes + 1] = oneData
            end
        end
        return tempHeroes
    end

    --竞技场pve
    if entranceType == PveEntrance.ArenaBattle then
        local arenaRankInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
        if arenaRankInfo and arenaRankInfo.type == 1 then
            local heroes = {}
            local tempHeroes = arenaRankInfo.army.heroes or {}
            for i, v in ipairs(tempHeroes) do
                local oneData= {}
                oneData.heroId = tonumber(v.heroId)
                oneData.heroLv = tonumber(v.heroLevel)
                oneData.heroQuality = tonumber(v.heroQuality)
                local rankLv = tonumber(v.rankLv) or 0
                local stage = tonumber(v.stage) or 0
                local curMilitaryRankId = HeroUtils.GetRankIdByLvAndStage(oneData.heroId, rankLv, stage)
                oneData.rankId = 0
                if curMilitaryRankId~=nil and curMilitaryRankId>0 then
                    oneData.rankId = curMilitaryRankId
                end
                heroes[#heroes + 1] = oneData
            end
            return heroes
        end
    end


    --正常pve
    local armyId = 0
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave then
        local _, _, tempID = DataCenter.MineCaveManager:GetBattleParam()
        armyId = tempID
    elseif entranceType == PveEntrance.ArenaSetting then
        return {}
    elseif entranceType == PveEntrance.ArenaBattle then
        armyId = LuaEntry.DataConfig:TryGetStr("arena", "k12")
    else
        armyId = self:GetArmyId()
    end

    local enemyHeros = {}
    for k,v in ipairs(heroFields) do
        local heroInfo = nil
        if entranceType == PveEntrance.ArenaBattle then
            heroInfo = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, v)
        else
            heroInfo = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, v)
        end
        if (string.IsNullOrEmpty(heroInfo)) then
            goto continue
        end
        -- 英雄1/英雄等级/英雄品质
        local t = string.split(heroInfo, ';')
        if table.count(t) >= 3 then
            local oneData= {}
            oneData.heroId = tonumber(t[1])
            oneData.heroLv = tonumber(t[2])
            oneData.heroQuality = tonumber(t[3])
            oneData.rankId = 0
            if #t>=5 then
                local rankLv = tonumber(t[4]) or 0
                local stage = tonumber(t[5]) or 0
                local curMilitaryRankId = HeroUtils.GetRankIdByLvAndStage(oneData.heroId, rankLv, stage)
                oneData.rankId = 0
                if curMilitaryRankId~=nil and curMilitaryRankId>0 then
                    oneData.rankId = curMilitaryRankId
                end
            end

            enemyHeros[k] = oneData

        end
        ::continue::
    end
    return enemyHeros
end

function PveActorMgr:GetEnemyHeroIds()
    if self.levelParam and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        local mailExt = self.m_mailExt or self.levelParam.mailExt
        if mailExt then
            local heroDict = mailExt:GetHeroDict(false)
            return table.keys(heroDict)
        end
    else
        local heroIds = {}
        for _, v in ipairs(self:GetEnemyHeros()) do
            table.insert(heroIds, v.heroId)
        end
        return heroIds
    end
    return {}
end

function PveActorMgr:GetArmyId()

    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave then
        local _, _, tempArmyId = DataCenter.MineCaveManager:GetBattleParam()
        return tempArmyId
    elseif entranceType == PveEntrance.ArenaBattle then
        return 0
    end
    
    local armyId = DataCenter.MonsterTemplateManager:GetTableValue( self:GetCurMonsterId(), "army")
    if string.IsNullOrEmpty(armyId) then
        Logger.LogError("PveActorMgr GetArmyId error: monsterId = " .. self:GetCurMonsterId())
    end
    return armyId
end

function PveActorMgr:RefreshEnemySigns()
    local qualities = {}

    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave then
        local model = self:GetEnemyHeros()
        for i, v in ipairs(model) do
            qualities[i] = GetTableData(HeroUtils.GetHeroXmlName(), v.heroId, "rarity")
        end
    elseif entranceType == PveEntrance.ArenaBattle then
        local arenaRankInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
        local heroes = arenaRankInfo.army.heroes or {}
        for i, v in ipairs(heroes) do
            qualities[i] = GetTableData(HeroUtils.GetHeroXmlName(), v.heroId, "rarity")
        end
    else
        local armyId = self:GetArmyId()
        for k, fieldName in ipairs(heroFields) do
            local heroInfo = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, fieldName)
            if (string.IsNullOrEmpty(heroInfo)) then
                goto continue
            end

            -- 英雄1/英雄等级/英雄品质
            local t = string.split(heroInfo, ';')
            if table.count(t) >= 1 then
                qualities[k] = GetTableData(HeroUtils.GetHeroXmlName(), t[1], "rarity")
            end

            ::continue::
        end
    end

    self.m_lineup:RefreshEnemySigns(qualities)
end

function PveActorMgr:SetAtkTotalMaxHp(maxHp)
    self.atkTotalMaxHp = maxHp
    EventManager:GetInstance():Broadcast(EventId.PVE_TotalHp_Changed, true)
end

function PveActorMgr:SetDefTotalMaxHp(maxHp)
    self.defTotalMaxHp = maxHp
    EventManager:GetInstance():Broadcast(EventId.PVE_TotalHp_Changed, false)
end

function PveActorMgr:AddAtkTotalHp(hp)
    self.atkTotalCurPower = Mathf.Clamp(self.atkTotalCurPower + hp, 0, self.atkTotalPower)
    EventManager:GetInstance():Broadcast(EventId.PVE_TotalHp_Changed, true)
end

function PveActorMgr:AddDefTotalHp(hp)
    self.defTotalCurPower = Mathf.Clamp(self.defTotalCurPower + hp, 0, self.defTotalPower)
    EventManager:GetInstance():Broadcast(EventId.PVE_TotalHp_Changed, false)
end

function PveActorMgr:GetAtkTotalMaxHp()
    return self.atkTotalPower
end

function PveActorMgr:GetAtkTotalCurHp()
    return math.ceil(self.atkTotalCurPower)
end

function PveActorMgr:GetDefTotalMaxHp()
    return self.defTotalPower
end

function PveActorMgr:GetDefTotalCurHp()
    return self.defTotalCurPower
end

function PveActorMgr:GetTotalVirtualArmy()
    if self.totalVirtualArmy == 0 then
        local entranceType = DataCenter.BattleLevel:GetEntranceType()
        if entranceType == PveEntrance.MineCave then
            if self.m_mailExt and self.m_mailExt._fightRoundList and #self.m_mailExt._fightRoundList > 0 then
                local soldierDic = self.m_mailExt._fightRoundList[1]._otherArmyResult._armyObj._tSoldiers
                for i, v in pairs(soldierDic) do
                    self.totalVirtualArmy = self.totalVirtualArmy + v.total
                end
            end
        end
    end
    return self.totalVirtualArmy
end

function PveActorMgr:SetHeros(heroes)
    self.m_heroes = {}

    for index, uuid in pairs(heroes) do
        table.insert(self.m_heroes, {["index"] = index, ["uuid"] = uuid})
    end
    self:SetHeroDataBackup()

    EventManager:GetInstance():Broadcast(EventId.OnEmBattleHeroChanged)
end

function PveActorMgr:GetHeros()
    if self.m_heroes == nil then
        self.m_heroes = {}
    end
    return self.m_heroes
end

function PveActorMgr:GetHeroIds()
    if self.levelParam and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        local mailExt = self.m_mailExt or self.levelParam.mailExt
        if mailExt then
            local heroDict = mailExt:GetHeroDict(true)
            return table.keys(heroDict)
        end
    else
        local heroUuids = {}
        for _, v in ipairs(self.m_heroes) do
            table.insert(heroUuids, v.uuid)
        end
        return HeroUtils.GetHeroIdsByUuids(heroUuids)
    end
    return {}
end

function PveActorMgr:GetHeroUuids()
    local heroUuids = {}
    for _, v in ipairs(self.m_heroes) do
        table.insert(heroUuids, v.uuid)
    end
    return heroUuids
end

function PveActorMgr:HaveHeroUuid(heroUuid)
    for _, v in ipairs(self.m_heroes) do
        if v.uuid == heroUuid then
            return true
        end
    end
    return false
end

function PveActorMgr:SetArmys(armys)
    self.m_armys = armys
end

function PveActorMgr:GetArmys()
    if self.m_armys == nil then
        self.m_armys = {}
    end
    return self.m_armys
end

function PveActorMgr:GetEmBattleTotalPowerAndHp(isSelf)
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        if isSelf then
            return self.levelParam.leftPower
        else
            if self.levelParam.rightMonsterId ==0 then
                return self.levelParam.rightPower
            else
                local totalPower = 0
                local monsterId = self.levelParam.rightMonsterId
                local armyId = DataCenter.MonsterTemplateManager:GetTableValue( monsterId , "army")
                local pve_power_str = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "pve_power") or ''
                local powerTable = string.split(pve_power_str, '|')
                for _, v in pairs(powerTable) do
                    totalPower = totalPower + (tonumber(v) or 0)
                end
                return totalPower
            end
        end
    else
        if isSelf then
            local heroes = {}
            for _, v in pairs(self.m_heroes) do
                if v ~= nil and v.uuid ~= nil then
                    heroes[v.uuid] = DataCenter.HeroDataManager:GetHeroByUuid(v.uuid)
                end
            end

            local soldiers = {}
            table.walk(self:GetArmys(),function (k,v)
                soldiers[tonumber(k)] = v
            end)

            
            local buffEffectDict = {}
            local totalPower, totalHp = MarchUtil.GetFormationPower(heroes,soldiers,1,MarchUtil.GetCampAddParam(heroes),buffEffectDict)
            return math.ceil(totalPower), math.ceil(totalHp)
        else
            local armyId = 0
            local entranceType = DataCenter.BattleLevel:GetEntranceType()
            if entranceType == PveEntrance.MineCave then
                local isTargetPlayer = DataCenter.MineCaveManager:CheckIfEnemyIsPlayer()
                if isTargetPlayer then
                    local heroPowerDic = DataCenter.MineCaveManager:GetEnemyPlayerPower()
                    local totalP = 0
                    for _, tempHp in pairs(heroPowerDic) do
                        totalP = totalP + tempHp
                    end
                    return totalP, totalP
                else
                    local _, _, tempID = DataCenter.MineCaveManager:GetBattleParam()
                    armyId = tempID
                end
            elseif entranceType == PveEntrance.ArenaSetting then
                return 0, 0
            elseif entranceType == PveEntrance.ArenaBattle then
                local hpTb = self:GetArenaDefenseHeroPower()
                local totalHp = 0
                for i, v in ipairs(hpTb) do
                    totalHp = totalHp + v
                end
                return totalHp, totalHp
            else
                armyId = self:GetArmyId()
            end
            local pve_power_str = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "pve_power") or ''
            local powerTable = string.split(pve_power_str, '|')
            local totalPower, totalHp = 0, 0
            for _, v in pairs(powerTable) do
                totalPower = totalPower + (tonumber(v) or 0)
            end

            local arm_str = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "arm")
            if string.IsNullOrEmpty(arm_str) then
                return totalPower, totalHp
            end
            
            local armTable = string.split(arm_str, '|')
            for _, str in pairs(armTable) do
                local soliderKV = string.split(str, ';')
                local soldierId =  tonumber(soliderKV[1])
                local soldierNum = tonumber(soliderKV[2])

                local hp = GetTableData(TableName.ArmsTab, soldierId, 'health')
                totalHp = totalHp + hp * soldierNum
            end

            return totalPower, totalHp
        end
    end
end

function PveActorMgr:RefreshHeroSigns()
    self.m_lineup:RefreshHeroSigns()
end

function PveActorMgr:SetHeroSignIcon(index, quality)
    self.m_lineup:SetHeroSignIcon(index, quality)
end

function PveActorMgr:GetStandObj( campType, index )
    return self.m_lineup:GetStandObj( campType, index )
end

function PveActorMgr:GetEmArmyList()
    local armyList = {}
    if self.levelParam~=nil and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        if self.levelParam.rightMonsterId ==0 then
            local list = self.levelParam.rightSoliderList
            if list~=nil then
                for k,v in pairs(list) do
                    local army = {}
                    army.soldierId = k
                    army.soldierNum = v
                    table.insert(armyList, army)
                end
            end
        else
            local monsterId = self.levelParam.rightMonsterId
            local armyId = DataCenter.MonsterTemplateManager:GetTableValue( monsterId, "army")
            local arm_str = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "arm")
            local armTable = string.split(arm_str, '|')

            for _, str in pairs(armTable) do
                local army = {}
                local soliderKV = string.split(str, ';')
                local soldierId =  tonumber(soliderKV[1])
                local soldierNum = tonumber(soliderKV[2])
                army.soldierId = soldierId
                army.soldierNum = soldierNum
                table.insert(armyList, army)
            end
        end

        return armyList
    end
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave then
        if self.m_mailExt and self.m_mailExt._fightRoundList and #self.m_mailExt._fightRoundList > 0 then
            local soldierDic = self.m_mailExt._fightRoundList[1]._otherArmyResult._armyObj._tSoldiers
            for i, v in pairs(soldierDic) do
                local army = {}
                army.soldierId = v.armsId
                army.soldierNum = v.total
                table.insert(armyList, army)
            end
        else
            local armyId = self:GetArmyId()
            local arm_str = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "arm")
            local armTable = string.split(arm_str, '|')

            for _, str in pairs(armTable) do
                local army = {}
                local soliderKV = string.split(str, ';')
                local soldierId =  tonumber(soliderKV[1])
                local soldierNum = tonumber(soliderKV[2])
                army.soldierId = soldierId
                army.soldierNum = soldierNum
                table.insert(armyList, army)
            end
        end
    elseif entranceType == PveEntrance.ArenaSetting then
        
    elseif entranceType == PveEntrance.ArenaBattle then
        local arenaRankInfo = DataCenter.ArenaManager:GetTargetEnemyInfo()
        local tempSoldieres = arenaRankInfo.army.soldiers or {}
        for i, v in ipairs(tempSoldieres) do
            local soldier = {}
            soldier.soldierId = v.armsId
            soldier.soldierNum = v.total
            table.insert(armyList, soldier)
        end
    else
        local armyId = self:GetArmyId()
        local arm_str = GetTableData(PveActorMgr:GetInstance():GetArmyXmlName(), armyId, "arm")
        local armTable = string.split(arm_str, '|')

        for _, str in pairs(armTable) do
            local army = {}
            local soliderKV = string.split(str, ';')
            local soldierId =  tonumber(soliderKV[1])
            local soldierNum = tonumber(soliderKV[2])
            army.soldierId = soldierId
            army.soldierNum = soldierNum
            table.insert(armyList, army)
        end
    end


    return armyList
end

function PveActorMgr:GetMaxHeroNum()
    local maxHeroNum = 0
    local k5 = LuaEntry.DataConfig:TryGetStr("aps_pve_config", "k5")
    local arr = string.split(k5,";")
    local needLv = 100
    if #arr>0 then
        for i = 1,#arr do
            local id = tonumber(arr[i])
            local level = DataCenter.BuildManager.MainLv
            if id~=nil and level ~= nil and id<=level then
                maxHeroNum = maxHeroNum+1
            end
        end
        if maxHeroNum<5 and maxHeroNum+1<= #arr then
            needLv = tonumber(arr[maxHeroNum+1])
        end
    end
    return math.min(maxHeroNum,5),needLv
end

function PveActorMgr:GetCurrentHeroDataList(camp)
    local result = {}
    local heroes = DataCenter.HeroDataManager:GetAllHeroBySort()
    for _, heroData in ipairs(heroes) do
        if camp ~=nil and camp>-1 then
            local targetCamp = GetTableData(HeroUtils.GetHeroXmlName(), heroData.heroId, "camp")
            if targetCamp == camp then
                table.insert(result, heroData.uuid)
            end
        else
            table.insert(result, heroData.uuid)
        end
    end
    return result
end

function PveActorMgr:GetCanAddHero()
    local heroList = self:GetCurrentHeroDataList()
    local maxHeroNum = self:GetMaxHeroNum()
    local curHeroes = PveActorMgr:GetInstance():GetHeros()
    local heroes = {}
    if curHeroes[1] ~= nil then
        for k, v in ipairs(curHeroes) do
            heroes[v.uuid] = v.index
        end
    else
        local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
        for _, v in ipairs(heroArr) do
            heroes[tonumber(v)] = _
        end
    end
    local curHeroNum = table.count(heroes)
    if curHeroNum<5 and curHeroNum<maxHeroNum and curHeroNum<#heroList then
        return true
    end
    return false
end

function PveActorMgr:GetCanAddHeroByHeroId(heroId)
    local canAdd =false
    local has = self:GetCanAddHero()
    if has == true then
        local heroUuid = DataCenter.HeroDataManager:GetHeroUuidByHeroId(heroId)
        if heroUuid ~= 0 then
            canAdd = true
            local curHeroes = PveActorMgr:GetInstance():GetHeros()
            local len = table.count(curHeroes)
            local heroes = {}
            if len>0 then
                table.walk(curHeroes,function(k,v)
                    if v~=nil then
                        heroes[v.uuid] = v.index
                    end
                end)
            else
                local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
                if not table.IsNullOrEmpty(heroArr) ~= "" then
                    for _, v in ipairs(heroArr) do
                        local uuid = tonumber(v)
                        heroes[uuid] = _
                    end
                end
            end
            if heroes[heroUuid]~=nil then
                canAdd = false
            end
        end
    end
    return canAdd
end

function PveActorMgr:IsHeroExistByHeroId(heroId)
    local heroUuid = DataCenter.HeroDataManager:GetHeroUuidByHeroId(heroId)
    if heroUuid ~= 0  then
        local curHeroes = PveActorMgr:GetInstance():GetHeros()
        local len = table.count(curHeroes)
        local heroes = {}
        if len>0 then
            table.walk(curHeroes,function(k,v)
                if v~=nil then
                    heroes[v.uuid] = v.index
                end
            end)
        else
            local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
            if not table.IsNullOrEmpty(heroArr) ~= "" then
                for _, v in ipairs(heroArr) do
                    local uuid = tonumber(v)
                    heroes[uuid] = _
                end
            end
        end
        if heroes[heroUuid] ==nil then
            return true
        end
    end
    return false
end

function PveActorMgr:GetCanAddHeroByHeroRarity(rarity)
    local has = self:GetCanAddHero()
    local list = self:GetCurrentHeroDataList()
    if has then
        local heroes = {}
        local curHeroes = PveActorMgr:GetInstance():GetHeros()
        local len = table.count(curHeroes)
        if len>0 then
            table.walk(curHeroes,function(k,v)
                if v~=nil then
                    heroes[v.uuid] = v.index
                end
            end)
        else
            local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
            if not table.IsNullOrEmpty(heroArr) ~= "" then
                for _, v in ipairs(heroArr) do
                    local uuid = tonumber(v)
                    heroes[uuid] = _
                end
            end
        end
        for i =1 ,#list do
            local uuid = list[i]
            if heroes[uuid] ==nil then
                local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(uuid)
                if tempHeroData.rarity == rarity then
                    return tempHeroData
                end
            end
        end
    end
end

function PveActorMgr:IsHeroExistByHeroRarity(rarity)
    local list = self:GetCurrentHeroDataList()
    local heroes = {}
    local curHeroes = PveActorMgr:GetInstance():GetHeros()
    local len = table.count(curHeroes)
    if len>0 then
        table.walk(curHeroes,function(k,v)
            if v~=nil then
                heroes[v.uuid] = v.index
            end
        end)
    else
        local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
        if not table.IsNullOrEmpty(heroArr) ~= "" then
            for _, v in ipairs(heroArr) do
                local uuid = tonumber(v)
                heroes[uuid] = _
            end
        end
    end
    for i =1 ,#list do
        local uuid = list[i]
        if heroes[uuid] ==nil then
            local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(uuid)
            if tempHeroData.rarity == rarity then
                return tempHeroData
            end
        end
    end
end

--获取未上阵中更高品质的英雄
function PveActorMgr:GetMoreRarityHero()
    local heroes = {}
    local curHeroes = PveActorMgr:GetInstance():GetHeros()
    local minRarity = nil
    if curHeroes[1] ~= nil then
        for k,v in ipairs(curHeroes) do
            heroes[v.uuid] = v.index
            local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(v.uuid)
            if tempHeroData ~= nil and (minRarity == nil or tempHeroData.rarity > minRarity) then
                minRarity = tempHeroData.rarity
            end
        end
    else
        local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
        for _, v in ipairs(heroArr) do
            local uuid = tonumber(v)
            heroes[uuid] = _
            local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(uuid)
            if tempHeroData ~= nil and tempHeroData.rarity > minRarity then
                minRarity = tempHeroData.rarity
            end
        end
    end
    local list = self:GetCurrentHeroDataList()
    local result = nil
    for k,v in ipairs(list) do
        if heroes[v] ==nil then
            local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(v)
            if tempHeroData.rarity < minRarity then
                result = tempHeroData
                minRarity = tempHeroData.rarity
            end
        end
    end
    return result
end


--获取未上阵中最高品质的英雄
function PveActorMgr:GetMostRarityHeroNoInUse()
    local heroes = {}
    local curHeroes = PveActorMgr:GetInstance():GetHeros()
    local minRarity = 999
    if curHeroes[1] ~= nil then
        for k,v in ipairs(curHeroes) do
            heroes[v.uuid] = v.index
        end
    else
        local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
        for _, v in ipairs(heroArr) do
            local uuid = tonumber(v)
            heroes[uuid] = _
        end
    end
    local list = self:GetCurrentHeroDataList()
    local result = nil
    for k,v in ipairs(list) do
        if heroes[v] ==nil then
            local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(v)
            if tempHeroData.rarity < minRarity then
                result = tempHeroData
                minRarity = tempHeroData.rarity
            end
        end
    end
    return result
end


--获取未上阵中更高品质的英雄
function PveActorMgr:IsExistMoreRarityHero()
    return self:GetMoreRarityHero() ~= nil
end

function PveActorMgr:GetRarityMinHero()
    local heroData = nil
    local rarity = 999
    local level = 0
    local heroes = {}
    local curHeroes = PveActorMgr:GetInstance():GetHeros()
    if curHeroes[1] ~= nil then
        for k,v in ipairs(curHeroes) do
            heroes[v.uuid] = v.index
        end
    else
        local heroArr = DataCenter.BattleLevel:GetHeroSelectHistory()
        for _, v in ipairs(heroArr) do
            heroes[tonumber(v)] = _
        end
    end
    for k,v in pairs(heroes) do
        local uuid = k
        local tempHeroData = DataCenter.HeroDataManager:GetHeroByUuid(uuid)
        if rarity == 999 or rarity < tempHeroData.rarity then
            heroData = tempHeroData
            rarity = tempHeroData.rarity
            level = tempHeroData.level
        elseif rarity == tempHeroData.rarity and level>tempHeroData.level then
            heroData = tempHeroData
            rarity = tempHeroData.rarity
            level = tempHeroData.level
        end
    end
    if heroData~=nil then
        return heroData
    end
end

function PveActorMgr:GetArmyDataForHeroExpBattleLevel(heroList)
    local soldierId = LuaEntry.DataConfig:TryGetNum("aps_pve_config", "k1")
    local asPlayerMaxSoldiers = LuaEntry.DataConfig:TryGetNum("building_base", "k5")
    local baseSize = LuaEntry.Effect:GetGameEffect(EffectDefine.APS_FORMATION_SIZE)
    local sizeEnhance = LuaEntry.Effect:GetGameEffect(EffectDefine.APS_FORMATION_SIZE_ENHANCE)
    asPlayerMaxSoldiers = asPlayerMaxSoldiers + math.floor(baseSize+0.5)
    local campAdd= 0
    if heroList~=nil then
        table.walk(heroList,function(k,v)
            local heroData = DataCenter.HeroDataManager:GetHeroByUuid(k)
            if heroData~=nil then
                local config = heroData:GetConfig()
                local rankId = heroData:GetCurMilitaryRankId()
                local armyAdd = HeroUtils.GetArmyLimit(heroData.level, rankId, config['rarity'], heroData.heroId,heroData.quality)
                asPlayerMaxSoldiers = asPlayerMaxSoldiers+armyAdd
                local heroBaseSize = heroData:GetEffectNum(EffectDefine.APS_FORMATION_SIZE)
                local heroSizeEnhance = heroData:GetEffectNum(EffectDefine.APS_FORMATION_SIZE_ENHANCE)
                local campAddEffect = LuaEntry.Effect:GetGameEffect(HeroUtils.GetExtraTroopByCamp(heroData.camp))
                campAdd = campAddEffect+campAdd
                asPlayerMaxSoldiers = asPlayerMaxSoldiers + heroBaseSize
                sizeEnhance = sizeEnhance + heroSizeEnhance
            end
        end)
    end
    local formationIndex = 1
    local finalAddNumByIndex = MarchUtil.GetFormationMaxNumByFormationIndex(formationIndex)
    asPlayerMaxSoldiers = asPlayerMaxSoldiers + finalAddNumByIndex+ campAdd
    asPlayerMaxSoldiers = asPlayerMaxSoldiers*(1+(sizeEnhance/100))
    local campFinalAdd = MarchUtil.GetHeroCampAddArmyCount(HeroUtils.GetHeroIdsByUuids(table.keys(heroList)))
    asPlayerMaxSoldiers = asPlayerMaxSoldiers + campFinalAdd
    local armyData = {}
    armyData[tonumber(soldierId)] = math.floor(asPlayerMaxSoldiers)
    return armyData
end
function PveActorMgr:GetLevelParam()
    return self.levelParam
end

-- 暂存英雄的旧等级和旧经验
function PveActorMgr:SetHeroDataBackup()
    self.heroDataBackup = {}
    for _, v in ipairs(self.m_heroes) do
        local heroUuid = v.uuid
        local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
        if heroData then
            local info = {}
            info["heroId"] = heroData.heroId
            info["oldLevel"] = heroData.level
            info["oldExp"] = heroData.exp
            self.heroDataBackup[heroUuid] = info
        end
    end
end

function PveActorMgr:GetHeroDataBackup()
    return self.heroDataBackup or {}
end

function PveActorMgr:CreateEffectObj(path, pos, duration, showDelay)
    local req = Resource:InstantiateAsync(path)
    req:completed('+', function()
        if req.isError or req.gameObject == nil then
            req:Destroy()
            table.removebyvalue(self.effReqList, req)
            return
        end
        local go = req.gameObject
        go:SetActive(true)
        local tf = go.transform
        tf.position = pos
        TimerManager:GetInstance():DelayInvoke(function()
            if req ~= nil then
                req:Destroy()
                table.removebyvalue(self.effReqList, req)
            end
        end, duration)
    end)
    table.insert(self.effReqList, req)
end

function PveActorMgr:SetModelHeroLv(heroId, heroLv)
    --目前新的战斗逻辑中没有用到，暂时注释掉
    --self.m_modelMgr:SetHeroLv(heroId, heroLv)
end

-- 首回合作用号list， List<{ effectId, value }>
function PveActorMgr:GetBattleEffectList(isLeft)
    local mailExt = self.m_mailExt or self.levelParam.mailExt
    if mailExt then
        local showData = mailExt:GetShowRoundListDataByIndex(1)
        if showData then
            local battleEffect = nil
            if isLeft then
                battleEffect = mailExt:GetMySideBattleEffect(showData.leftUuid)
            else
                battleEffect = mailExt:GetOtherSideBattleEffect(showData.rightUuid)
            end
            if battleEffect then
                return battleEffect:GetList() or {}
            end
        end
    end
    return {}
end

-- 左方阵营加成，作用号额外值（从战报获取）
function PveActorMgr:GetLeftCampBonusExtraVal()
    return MarchUtil.GetCampBonusExtraVal(self:GetHeroIds(), self:GetBattleEffectList(true))
end

-- 右方阵营加成，作用号额外值（从战报获取）
function PveActorMgr:GetRightCampBonusExtraVal()
    return MarchUtil.GetCampBonusExtraVal(self:GetEnemyHeroIds(), self:GetBattleEffectList(false))
end

function PveActorMgr:GetArmyXmlName()
    local configOpenState = LuaEntry.DataConfig:CheckSwitch("army_xml_use_b")
    if configOpenState then
        return TableName.Army_B
    end
    return TableName.Army
end

function PveActorMgr:AddUpdateTimer()
    if self.updateTimer == nil then
        self.updateTimer = function() self:OnUpdate() end
        UpdateManager:GetInstance():AddUpdate(self.updateTimer)
    end
end

function PveActorMgr:RemoveUpdateTimer()
    if self.updateTimer then
        UpdateManager:GetInstance():RemoveUpdate(self.updateTimer)
        self.updateTimer = nil
    end
end

function PveActorMgr:OnUpdate()
    local deltaTime = Time.deltaTime
    if self.m_reportMgr ~= nil then
        self.m_reportMgr:OnUpdate(deltaTime)
    end
    if self.m_reportBattle ~= nil then
        self.m_reportBattle:OnUpdate(deltaTime)
    end
end

function PveActorMgr:CheckEnd()
    if self.m_reportBattle:CheckEnd() then
        self:ShowResult()
    end
end

function PveActorMgr:GetHeroDataList()
    if self.levelParam and self.levelParam.pveEntrance == PveEntrance.BattlePlayBack then
        local mailExt = self.m_mailExt or self.levelParam.mailExt
        if mailExt then
            local heroDict = mailExt:GetHeroDict(true)
            return table.values(heroDict)
        end
    else
        local heroUuids = {}
        for _, v in ipairs(self.m_heroes) do
            table.insert(heroUuids, v.uuid)
        end
        return HeroUtils.GetPveHeroDataListByUuids(heroUuids)
    end
    return {}
end

function PveActorMgr:GetAllHeroObjects()
    return self.m_reportBattle:GetAllHeroObjects()
end

return PveActorMgr