---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wsf.

---
---小队 MemberUnit的集合（新的Parkour Team）
---

local Resource = CS.GameEntry.Resource
local GameObject = CS.UnityEngine.GameObject
local Const = require("Scene.LWBattle.Const")
local HeroUnit = require("Scene.LWBattle.ParkourBattle.Team.HeroUnit")
local WorkerUnit = require("Scene.LWBattle.ParkourBattle.Team.WorkerUnit")
local WeaponUnit = require("Scene.LWBattle.ParkourBattle.Team.WeaponUnit")
local HeroInfo = require "DataCenter.HeroData.HeroInfo"
local fingerDir = Vector3.zero

---@class Scene.LWBattle.ParkourBattle.ParkourTeam
local ParkourTeam = BaseClass("ParkourTeam")
local FSM=require("Framework.Common.FSM")
--跑酷阶段，自动前进，玩家可以操作左右移动
local TeamStateFarm=require("Scene.LWBattle.ParkourBattle.Team.TeamFSM.TeamStateFarm")
--塔防阶段，只能左右移动
local TeamStateDefense = require("Scene.LWBattle.ParkourBattle.Team.TeamFSM.TeamStateDefense")
--boss阶段，万向移动状态，玩家可以操作摇杆移动
local TeamStateBoss=require("Scene.LWBattle.ParkourBattle.Team.TeamFSM.TeamStateBoss")
--退场阶段，自动移动状态，玩家不可以操作移动（路径点模式）
local TeamStateExit=require("Scene.LWBattle.ParkourBattle.Team.TeamFSM.TeamStateExit")
--boss站立攻击阶段，小队不移动，单位自动瞄准攻击
local TeamStateBossStay = require("Scene.LWBattle.ParkourBattle.Team.TeamFSM.TeamStateBossStay")
local ParkourTeamFormation = require("Scene.LWBattle.ParkourBattle.Team.ParkourTeamFormation")

local TeamConfig = {
    Human = {x = 1.5,z = 2,lineUnitNumber = 3,}, --x轴间隔，z轴间隔，每行单位数量上限
    Tank = {x = 2.5,z = 2.6,lineUnitNumber = 3,},
    Worker = {x = 1.5,z = 1.5,lineUnitNumber = 3,},
}
local TeamRowCount = 4

--[1]=Vector3.New(-2.3,0,2.5),
--[2]=Vector3.New(2.3,0,2.5),
--[3]=Vector3.New(-3.3,0,-1.5),
--[4]=Vector3.New(0,0,-1.5),
--[5]=Vector3.New(3.3,0,-1.5),


function ParkourTeam:__init(x,z,logic,defaultHero)
    local go = GameObject("ParkourTeamRoot")
    self.gameObject = go
    self.transform = go.transform
    self.curPos = Vector3.New(x,0,z)
    self:SetPosition(x,z)
    self.logic = logic
    self.moveSpeedDirty = true
    self.moveSpeedZDirty = true
    self.superArmorDirty = true
    self.superArmor = false
    self.isExiting = false
    local hasDefaultHero = not string.IsNullOrEmpty(defaultHero)
    ---@type ParkourTeamFormation
    self.formation = ParkourTeamFormation.New(logic.data and logic.data.specialPos or nil)
    local defense = logic.battleType and logic.battleType == Const.ParkourBattleType.Defense
    self.formation:Init(hasDefaultHero, defense, defense)
    self.teamUnits = {}
    self.teamInitUnitIds = {}   --初始上阵英雄id缓存
    self.teamUnitCount = 0
    self.teamWorkerCount = 0
    self.formationMaxPosCount = self.formation.posCount
    self.qualitySlots = {}
    if hasDefaultHero then
        local heroIds = string.split(defaultHero,"|")
        for _,heroId in ipairs(heroIds) do
            self:AddMember(tonumber(heroId))
        end
    end
    self:InitFSM()
    self.oldZ=0
    self.oldX=0
    self.teamWeapon = nil
end

function ParkourTeam:__delete()
    self:Destroy()
end

function ParkourTeam:Update()
    if self.fsm then
        self.fsm:OnUpdate()
    end
    for _, unit in pairs(self.teamUnits) do
        unit:OnUpdate()
    end
    if self.teamWeapon then
        self.teamWeapon:OnUpdate()
    end
    if self:IsSuperArmor() or self:IsExiting() then
        self:UpdateMemberCollision()
    end
end

function ParkourTeam:Destroy()
    if self.teamUnits then
        for _, unit in pairs(self.teamUnits) do
            self.logic:RemoveUnit(unit.guid)
        end
        self.teamUnits = nil
    end
    if self.teamWeapon then
        self.logic:RemoveUnit(self.teamWeapon.guid)
        self.teamWeapon = nil
    end
    if self.gameObject then
        GameObject.Destroy(self.gameObject);
        self.gameObject = nil
        self.transform = nil
    end
    if self.fsm then
        self.fsm:Delete()
        self.fsm = nil
    end

    self:DestroyQualitySlots()
end

function ParkourTeam:InitFSM()
    self.fsm = FSM.New()--运动状态机
    self.fsm:AddState(Const.ParkourMoveState.Auto,TeamStateExit.New(self))
    
    if self.logic.battleType and self.logic.battleType == Const.ParkourBattleType.Defense then
        --塔防状态
        self.fsm:AddState(Const.ParkourMoveState.LeftRight,TeamStateDefense.New(self))
    else
        self.fsm:AddState(Const.ParkourMoveState.LeftRight,TeamStateFarm.New(self))
    end
    
    self.fsm:AddState(Const.ParkourMoveState.AllDirection,TeamStateBoss.New(self))
    self.fsm:AddState(Const.ParkourMoveState.BossStay, TeamStateBossStay.New(self))
    self.fsm:ChangeState(Const.ParkourMoveState.LeftRight)
end

-----初始化阵型选择编辑------

---@param heroes table<number, HeroInfo>
function ParkourTeam:InitHeroes(heroes, hideQualitySlot)
    --阵型中初始化来的都认为isHuman = true，初始化阵型中最多5个英雄
    for slot, heroData in pairs(heroes) do
        local hero = ObjectPool:GetInstance():Load(HeroUnit)
        hero:Init(self.logic,self, self.transform,Vector3.zero, heroData)
        self.logic:AddUnit(hero)
        self.teamUnits[slot] = hero
        hero:SetSlot(slot)
        self.teamUnitCount = self.teamUnitCount + 1
    end
    
    self:ResetPos()

    if not hideQualitySlot then
        self:RefreshHeroQualitySlot()
    end
end

function ParkourTeam:InitWeapon(weaponData,skillChips)
    if not weaponData then
        return
    end

    local appearanceMetaId = DataCenter.TacticalWeaponManager:GetWeaponAppearance(weaponData.id)
    local appearanceTemplate = DataCenter.AppearanceTemplateManager:GetTemplate(appearanceMetaId)
    local weapon = ObjectPool:GetInstance():Load(WeaponUnit)
    weapon:Init(self.logic,self, self.transform,Vector3.zero,weaponData,appearanceTemplate,skillChips)
    self.logic:AddUnit(weapon)
    self.teamWeapon = weapon
    -- self:ResetPos()
    local pos = self.formation:GetWeaponPos()
    weapon:SetLocalPosition(pos)
    
    self.weaponUnit = weapon

    self.weaponData = weaponData
    self.weaponAppearanceId = appearanceMetaId
end

-------------------------

function ParkourTeam:SaveHero(heroId)
    local heroCfg = self:GenHeroCfg(heroId)
    if not heroCfg then
        Logger.LogError("no hero ",heroId)
        return
    end
    self:RealAddMember(heroCfg)
end


function ParkourTeam:AddMember(heroId)

    local newHeroId = heroId
    if self.logic.GetReplaceAppearance then
        local id = self.logic:GetReplaceAppearance(heroId)
        if id > 0 then
            newHeroId = id
        end
    end
    
    local heroCfg = self:GenHeroCfg(newHeroId)
    if not heroCfg then
        Logger.LogError("no hero ",newHeroId)
        return nil
    end
    return self:RealAddMember(heroCfg)
end

function ParkourTeam:RealAddMember(heroCfg)

    local hero = ObjectPool:GetInstance():Load(HeroUnit)
    hero:Init(self.logic,self, self.transform,Vector3.zero, heroCfg)
    self.logic:AddUnit(hero)
    
    local resetPos = false
    local emptySlot = 0
    local newCount = self.teamUnitCount + 1
    if newCount <= self.formationMaxPosCount then
        --当前阵型数据中还有空位，找空位加入
        for i = 1, self.formationMaxPosCount do
            if self.teamUnits[i] == nil then
                emptySlot = i
                break
            end
        end

        if emptySlot == 0 then
            Logger.LogError("ParkourTeam.RealAddMember find empty slot error !")
            --扩容兼容处理
            self.formation:ReSize(self.formationMaxPosCount + 1)
            self.teamUnitCount = self.formationMaxPosCount
            emptySlot = self.formationMaxPosCount + 1
            self.formationMaxPosCount = self.formation.posCount

            resetPos = true
        end
    else
        --扩容阵型
        self.formation:ReSize(self.formationMaxPosCount + 1)
        emptySlot = self.formationMaxPosCount + 1
        self.formationMaxPosCount = self.formation.posCount

        resetPos = true
    end

    self.teamUnits[emptySlot] = hero
    self.teamUnitCount = self.teamUnitCount + 1

    hero:SetSlot(emptySlot)

    if resetPos then
        self:ResetPos()
    else
        local pos = self.formation:GetOffsetByIndex(emptySlot)
        hero:SetLocalPosition(pos)
    end
    
    return hero
    
end

--增加试用英雄，有技能图标显示，有伤害统计
function ParkourTeam:AddTrialHero(heroId, heroLevel, heroRank)
    local hero = HeroInfo.New()
    hero:UpdateFromTemplate(heroId, heroLevel, heroRank)
    hero.uuid = DataCenter.LWBattleManager:GetTmpHeroUuid()
    
    local unit = self:RealAddMember(hero)
    self.logic:AddTrialHero(hero)
    table.insert(self.teamInitUnits, unit)
end

function ParkourTeam:GenHeroCfg(heroId)
    local hero = HeroInfo.New()
    hero:UpdateFromTemplate(heroId,1)
    return hero
end

function ParkourTeam:RemoveMemberWithoutUnit(hero)
    if self:GetMemberCount()<1 or not hero then
        Logger.LogError("No member can be removed!")
        return
    end
    if self.logic.state==Const.ParkourBattleState.PreExit or self.logic.state==Const.ParkourBattleState.Exit then
        return
    end
    Logger.Log("Remove team member "..hero.guid)

    local slot = 0;
    for index, unit in pairs(self.teamUnits) do
        if unit == hero then
            slot = index
            break
        end
    end

    if slot > 0 then
        self.teamUnits[slot] = nil
        self.teamUnitCount = self.teamUnitCount - 1
    else
        Logger.LogError("ParkourTeam.RemoveMember error ! guid:".. hero.guid)
    end

end

function ParkourTeam:RemoveMember(hero)
    if self:GetMemberCount()<1 or not hero then
        Logger.LogError("No member can be removed!")
        return
    end
    if self.logic.state==Const.ParkourBattleState.PreExit or self.logic.state==Const.ParkourBattleState.Exit then
        return
    end
    Logger.Log("Remove team member "..hero.guid)
    hero.curBlood=0
    
    local tbl = {}
    tbl.heroId = hero.hero.heroId
    tbl.curBlood = hero.curBlood
    tbl.maxBlood = hero.maxBlood
    EventManager:GetInstance():Broadcast(EventId.PveHeroHpUpdate, tbl)
    
    self.logic:RemoveUnit(hero.guid)
    
    local slot = 0;
    for index, unit in pairs(self.teamUnits) do
        if unit == hero then
            slot = index
            break
        end
    end

    if slot > 0 then
        self.teamUnits[slot] = nil
        self.teamUnitCount = self.teamUnitCount - 1
    else
        Logger.LogError("ParkourTeam.RemoveMember error ! guid:".. hero.guid)
    end
    
end


function ParkourTeam:ResetPos()
    for slotIndex, unit in pairs(self.teamUnits) do
        if unit ~= nil then
            local pos = self.formation:GetOffsetByIndex(slotIndex)
            unit:SetLocalPosition(pos)
        end
    end
    if self.teamWeapon then
        local pos = self.formation:GetWeaponPos()
        self.teamWeapon:SetLocalPosition(pos)
    end
end

function ParkourTeam:GetMemberCount()
    return self.teamUnitCount - self.teamWorkerCount
end

function ParkourTeam:SetPosition(x,z)
    self.curPos.x=x
    self.curPos.z=z
    self.transform:Set_position(x,0,z)

    if self.weaponUnit then
        self.weaponUnit:UpdateRelativePosition(x, z)
    end
end

function ParkourTeam:GetPosition()
    return self.curPos
end

function ParkourTeam:GetPositionZ()
    return self.curPos.z
end


function ParkourTeam:MoveHorizontalTo(x)
    self.fsm:ChangeState(Const.ParkourMoveState.LeftRight,x)
end

function ParkourTeam:OnFingerDown(pos)
    --self.fsm:HandleInput(Const.ParkourInput.FingerDown,pos)
    for _, unit in pairs(self.teamUnits) do
        unit:OnFingerDown(fingerDir)
    end
end
function ParkourTeam:OnFingerUp()
    self.fsm:HandleInput(Const.ParkourInput.FingerUp)
    for _, unit in pairs(self.teamUnits) do
        unit:OnFingerUp(fingerDir)
    end
end
function ParkourTeam:OnFingerHold(x,z)

    --控制移动
    local oldPos = self:GetPosition()
    local distance = self:GetMoveSpeed() * Time.deltaTime
    --Logger.Log("移动："..x..","..z..","..distance)
    local deltaX = x * distance
    local deltaZ = z * distance
    local newX = oldPos.x + deltaX
    local newZ = oldPos.z + deltaZ
    if self.logic.data:Contains(newX,newZ) then
        self:SetPosition(newX,newZ)
    elseif self.logic.data:Contains(oldPos.x,newZ) then
        self:SetPosition(oldPos.x,newZ)
    elseif self.logic.data:Contains(newX,oldPos.z) then
        self:SetPosition(newX,oldPos.z)
    end

    --控制旋转
    if x==0 and z==0 then
        return
    end
    if math.abs(self.oldX-x)>0.01 or math.abs(self.oldZ-z)>0.01 then
        fingerDir.x = oldPos.x + x * 1024
        fingerDir.z = oldPos.z + z * 1024
        for _, unit in pairs(self.teamUnits) do
            unit:OnFingerHold(fingerDir)
        end
        --Logger.LogError("xz")
    end
    self.oldX=x
    self.oldZ=z
end

function ParkourTeam:SetActive(isOn)
    if  self.gameObject then
        self.gameObject:SetActive(isOn)
    end
end

function ParkourTeam:GetMoveSpeedZ()
    if not self.moveSpeedZDirty then
        return self.finalSpeedZ
    end
    self.moveSpeedZDirty = false
    local addValue = 0
    for _, unit in pairs(self.teamUnits) do
        local bfValue = unit:GetProperty(HeroEffectDefine.BattleHeroMoveSpeed)
        if bfValue > 0 then
            addValue =  self.speedZ * bfValue
            break
        end
    end
    self.finalSpeedZ =  self.speedZ + addValue
    return self.finalSpeedZ
end

function ParkourTeam:IsSuperArmor()
    if not self.superArmorDirty then
        return self.superArmor
    end
    local oldValue = self.superArmor
    self.superArmorDirty = false
    self.superArmor = false
    for _,unit in pairs(self.teamUnits) do
        local buff = unit.buffManager:GetPropertyBuff(HeroEffectDefine.SuperArmor)
        if buff > 0 then
            self.superArmor = true
            break
        end
    end
    if oldValue ~= self.superArmor then
        self:SetInvincible(self.superArmor)--狂飙时无敌
        EventManager:GetInstance():Broadcast(EventId.SquadSuperArmorStateChange)
    end
    return self.superArmor
end

function ParkourTeam:UpdateMemberCollision()
    for _,member in pairs(self.teamUnits) do
        if member.unitType~=UnitType.Plot then
            if not member.colliderComponent then
                local collision = function (colliderCnt, colliderComponentArray)
                    self:OnCollision(colliderCnt, colliderComponentArray)
                end
                member:InitColliderComponent(LayerMask.GetMask("Zombie")|LayerMask.GetMask(LayerType.Junk),collision)
            end
            if member.colliderComponent then
                member.colliderComponent:CollisionDetect()
            end
        end
    end
end

function ParkourTeam:OnCollision(colliderCnt, colliderComponentArray )
    for i = 0, colliderCnt-1, 1 do
        self:Hit(colliderComponentArray[i])
    end
end

local HitDamageCD = 100 --霸体伤害对单位伤害cd
local deathEffPath = "Assets/_Art/Effect_B/Prefab/Common/Eff_shiti_boom.prefab"
function ParkourTeam:Hit(otherObj)
    local now = UITimeManager:GetInstance():GetServerTime()
    local trigger = otherObj:GetComponent(typeof(CS.CitySpaceManTrigger))
    if trigger~=nil and trigger.ObjectId~=0 then
        local tar = self.logic:GetUnit(trigger.ObjectId)
        if tar and (tar.curBlood or 0) > 0 and now - (tar.lastHitTime or 0) > HitDamageCD then
            tar.lastHitTime = now
            --伤害
            --击退
            local hurt = 1
            local hitPoint = tar:GetPosition()
            local hitDir = nil
            local whiteTime = 0.2
            local stiffTime = 0
            local hitBackDistance = nil
            local hitEff = nil

            if tar.meta.crash_kill > 0 then
                hurt = tar.maxBlood * (tar.meta.crash_kill / 100)
            else
                return
            end

            if hurt < tar.curBlood then
                hitBackDistance = Vector3.Normalize(hitPoint - self:GetPosition()) * 10
            end
            local m_deathEffPath = deathEffPath
            if tar.meta.monster_type == Const.MonsterType.Junk then
                m_deathEffPath = nil
            end
            tar:BeAttack(hurt,hitPoint,hitDir,whiteTime,stiffTime,hitBackDistance,hitEff)
            tar:AfterBeAttack(hurt,hitPoint,hitDir,whiteTime,stiffTime,hitBackDistance,hitEff,nil,m_deathEffPath,true)
            --self.logic.damageTextMgr:GenText(hurt,hitPoint,Const.DamageTextStyle.BeAttack,DamageType.Physics,false)

            if tar.meta.is_boss == 1 then
                --震屏
                local p = {}
                p.duration = 0.5
                p.strength = Vector3.New(1, 1, 0)
                p.vibrato = 20
                self.logic:ShakeCameraWithParam(p)
            end
        end
    end
end

function ParkourTeam:AddWorker(workerId)
    local workerCfg = LocalController:instance():getLine(TableName.LW_Worker,tonumber(workerId))
    if not workerCfg then
        Logger.LogError("no worker Config ",workerId)
        return
    end

    local worker = ObjectPool:GetInstance():Load(WorkerUnit)
    worker:Init(self.logic,self, self.transform,Vector3.zero,workerCfg)
    self.logic:AddUnit(worker)
    self.logic:OnWorkerSave()
    self.teamWorkerCount = self.teamWorkerCount + 1


    local resetPos = false
    local emptySlot = 0
    local newCount = self.teamUnitCount + 1
    if newCount <= self.formationMaxPosCount then
        --当前阵型数据中还有空位，找空位加入
        for i = 1, self.formationMaxPosCount do
            if self.teamUnits[i] == nil then
                emptySlot = i
                break
            end
        end

        if emptySlot == 0 then
            Logger.LogError("ParkourTeam.AddWorker find empty slot error !")
            --扩容兼容处理
            self.formation:ReSize(self.formationMaxPosCount + 1)
            self.teamUnitCount = self.formationMaxPosCount
            emptySlot = self.formationMaxPosCount + 1
            self.formationMaxPosCount = self.formation.posCount

            resetPos = true
        end
    else
        --扩容阵型
        self.formation:ReSize(self.formationMaxPosCount + 1)
        emptySlot = self.formationMaxPosCount + 1
        self.formationMaxPosCount = self.formation.posCount

        resetPos = true
    end

    self.teamUnits[emptySlot] = worker
    self.teamUnitCount = self.teamUnitCount + 1

    if resetPos then
        self:ResetPos()
    else
        local pos = self.formation:GetOffsetByIndex(emptySlot)
        worker:SetLocalPosition(pos)
    end
    
end

function ParkourTeam:IsExiting()
    return self.logic.state==Const.ParkourBattleState.Exit
end

function ParkourTeam:ChangeStage(stage)
    if stage == Const.ParkourBattleState.Boss then
        self.fsm:ChangeState(Const.ParkourMoveState.AllDirection)
    elseif stage == Const.ParkourBattleState.BossStay then
        self.fsm:ChangeState(Const.ParkourMoveState.BossStay)
    elseif stage == Const.ParkourBattleState.BossHorizontal then
        self.fsm:ChangeState(Const.ParkourMoveState.LeftRight, self:GetPosition().x)
    elseif stage == Const.ParkourBattleState.Exit then
        --路径点模式
        --local destinationQueue = {}
        --table.insert(destinationQueue,Vector3.New(Const.ParkourSceneCenter,0,10000))
        --local curPos = self:GetPosition()
        --table.insert(destinationQueue,Vector3.New(Const.ParkourSceneCenter,0,curPos.z))
        --self.fsm:ChangeState(Const.ParkourMoveState.Auto,destinationQueue)
        --贝塞尔曲线
        local curPos = self:GetPosition()
        local controlPoint1 = curPos
        local controlPoint2 = Vector3.New(Const.ParkourSceneCenter,0,curPos.z+EXIT_CTRL_POINT_OFFSET)
        local controlPoint3 = Vector3.New(Const.ParkourSceneCenter,0,
                curPos.z+EXIT_CTRL_POINT_OFFSET+math.abs(Const.ParkourSceneCenter-curPos.x))
        self.fsm:ChangeState(Const.ParkourMoveState.Auto,controlPoint1,controlPoint2,controlPoint3)
    end
    for _, unit in pairs(self.teamUnits) do
        unit:ChangeStage(stage)
    end
    if self.teamWeapon then
        self.teamWeapon:ChangeStage(stage)
    end
end


function ParkourTeam:GetMoveSpeed()
    if self.moveSpeed and not self.moveSpeedDirty then
        return self.moveSpeed
    end
    self.moveSpeed=99
    self.moveSpeedDirty=false
    for _,member in pairs(self.teamUnits) do--小队速度=最慢的成员的速度
        local speed=member:GetMoveSpeed()
        self.moveSpeed = self.moveSpeed > speed and speed or self.moveSpeed
    end
    return self.moveSpeed
end

function ParkourTeam:ReturnMemberPositions()
    local pos = {}
    for i = 1, 5 do
        local offset = self.formation:GetOffsetByIndex(i)
        local worldPos = self.transform:TransformPoint(offset)
        table.insert(pos, worldPos)
    end
    return pos
end

function ParkourTeam:ChangeHeroes(heroes)

    if self.teamUnits then
        for _, unit in pairs(self.teamUnits) do
            self.logic:RemoveUnit(unit.guid)
            unit:DestroyData()
        end
    end
    -- if self.teamWeapon then
    --     self.logic:RemoveUnit(self.teamWeapon.guid)
    --     self.teamWeapon:DestroyData()
    --     self.teamWeapon = nil
    -- end

    self.teamUnits = {}

    self.teamUnitCount = 0
    self.teamWorkerCount = 0
    
    self:InitHeroes(heroes)
    -- self:InitWeapon()
end

function ParkourTeam:ResetHeroPosition()
    self:ResetPos()
end

function ParkourTeam:SetHeroPosition(index, worldPos)
    for slot, unit in pairs(self.teamUnits) do
        if index == slot then
            unit:SetPosition(worldPos)
        end
    end
end

function ParkourTeam:MoveHeroToIndex(index, dstIndex, time)
    for slot, unit in pairs(self.teamUnits) do
        if slot == index then
            local localPos = self.formation:GetOffsetByIndex(dstIndex)
            unit:MoveToLocalPos(localPos, time)
        end
    end
end

function ParkourTeam:OnStartBattle(changeFormation)
    self:DestroyQualitySlots()

    self.teamInitUnitIds = {}
    self.teamInitUnits = {}
    for _, unit in pairs(self.teamUnits) do
        if unit.hero then
            if (not unit.hero.fromTemplate) then
                --这里先过滤掉试用英雄，teamInitUnitIds目前主要用于触发门
                table.insert(self.teamInitUnitIds, unit.hero.uuid)
            end
            table.insert(self.teamInitUnits, unit)
        end
    end

    self.formation:ChangeToBattleFormation()
    if changeFormation then
        for slot, unit in pairs(self.teamUnits) do
            local localPos = self.formation:GetOffsetByIndex(slot)
            unit:MoveToLocalPos(localPos, 0.5)
        end
        if self.teamWeapon then
            local pos = self.formation:GetWeaponPos()
            self.teamWeapon:MoveToLocalPos(pos, 0.5)
        end
    end
end

function ParkourTeam:DestroyQualitySlots()
    for _,v in pairs(self.qualitySlots) do
        if not IsNull(v) then
            CS.UnityEngine.GameObject.Destroy(v.gameObject)
        end
    end
end

function ParkourTeam:RefreshHeroQualitySlot()
    if table.IsNullOrEmpty(self.qualitySlots) then
        for i = 1, 5 do
            local obj =CS.UnityEngine.GameObject( "QualitySlot"..i)
            obj.transform:SetParent(self.transform,false)
            local offset = self.formation:GetOffsetByIndex(i)
            offset.y = 0.2
            obj.transform:Set_localEulerAngles(90,0, 0)
            obj.transform.localPosition = offset
            obj.transform.localScale = Vector3.New(1.5,1.5,1)
            local sprite = obj:AddComponent(typeof(CS.UnityEngine.SpriteRenderer))
            table.insert(self.qualitySlots, sprite)
        end
    end

    for i = 1, 5 do
        local sprite = self.qualitySlots[i]
        if not IsNull(sprite) then
            local icon
            if not table.IsNullOrEmpty(self.teamUnits) then
                local hasHero = self.teamUnits[i] ~= nil
                if hasHero then
                    local rarity = self.teamUnits[i].hero.rarity
                    icon = string.format(LoadPath.UIPve, "pve_img_rarity_" .. rarity)
                else
                    icon = string.format(LoadPath.UIPve, "pve_img_rarity_5")
                end
            else
                icon = string.format(LoadPath.UIPve, "pve_img_rarity_5")
            end
            sprite:LoadSprite(icon)
        end
    end
end

function ParkourTeam:ChangeWeaponSkillChips(skillChips)
    if self.teamWeapon then
        self.teamWeapon:ChangeSkillChips(skillChips)
    end
end


return ParkourTeam
