---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mac.
--- DateTime: 2022/10/11 5:00 下午
---
-- 辅助类 [ 杂类 ]
local Const = require("Scene.PVEBattleLevel.Const")
local GameObject = CS.UnityEngine.GameObject
local ResourceManager = CS.GameEntry.Resource

local SU_Util = {}

--[[
    根据资源类型找到资源飞到的最终位置
]]
SU_Util.GetRewardFlyPos = function( rewardType )
    local battle = DataCenter.BattleLevel
    if battle ~= nil and battle.uiPveMain ~= nil then
        local resType = RewardToResType[rewardType]
        if resType ~= nil then
            local pveRes = Const.ResourceTypeToResType[resType]
            if pveRes ~= nil then
                local obj = battle.uiPveMain:GetFlyNode(pveRes)
                if obj then
                    return obj.transform.position
                end
            end
        else
            local pos = battle.uiPveMain:GetFlyPosByRewardType(rewardType)
            if pos ~= nil then
                return pos
            end
        end
    end
    local flyPosPath = Const.FlyPosPath[rewardType]
    if flyPosPath then
        local obj = CS.UnityEngine.GameObject.Find(flyPosPath)
        if obj then
            return obj.transform.position
        end
    end

    local obj = GameObject.Find(Const.FlyPosDefaultPath)
    if obj then
        return obj.transform.position
    end
    return Vector3.zero
end

SU_Util.WorldToScreenPoint = function( worldPos )
    local bl = DataCenter.BattleLevel
    if bl then
        local camera = bl:GetCamera()
        if camera then
            return camera:WorldToScreenPoint( worldPos )
        end
    end
    return Vector2.New(0, 0)
end

SU_Util.GetAngle = function(pos1,pos2)
    local dx = pos1.x - pos2.x
    local dz = pos1.z - pos2.z
    local angle = Mathf.Atan2(dx, dz)

    return angle * 180 / Mathf.PI + 180
end
--生成同心圆的某一个点
--pos 中心点
--range 同心圆半径
--range1 同心圆内径，不会在这个范围内生成点
--outPosition 为了避免频繁调用产生过多新对象，这里可以外部传入一个固定对象
SU_Util.GenerateConcentricPosition = function(pos, range, range1, outPosition)
    range1 = range1 or 1
    outPosition = outPosition or {}
    outPosition.x = pos.x
    outPosition.y = pos.y
    outPosition.z = pos.z

    local vec = CS.UnityEngine.Random.insideUnitCircle * (range - range1)
    local pos1 = vec.normalized * (range1 + vec.magnitude)
    outPosition.x = outPosition.x + pos1.x
    outPosition.y = 0
    outPosition.z = outPosition.z + pos1.y

    return outPosition
end


-- 根据参数播放资源的各种特效
function SU_Util.PlayResourceEffect(...)
	
	-- 树的特效
	-- Assets/_Art_LastDay/Effect/Prefab/Eff_songshu_lv.prefab
	-- Assets/_Art_LastDay/Effect/Prefab/Eff_songshu_huang.prefab
	
end

local levelId_map = {}

-- FIXME: 这里要把server加上
function SU_Util.GetItemConfig(levelId, subKey)
	levelId = levelId or 0
	local strLevel
	if levelId_map[levelId] then
    	strLevel = levelId_map[levelId]
	else
		strLevel = "level_" .. levelId
		levelId_map[levelId] = strLevel
	end
	
    local _result = DataCenter.ItemConfig:GetValue(strLevel, subKey)
    if (string.IsNullOrEmpty(_result)) then
        return DataCenter.ItemConfig:GetValue("level_0", subKey)
    end
    return _result
end

function SU_Util.GetLevel0Config(subKey)
	return DataCenter.ItemConfig.GetValue("level_0", subKey)
end

function SU_Util.GetCurItemConfig(subKey)
    local _levelId = DataCenter.BattleLevel:GetLevelId()
    return SU_Util.GetItemConfig(_levelId, subKey)
end

-- 是否有某个配置项
function SU_Util.HasItemConfig(levelId, subKey)
	levelId = levelId or 0
	local strLevel
	if levelId_map[levelId] then
		strLevel = levelId_map[levelId]
	else
		strLevel = "level_" .. levelId
		levelId_map[levelId] = strLevel
	end

	return DataCenter.ItemConfig:HasItem(strLevel, subKey)
end

function SU_Util.IsSplitLevel(levelId)
    if (tonumber(levelId) == 10001 or 
        tonumber(levelId) == 10002 or
        tonumber(levelId) == 10003 or
        tonumber(levelId) == 10004 ) then
        return false
    end
    return true
end

--[[
    返回当前存在的路径 pvelevel/pve_download,
    判定pvelevel不存在的情况下,直接返回pve_download
    为什么这么做,他其实就是在这两个文件夹下。判断其中一个,默认返回另一个.在 直接加载 或者 判定文件存不存在的时候也可以直接使用，进行下一步的处理
]]
function SU_Util.GetExistResPath(path1, path2)
    if ResourceManager:IsAssetDownloaded(path1) then
        return path1
    end
    return path2
end

--[[
    返回当前存在的路径 pvelevel/pve_download,
    判定pvelevel不存在的情况下,直接返回pve_download
    为什么这么做,他其实就是在这两个文件夹下。判断其中一个,默认返回另一个.在 直接加载 或者 判定文件存不存在的时候也可以直接使用，进行下一步的处理
]]
function SU_Util.GetExistResPath(path1, path2)
    if ResourceManager:IsAssetDownloaded(path1) then
        return path1
    end
    return path2
end

function SU_Util.IsLevelDownloaded(levelId)
    local pveTemplate = DataCenter.PveLevelTemplateManager:GetTemplate(levelId)
    local scenePrefabName = pveTemplate.scene
    -- 首先判定pve_download下
    local assetPath = string.format(Const.PVEScenePath, scenePrefabName)
    local hasAsset = ResourceManager:IsAssetDownloaded(assetPath)
    if hasAsset then return true end
    -- 再次检测pvelevel下
    assetPath = string.format(Const.PVEScenePath2, scenePrefabName)
    hasAsset = ResourceManager:IsAssetDownloaded(assetPath)
    return hasAsset, assetPath
end

function SU_Util.ChangeToLevel(pveId, areaId)
    local function callback()
        local k5 = LuaEntry.DataConfig:TryGetNum("c_initial_Parameter", "k5")
        local emptySlotCount = DataCenter.BagGridDataManager:GetPlayerPocketData():GetEmptySlotCount()
        if k5 >= emptySlotCount and pveId ~= LevelId.Main then
            UIUtil.ShowMessage(820459, 2, 820457, 820458,
                    function() SFSNetwork.SendMessage(MsgDefines.SU_AreaStart, areaId) end,
                    function() BagUtil.OnClickOrganizeBag() end)
        else
            SFSNetwork.SendMessage(MsgDefines.SU_AreaStart, areaId)
        end
    end
    
    local hasAsset, assetPath = SU_Util.IsLevelDownloaded(pveId)
    if hasAsset then
        callback()
    else
        UIManager:GetInstance():OpenWindow(UIWindowNames.UIDownloadProgress, { anim = false }, assetPath, function(ret)
            if ret then
                callback()
            end
        end)
    end
end

--[[ 获取当前点击的坐标 ]]


--旋转后的坐标点
function SU_Util.RotationPoint(originPoint,targetPosition,angle,arc)
    angle = (angle - 90) % 360
    angle = 360 - angle
    angle = angle - arc / 2
    local radius = Vector3.Distance(originPoint,targetPosition)
    return Vector3.Add(SU_Util.PolarToCartesian(angle,radius),originPoint)
end

function SU_Util.PolarToCartesian(angle,length)
    return Vector3.New(Mathf.Cos(angle * Mathf.Deg2Rad), 0, Mathf.Sin(angle * Mathf.Deg2Rad)) * length
end

return SU_Util