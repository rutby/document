---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2022/9/27 17:54
---僵尸AI逻辑类，搜寻目标、控制行为都写在这里
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local ZombieBaseAI = require("Scene.PVEBattleLevel.Character.AI.ZombieBaseAI")
local ZombieAI = BaseClass("ZombieAI",ZombieBaseAI)
local Util = require("Scene.PVEBattleLevel.Utils.SU_Util")

local StateType = {
    AttackState = "AttackState",            --攻击状态
    SkillState = "SkillState",              --技能状态
    PatrolState = "PatrolState",            --巡逻状态
    GoBackState = "GoBackState",            --返回状态
    VigilanceState = "VigilanceState"       --警觉状态
}

ZombieAI.StateType = StateType

local targetPosition = {}

function ZombieAI:__init(owner)
    ZombieBaseAI.__init(self,owner)
    self.attackRadius = self.m_owner:GetAttackRange()
    self.skillOrder = self.m_owner:GetSkillOrder()
    self.hpGroup = self.m_owner:GetHpStage()
    self.currentSkillIndex = 1
    self.useSkill = false
    self.skillRadius = 0
    
    self.patrolRadius = self.m_owner:GetPatrolRadius()
    self.patrolTimeInterval = self.m_owner:GetPatrolIntervalTime()
    self.newChaseRadius = self.m_owner.info:GetNewChaseRadius()
end

function ZombieAI:__initState()
    ZombieBaseAI.__initState(self)
    self.m_states:AddState(StateType.AttackState,self.AttackTarget_Enter, self.AttackTarget_Update)
    self.m_states:AddState(StateType.SkillState,self.Skill_Enter)
    self.m_states:AddState(StateType.PatrolState, self.Patrol_Enter, self.Patrol_Update, self.Patrol_Exit)
    self.m_states:AddState(StateType.GoBackState, self.GoBack_Enter, self.GoBack_Update, self.GoBack_Exit)
    self.m_states:AddState(StateType.VigilanceState, self.Vigilance_Enter, self.Vigilance_Update, self.vigilance_Exit)
end

function ZombieAI:Start()
    ZombieBaseAI.Start(self)
    self:CheckSkill()
    if self:CanPatrol() then
        self.m_states:SetState(StateType.PatrolState)
    end
end

function ZombieAI:Vigilance_Enter()
    --Logger.LogError("进入警戒模式")
    self.m_owner:Vigilance(true)
    --显示一下问号
    --self.m_owner:ShowWarningIcon()
end

function ZombieAI:Vigilance_Update(deltaTime)
    if self.m_target and self.m_target:GetCurBlood() > 0 then
        local ownerPos = self.m_owner:GetPosition()
        local targetPos = self.m_target:GetPosition()
        local dis = Vector3.Distance(ownerPos,targetPos) - self:GetModelRadius() - self.m_owner:GetModelRadius()
        if dis <= self.newChaseRadius then
            --Logger.LogError("开始追击")
            self.m_states:SetState(ZombieBaseAI.StateType.MoveState)
            --显示一下感叹号
            self.m_owner:ShowDangerIcon()
            --播放吼叫动画，这个还没有
            --进入警觉状态播放吼叫声音"find"
            local info = self.m_owner.info
            if info ~= nil then
                local modelName = info:GetModelName()
                if modelName ~= nil then
                    --SUSoundUtil.PlayActorActionSound(modelName,"find")
                end
            end
        elseif self:CheckDisengageDistance(dis) or self:CheckMoveRange(ownerPos) then
            --丢失目标
            self.m_target = nil
            self.m_states:SetState(StateType.GoBackState)
        else
            self.m_owner:MovePath(targetPos)
        end
    else
        self.m_target = nil
        self.m_states:SetState(StateType.GoBackState)
    end
end

function ZombieAI:vigilance_Exit()
    self.m_owner:Vigilance(false)
end

function ZombieAI:GoBack_Enter()
    self.m_owner:GoBack(true)
    self.m_owner:MovePath(self.m_owner.spawnPos,function()
        if self:CanPatrol() then
            self.m_states:SetState(StateType.PatrolState)
        else
            self.m_states:SetState(ZombieBaseAI.StateType.FindTargetState)
        end
    end)
end

function ZombieAI:GoBack_Update(deltaTime)
    --if not self:CheckMoveRange() then
    --    self.m_target = self:SearchEnemyTarget()
    --    if self.m_target then
    --        self.m_states:SetState(ZombieBaseAI.StateType.MoveState)
    --    end
    --end
end

function ZombieAI:GoBack_Exit()
    self.m_owner:GoBack(false)
end

function ZombieAI:Patrol_Enter()
    local pos = self.m_owner:GetPosition()
    self.originPos = {x = pos.x,y = pos.y,z = pos.z}
    self.patrolling = false
    self.checkPatrolTime = 0
    self.m_owner:Patrol(true)
end

function ZombieAI:Patrol_Update(deltaTime)
    self.m_target = self:SearchEnemyTarget()
    if self.m_target then
        if self:CanVigilance() then
            self.m_states:SetState(StateType.VigilanceState)
        else
            self.m_states:SetState(ZombieBaseAI.StateType.MoveState)
        end
    else
        self:CheckPatrol(deltaTime)
    end
end

function ZombieAI:CheckPatrol(deltaTime)
    if not self.patrolling then
        self.checkPatrolTime = self.checkPatrolTime + deltaTime
        if self.checkPatrolTime >= self.patrolTimeInterval then
            self.patrolling = true
            self.checkPatrolTime = 0
            Util.GenerateConcentricPosition(self.originPos,self.patrolRadius,1,targetPosition)
            self.m_owner:MovePath(targetPosition)
        end
    end
end

function ZombieAI:Patrol_Exit()
    self.originPos = nil
    self.patrolling = false
    self.checkPatrolTime = 0
    self.m_owner:Patrol(false)
end

function ZombieAI:Move_Enter()
    self.m_checkTime = 0
end

function ZombieAI:Move_Update(deltaTime)
    self.m_checkTime = self.m_checkTime + deltaTime
    if self.m_checkTime  > 0.2 or self.m_target == nil or self.m_target:GetCurBlood() <= 0 then
        self.m_checkTime = 0
        local target = self:SearchEnemyTarget()
        if target ~= nil then
            self.m_target = target
        end
    end

    if self.m_target and self.m_target:GetCurBlood() > 0 then
        local ownerPos = self.m_owner:GetPosition()
        local targetPos = self.m_target:GetPosition()
        local dis = Vector3.Distance(ownerPos,targetPos) - self:GetModelRadius()
        if dis <= self:GetAttackRadius() then
            if self.useSkill then
                self.m_states:SetState(StateType.SkillState)
            else
                self.m_states:SetState(StateType.AttackState)
            end
        elseif self:CheckDisengageDistance(dis) or self:CheckMoveRange(ownerPos) then
            --丢失目标
            self.m_target = nil
            self.m_states:SetState(StateType.GoBackState)
        else
            self.m_owner:MovePath(targetPos)
        end
    else
        self.m_target = nil
        self.m_states:SetState(StateType.GoBackState)
    end
end

function ZombieAI:IsLockedPlayer()
    if self.m_target and self.m_target:GetCurBlood() > 0 then
        return true
    end
    return false
end
--是否可以暂停
function ZombieAI:CanPause()
    if self:IsLockedPlayer() or self.m_states:CurrentStateEqual(StateType.GoBackState) then --返回的路上不能被暂停
        return false
    end
    return true
end

function ZombieAI:AttackTarget_Enter()
    if self.m_target and self.m_target:GetCurBlood() > 0 then
        self.m_owner:Attack(self.m_target)
    end
    self.m_owner:StopAttack() --取消循环攻击，变成单次攻击，支持技能组来控制攻击频率和类型
end
--子类有复写
function ZombieAI:AttackTarget_Update(deltaTime)
end

function ZombieAI:CheckSkill()
    self.useSkill = false
    local skillLength = #self.skillOrder
    if skillLength > 0 then
        local currentHpPercent = self.m_owner:GetCurBlood() / self.m_owner:GetMaxBlood() * 100
        local minHp = 0
        local maxHp = 0
        local skillGroupIndex = 1
        for i,v in ipairs(self.hpGroup) do
            maxHp = tonumber(v[1])
            minHp = tonumber(v[2])
            if currentHpPercent >= minHp and currentHpPercent <= maxHp then
                skillGroupIndex = i
                break
            end
        end
        if skillGroupIndex <= skillLength then
            local skillGroup = self.skillOrder[skillGroupIndex]
            self.currentSkillIndex = self.currentSkillIndex > #skillGroup and 1 or self.currentSkillIndex
            local skillId = tonumber(skillGroup[self.currentSkillIndex])
            if not string.IsNullOrEmpty(skillId) and skillId ~= PveSkillId.NormalAttack then
                self.useSkill = true
                self.skillId = skillId
                self.skillRadius = tonumber(GetTableData(TableName.SU_PveSkill, skillId, 'range'))
            end
        end
    end
end

function ZombieAI:Skill_Enter()
    self.m_owner:Skill(self.skillId,self.m_target)
end

function ZombieAI:GetAttackRadius()
    if self.useSkill then
        return self.skillRadius
    end
    return self.attackRadius
end

function ZombieAI:GetModelRadius()
    if self.useSkill then
        return 0 --技能范围很多不规则的，如果算人物半径还得算最近的点，比较麻烦，在释放技能范围的时候先不考虑人物半径
    end
    return self.m_target:GetModelRadius()
end
--玩家是否出了逃脱范围
function ZombieAI:CheckDisengageDistance(dis)
    local disengageDistance = self.m_owner:GetDisengageDistance()
    return disengageDistance > 0 and dis > disengageDistance
end

function ZombieAI:CheckMoveRange(ownerPos)
    local moveRange = self.m_owner:GetMoveRange()
    if moveRange > 0 then
        local dis = Vector3.Distance(ownerPos,self.m_owner.spawnPos)
        return dis > moveRange
    end
    return false
end
--是否需要警觉
function ZombieAI:CanVigilance()
    return true
end
--是否可以巡逻
function ZombieAI:CanPatrol()
    return self.patrolRadius > 0 and self.patrolTimeInterval > 0
end
--是否在返回出生点
function ZombieAI:IsGoBack()
    return self.m_states:CurrentStateEqual(StateType.GoBackState)
end

function ZombieAI:OnStateComplete(type,data)
    ZombieBaseAI.OnStateComplete(self,type,data)
    if type == CharacterStateType.Attack or type == CharacterStateType.Skill then
        self.currentSkillIndex = self.currentSkillIndex + 1
        self:CheckSkill()
        self.m_states:SetState(ZombieBaseAI.StateType.MoveState)
    elseif type == CharacterStateType.BeHit then
        self.m_states:SetState(ZombieBaseAI.StateType.MoveState)
    elseif type == CharacterStateType.MoveByPath and self.m_states:CurrentStateEqual(ZombieAI.StateType.PatrolState) then
        --移动完成，并且在巡逻状态
        self.patrolling = false
    end
end

function ZombieAI:Destroy()
    ZombieBaseAI.Destroy(self)
    self.skillOrder = nil
    self.hpGroup = nil
end

return ZombieAI