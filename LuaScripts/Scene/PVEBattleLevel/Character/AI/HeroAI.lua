---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/1/3 16:54
---英雄的AI
local HeroAI = BaseClass("HeroAI")
local States = require("Util.States")
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local SU_Util = require("Scene.PVEBattleLevel.Utils.SU_Util")

local StateType = {
    FollowState = "FollowState",
    MoveState = "MoveState",
    AttackState = "AttackState",
    SkillState = "SkillState"
}

function HeroAI:__init(owner)
    self.m_owner = owner
    self.battleLevel = owner.battleLevel
    self.attackRadius = self.m_owner:GetAttackRange()
    self.chaseRadius = LuaEntry.DataConfig:TryGetNum("survival_heroes", "k2")
    -------技能相关--------
    self.skillRadius = 0
    self.currentSkillIndex = 1
    self.useSkill = false
    self.skillOrder = self.m_owner:GetSkillOrder()
    self.hpGroup = self.m_owner:GetHpStage()
    ---------------------
    
    self:__initState()
    self:__initFollowRange()

    self.playerAttackHandler = function(enemy)
        self:OnPlayerAttack(enemy)
    end
end

function HeroAI:__initState()
    self.m_states = States.New(self)
    self.m_states:AddState(StateType.FollowState, self.Follow_Enter, self.Follow_Update, self.Follow_Exit)
    self.m_states:AddState(StateType.MoveState, nil, self.Move_Update, nil)
    self.m_states:AddState(StateType.AttackState, self.AttackTarget_Enter)
    self.m_states:AddState(StateType.SkillState,self.Skill_Enter)
end

function HeroAI:__initFollowRange()
    local followRangeStr = SU_Util.GetItemConfig(DataCenter.BattleLevel:GetLevelId(), "hero_follow_range")
    local followRangeArr = string.split(followRangeStr,";")
    self.startMoveRange = tonumber(followRangeArr[1]) --开始跟随距离
    self.stopMoveRange = tonumber(followRangeArr[2])  --停止跟随距离
    self.intervalRange = tonumber(followRangeArr[3])  --和玩家保持的距离
end

function HeroAI:OnUpdate(deltaTime)
    self.m_states:Update(deltaTime)
end

function HeroAI:Start()
    self.m_states:SetState(StateType.FollowState)
    self:CheckSkill()
end

function HeroAI:Reset()
    self.m_enemy = nil
    self.enemyList = nil
    self.skillRadius = 0
    self.currentSkillIndex = 1
    self.useSkill = false
    self.m_states:SetState(StateType.FollowState)
    self:CheckSkill()
end

function HeroAI:OnPlayerAttack(enemy)
    self.m_enemy = enemy
    local pos = enemy:GetPosition()
    self.enemyList = self.battleLevel.RoleMgr:SearchZombieByRange(pos,self.chaseRadius)
    self.m_states:SetState(StateType.MoveState)
end

function HeroAI:Follow_Enter()
    self.m_target = DataCenter.BattleLevel:GetPlayer()
    self.m_checkTime = 0
    self.m_isMoving = false
    --EventManager:GetInstance():AddListener(EventId.SU_PlayerAttack,self.playerAttackHandler)
end

function HeroAI:Follow_Update(deltaTime)
    self.m_checkTime = self.m_checkTime + deltaTime
    if self.m_checkTime  < 0.1 then
        return
    end
    self.m_checkTime = 0
    if self.m_target ~= nil then
        local targetPos = self.m_target:GetPosition()
        local dis = Vector3.Distance(self.m_owner:GetPosition(),targetPos)
        if not self.m_isMoving then
            if dis > self.startMoveRange then
                self.m_isMoving = true
                self.m_owner:MovePath(targetPos)
            elseif dis < self.intervalRange then
                local pos = self.m_owner:GenerateConcentricPosition(targetPos,self.stopMoveRange,self.intervalRange)
                self.m_isMoving = true
                self.m_owner:MovePath(pos)
            end
        else
            if dis > self.intervalRange and dis < self.stopMoveRange then
                self.m_isMoving = false
                self.m_owner:Idle()
            elseif dis > self.intervalRange then
                self.m_owner:MovePath(targetPos)
            end
        end
    end
    self:FindEnemy()
end

function HeroAI:Follow_Exit()
    self.m_target = nil
    --EventManager:GetInstance():RemoveListener(EventId.SU_PlayerAttack,self.playerAttackHandler)
end

function HeroAI:Move_Update(deltaTime)
    if self.m_enemy and self.m_enemy:GetCurBlood() > 0 then
        local dis = Vector3.Distance(self.m_owner:GetPosition(),self.m_enemy:GetPosition()) - self:GetModelRadius(self.m_enemy)
        if dis <= self:GetAttackRadius() then
            if self.useSkill then
                self.m_states:SetState(StateType.SkillState)
            else
                self.m_states:SetState(StateType.AttackState)
            end
        else
            self.m_owner:MovePath(self.m_enemy:GetPosition())
        end
    else
        self:FindEnemy()
    end
end

function HeroAI:AttackTarget_Enter()
    if self.m_enemy and self.m_enemy:GetCurBlood() > 0 then
        self.m_owner:Attack(self.m_enemy)
    else
        self.m_states:SetState(StateType.MoveState)
    end
    self.m_owner:StopAttack() --取消循环攻击，变成单次攻击，支持不同攻击动画
end

function HeroAI:CheckSkill()
    self.useSkill = false
    local skillLength = #self.skillOrder
    if skillLength > 0 then
        local currentHpPercent = self.m_owner:GetCurBlood() / self.m_owner:GetMaxBlood() * 100
        local minHp = 0
        local maxHp = 0
        local skillGroupIndex = 1
        for i,v in ipairs(self.hpGroup) do
            maxHp = tonumber(v[1])
            minHp = tonumber(v[2])
            if currentHpPercent >= minHp and currentHpPercent <= maxHp then
                skillGroupIndex = i
                break
            end
        end
        if skillGroupIndex <= skillLength then
            local skillGroup = self.skillOrder[skillGroupIndex]
            self.currentSkillIndex = self.currentSkillIndex > #skillGroup and 1 or self.currentSkillIndex
            local skillId = tonumber(skillGroup[self.currentSkillIndex])
            if not string.IsNullOrEmpty(skillId) and skillId ~= PveSkillId.NormalAttack then
                self.useSkill = true
                self.skillId = skillId
                self.skillRadius = tonumber(GetTableData(TableName.SU_PveSkill, skillId, 'range')) or 1
            end
        end
    end
end

function HeroAI:Skill_Enter()
    self.m_owner:Skill(self.skillId,self.m_enemy)
end

function HeroAI:GetAttackRadius()
    if self.useSkill then
        return self.skillRadius
    end
    return self.attackRadius
end

function HeroAI:GetModelRadius(target)
    if self.useSkill or target == nil then
        return 0 --技能范围很多不规则的，如果算人物半径还得算最近的点，比较麻烦，在释放技能范围的时候先不考虑人物半径
    end
    return target:GetModelRadius()
end

function HeroAI:OnStateComplete(type)
    if type == CharacterStateType.Attack or type == CharacterStateType.Skill then
        self.currentSkillIndex = self.currentSkillIndex + 1
        self:CheckSkill()
        self.m_states:SetState(StateType.MoveState)
    end
end

function HeroAI:FindEnemy()
    if self.enemyList == nil then
        local player = DataCenter.BattleLevel:GetPlayer()
        if player ~= nil and player.ai ~= nil then
            local enemy = player.ai:GetLastZombieSelected()
            if enemy ~= nil and enemy:GetCurBlood() > 0 then
                self.enemyList = self.battleLevel.RoleMgr:SearchZombieByRange(enemy:GetPosition(),self.chaseRadius)
            end
        end
    end
    local enemy
    if self.enemyList ~= nil then
        local minDist = IntMaxValue
        local pos = self.m_owner:GetPosition()
        for _,v in ipairs(self.enemyList) do
            if v ~= nil and v:GetCurBlood() > 0 then
                local enemyPos = v:GetPosition()
                local dist = Vector3.Distance(enemyPos, pos) - v:GetModelRadius()
                if dist < minDist then
                    minDist = dist
                    enemy = v
                end
            end
        end
    end

    if enemy ~= nil then
        self.m_enemy = enemy
        self.m_states:SetState(StateType.MoveState)
    else
        self.m_enemy = nil
        self.enemyList = nil
        if not self.m_states:CurrentStateEqual(StateType.FollowState) then
            self.m_states:SetState(StateType.FollowState)
        end
    end
end

function HeroAI:Destroy()
    self.m_owner = nil
    self.battleLevel = nil
    self.enemyList = nil
    self.m_enemy = nil
    self.m_states:Dispose()
    self.skillOrder = nil
    self.hpGroup = nil
    EventManager:GetInstance():RemoveListener(EventId.SU_PlayerAttack,self.playerAttackHandler)
end

return HeroAI