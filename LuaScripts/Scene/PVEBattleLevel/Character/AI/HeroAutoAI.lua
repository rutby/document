---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/7/13 15:08
---英雄自动战斗AI
local HeroAutoAI = BaseClass("HeroAutoAI")
local States = require("Util.States")
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local SU_Util = require("Scene.PVEBattleLevel.Utils.SU_Util")
local Vector3_Distance2D = Vector3.Distance2D_XZ

local StateType = {
    FindTargetState = "FindTargetState",
    MoveState = "MoveState",
    AttackState = "AttackState",
    SkillState = "SkillState",
}

function HeroAutoAI:GetTeamTargetPos(player,teamPos)
    local playerPos = player:GetPosition()
    local eulerY = player:GetEuler().y
    return self.battleLevel.heroManager:GetTeamTargetPos(playerPos,teamPos,eulerY)
end

function HeroAutoAI:__init(owner)
    self.m_owner = owner
    self.battleLevel = owner.battleLevel
    self.attackRadius = self.m_owner:GetAttackRange()
    self.chaseRadius = LuaEntry.DataConfig:TryGetNum("survival_heroes", "k2")
    -------技能相关--------
    self.skillRadius = 0
    self.currentSkillIndex = 1
    self.useSkill = false
    self.skillOrder = self.m_owner:GetSkillOrder()
    self.hpGroup = self.m_owner:GetHpStage()
    ---------------------

    self:__initState()
    self:__initRange()

    self.playerPos = Vector3.New(0,0,0)

    --self.isFirstMove = true
end

function HeroAutoAI:__initState()
    self.m_states = States.New(self)
    self.m_states:AddState(StateType.FindTargetState, nil, self.FindTarget_Update, nil)
    self.m_states:AddState(StateType.MoveState, nil, self.Move_Update, nil)
    self.m_states:AddState(StateType.AttackState, self.AttackTarget_Enter)
    self.m_states:AddState(StateType.SkillState,self.Skill_Enter)
end

function HeroAutoAI:__initRange()
    --local followRangeStr = SU_Util.GetItemConfig(DataCenter.BattleLevel:GetLevelId(), "hero_follow_range")
    --local followRangeArr = string.split(followRangeStr,";")
    --self.startMoveRange = tonumber(followRangeArr[1]) --开始跟随距离
    --self.stopMoveRange = tonumber(followRangeArr[2])  --停止跟随距离
    --self.intervalRange = tonumber(followRangeArr[3])  --和玩家保持的距离

    self.searchEnemyRange = 100
end

function HeroAutoAI:OnUpdate(deltaTime)
    self.m_states:Update(deltaTime)
end

function HeroAutoAI:Start()
    self.m_states:SetState(StateType.FindTargetState)
    self:CheckSkill()
end

function HeroAutoAI:Reset()
    self.m_enemy = nil
    self.skillRadius = 0
    self.currentSkillIndex = 1
    self.useSkill = false
    self.m_states:SetState(StateType.FindTargetState)
    self:CheckSkill()
end

function HeroAutoAI:Move()
end

function HeroAutoAI:FindTarget_Update(deltaTime)
    self:FindEnemy()
    if self.m_enemy ~= nil then
        self.m_states:SetState(StateType.MoveState)
    end
end

function HeroAutoAI:Move_Update(deltaTime)
    if self.m_enemy and self.m_enemy:GetCurBlood() > 0 then
        local dis = Vector3.Distance(self.m_owner:GetPosition(),self.m_enemy:GetPosition()) - self:GetModelRadius(self.m_enemy)
        if dis <= self:GetAttackRadius() then
            if self.useSkill then
                self.m_states:SetState(StateType.SkillState)
            else
                self.m_states:SetState(StateType.AttackState)
            end
        else
            self.m_owner:MovePath(self.m_enemy:GetPosition())
        end
    else
        self:FindEnemy()
    end
end

function HeroAutoAI:AttackTarget_Enter()
    if self.m_enemy and self.m_enemy:GetCurBlood() > 0 then
        self.m_owner:Attack(self.m_enemy)
    else
        self.m_states:SetState(StateType.MoveState)
    end
    self.m_owner:StopAttack() --取消循环攻击，变成单次攻击，支持不同攻击动画
end

function HeroAutoAI:CheckSkill()
    self.useSkill = false
    local skillLength = #self.skillOrder
    if skillLength > 0 then
        local currentHpPercent = self.m_owner:GetCurBlood() / self.m_owner:GetMaxBlood() * 100
        local minHp = 0
        local maxHp = 0
        local skillGroupIndex = 1
        for i,v in ipairs(self.hpGroup) do
            maxHp = tonumber(v[1])
            minHp = tonumber(v[2])
            if currentHpPercent >= minHp and currentHpPercent <= maxHp then
                skillGroupIndex = i
                break
            end
        end
        if skillGroupIndex <= skillLength then
            local skillGroup = self.skillOrder[skillGroupIndex]
            self.currentSkillIndex = self.currentSkillIndex > #skillGroup and 1 or self.currentSkillIndex
            local skillId = tonumber(skillGroup[self.currentSkillIndex])
            if not string.IsNullOrEmpty(skillId) and skillId ~= PveSkillId.NormalAttack then
                self.useSkill = true
                self.skillId = skillId
                self.skillRadius = tonumber(GetTableData(TableName.SU_PveSkill, skillId, 'range')) or 1
            end
        end
    end
end

function HeroAutoAI:Skill_Enter()
    self.m_owner:Skill(self.skillId,self.m_enemy)
end

function HeroAutoAI:GetAttackRadius()
    if self.useSkill then
        return self.skillRadius
    end
    return self.attackRadius
end

function HeroAutoAI:GetModelRadius(target)
    if self.useSkill or target == nil then
        return 0 --技能范围很多不规则的，如果算人物半径还得算最近的点，比较麻烦，在释放技能范围的时候先不考虑人物半径
    end
    return target:GetModelRadius()
end

function HeroAutoAI:OnStateComplete(type)
    if type == CharacterStateType.Attack or type == CharacterStateType.Skill then
        self.currentSkillIndex = self.currentSkillIndex + 1
        self:CheckSkill()
        self.m_states:SetState(StateType.MoveState)
    end
end

function HeroAutoAI:FindEnemy()
    local enemy = self.battleLevel.RoleMgr:SearchEnemyTarget(self.m_owner:GetPosition(),self.searchEnemyRange,self.m_owner:GetType(),self:GetModelRadius(self.m_owner))

    --if not self.m_owner:SightRayCast(enemy:GetTransform()) then
    --    enemy = nil
    --end

    if enemy ~= nil then
        self.m_enemy = enemy
    end
end

function HeroAutoAI:Destroy()
    self.m_target = nil
    self.m_owner = nil
    self.battleLevel = nil
    self.m_enemy = nil
    self.m_states:Dispose()
    self.skillOrder = nil
    self.hpGroup = nil
end

return HeroAutoAI