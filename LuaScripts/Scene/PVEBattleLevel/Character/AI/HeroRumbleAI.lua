---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/5/29 15:27
---像rumble heroes 一样的AI。。。
local HeroRumbleAI = BaseClass("HeroRumbleAI")
local States = require("Util.States")
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local SU_Util = require("Scene.PVEBattleLevel.Utils.SU_Util")
local Vector3_Distance2D = Vector3.Distance2D_XZ

local StateType = {
    FollowState = "FollowState",
    MoveState = "MoveState",
    AttackState = "AttackState",
    SkillState = "SkillState",
}

function HeroRumbleAI:GetTeamTargetPos(player,teamPos)
    local playerPos = player:GetPosition()
    local eulerY = player:GetEuler().y
    return self.battleLevel.heroManager:GetTeamTargetPos(playerPos,teamPos,eulerY)
end

function HeroRumbleAI:__init(owner)
    self.m_owner = owner
    self.battleLevel = owner.battleLevel
    self.attackRadius = self.m_owner:GetAttackRange()
    self.chaseRadius = LuaEntry.DataConfig:TryGetNum("survival_heroes", "k2")
    -------技能相关--------
    self.skillRadius = 0
    self.currentSkillIndex = 1
    self.useSkill = false
    self.skillOrder = self.m_owner:GetSkillOrder()
    self.hpGroup = self.m_owner:GetHpStage()
    ---------------------

    self:__initState()
    self:__initRange()
    
    self.playerPos = Vector3.New(0,0,0)
    
    --self.isFirstMove = true
end

function HeroRumbleAI:__initState()
    self.m_states = States.New(self)
    self.m_states:AddState(StateType.FollowState, self.Follow_Enter, self.Follow_Update, self.Follow_Exit)
    self.m_states:AddState(StateType.MoveState, nil, self.Move_Update, nil)
    self.m_states:AddState(StateType.AttackState, self.AttackTarget_Enter)
    self.m_states:AddState(StateType.SkillState,self.Skill_Enter)
end

function HeroRumbleAI:__initRange()
    local followRangeStr = SU_Util.GetItemConfig(DataCenter.BattleLevel:GetLevelId(), "hero_follow_range")
    local followRangeArr = string.split(followRangeStr,";")
    self.startMoveRange = tonumber(followRangeArr[1]) --开始跟随距离
    self.stopMoveRange = tonumber(followRangeArr[2])  --停止跟随距离
    self.intervalRange = tonumber(followRangeArr[3])  --和玩家保持的距离

    self.searchEnemyRange = LuaEntry.DataConfig:TryGetNum("pve_c_boss", "k5")
end

function HeroRumbleAI:OnUpdate(deltaTime)
    self.m_states:Update(deltaTime)
end

function HeroRumbleAI:Start()
    self.m_states:SetState(StateType.FollowState)
    self:CheckSkill()
end

function HeroRumbleAI:Reset()
    self.m_enemy = nil
    self.skillRadius = 0
    self.currentSkillIndex = 1
    self.useSkill = false
    self.m_states:SetState(StateType.FollowState)
    self:CheckSkill()
end

function HeroRumbleAI:Move()
    if not self.m_states:CurrentStateEqual(StateType.FollowState) and self:CanStartFollow() then
        self:Reset()
        self.m_owner:ExitCurrentState()
        self.m_states:SetState(StateType.FollowState)
    end
    --self.isFirstMove = false
end

function HeroRumbleAI:IsMoving(target)
    if target == nil then
        return nil
    end
    --if self.isFirstMove then
        return self.m_target:IsMoving() or self.m_target:IsMoveByPath()
    --end
    --return self.m_target:IsMoving()
end
--是否开始跟随
function HeroRumbleAI:CanStartFollow()
    local player = DataCenter.BattleLevel:GetPlayer()
    local targetPos = player:GetPosition()
    if not targetPos:Equals(self.playerPos) then
        self.playerPos:Set(targetPos.x,targetPos.y,targetPos.z)
        local dis = Vector3_Distance2D(self.m_owner:GetPosition(),self.playerPos)
        if dis > self.m_owner.followRange then
            return true
        end
    end
    return false
end

function HeroRumbleAI:Follow_Enter()
    self.m_target = DataCenter.BattleLevel:GetPlayer()
    self.m_checkTime = 0
    self.m_isMoving = false
    self.isFirstMove = true
end

function HeroRumbleAI:Follow_Update(deltaTime)
    if self.m_target == nil then
        return
    end
    self.m_checkTime = self.m_checkTime + deltaTime
    local isPlayerMoving = self:IsMoving(self.m_target)
    if self.m_checkTime  < 0.2 and not isPlayerMoving then
        return
    end
    self.m_checkTime = 0
    if isPlayerMoving then
        local targetPos = self.m_target:GetPosition()
        if not targetPos:Equals(self.playerPos) then
            self.playerPos:Set(targetPos.x,targetPos.y,targetPos.z)
            local dis = Vector3_Distance2D(self.m_owner:GetPosition(),self.playerPos)
            if dis > self.m_owner.followRange or not self.isFirstMove then
                local pos = self:GetTeamTargetPos(self.m_target,self.m_owner.teamPos)
                self.isFirstMove = false
                self.m_isMoving = true
                self.m_owner:MovePath(pos,function()
                    self.isFirstMove = true
                    self.m_isMoving = false
                end)
            end
        end
    end

    if self:CheckFollowFindEnemy(isPlayerMoving) then
        self:FindEnemy()
    end
end

function HeroRumbleAI:CheckFollowFindEnemy(isPlayerMoving)
    return (not isPlayerMoving and not self.m_isMoving) or self.isFirstMove
end

function HeroRumbleAI:Follow_Exit()
    self.m_target = nil
end

function HeroRumbleAI:Move_Update(deltaTime)
    if self.m_enemy and self.m_enemy:GetCurBlood() > 0 then
        local dis = Vector3.Distance(self.m_owner:GetPosition(),self.m_enemy:GetPosition()) - self:GetModelRadius(self.m_enemy)
        if dis <= self:GetAttackRadius() then
            if self.useSkill then
                self.m_states:SetState(StateType.SkillState)
            else
                self.m_states:SetState(StateType.AttackState)
            end
        else
            self.m_owner:MovePath(self.m_enemy:GetPosition())
        end
    else
        self:FindEnemy()
    end
end

function HeroRumbleAI:AttackTarget_Enter()
    if self.m_enemy and self.m_enemy:GetCurBlood() > 0 then
        self.m_owner:Attack(self.m_enemy)
    else
        self.m_states:SetState(StateType.MoveState)
    end
    self.m_owner:StopAttack() --取消循环攻击，变成单次攻击，支持不同攻击动画
end

function HeroRumbleAI:CheckSkill()
    self.useSkill = false
    local skillLength = #self.skillOrder
    if skillLength > 0 then
        local currentHpPercent = self.m_owner:GetCurBlood() / self.m_owner:GetMaxBlood() * 100
        local minHp = 0
        local maxHp = 0
        local skillGroupIndex = 1
        for i,v in ipairs(self.hpGroup) do
            maxHp = tonumber(v[1])
            minHp = tonumber(v[2])
            if currentHpPercent >= minHp and currentHpPercent <= maxHp then
                skillGroupIndex = i
                break
            end
        end
        if skillGroupIndex <= skillLength then
            local skillGroup = self.skillOrder[skillGroupIndex]
            self.currentSkillIndex = self.currentSkillIndex > #skillGroup and 1 or self.currentSkillIndex
            local skillId = tonumber(skillGroup[self.currentSkillIndex])
            if not string.IsNullOrEmpty(skillId) and skillId ~= PveSkillId.NormalAttack then
                self.useSkill = true
                self.skillId = skillId
                self.skillRadius = tonumber(GetTableData(TableName.SU_PveSkill, skillId, 'range')) or 1
            end
        end
    end
end

function HeroRumbleAI:Skill_Enter()
    self.m_owner:Skill(self.skillId,self.m_enemy)
end

function HeroRumbleAI:GetAttackRadius()
    if self.useSkill then
        return self.skillRadius
    end
    return self.attackRadius
end

function HeroRumbleAI:GetModelRadius(target)
    if self.useSkill or target == nil then
        return 0 --技能范围很多不规则的，如果算人物半径还得算最近的点，比较麻烦，在释放技能范围的时候先不考虑人物半径
    end
    return target:GetModelRadius()
end

function HeroRumbleAI:OnStateComplete(type)
    if type == CharacterStateType.Attack or type == CharacterStateType.Skill then
        self.currentSkillIndex = self.currentSkillIndex + 1
        self:CheckSkill()
        self.m_states:SetState(StateType.MoveState)
    end
end

function HeroRumbleAI:FindEnemy()
    local list = self.battleLevel:GetRoleMgr().zombies
    local player = self.battleLevel:GetPlayer()
    local playerPosition = player:GetPosition()
    local heroPosition = self.m_owner:GetPosition()
    --local heroTransform = self.m_owner:GetTransform()
    local minDis = IntMaxValue
    local enemy = nil
    for _, v in pairs(list) do
        if not v:IsDead() then
            local enemyPos = v:GetPosition()
            local dist = Vector3_Distance2D(enemyPos, playerPosition) - self:GetModelRadius(v) - self:GetModelRadius(self.m_owner)
            --敌人在玩家搜寻范围内
            if dist < self.searchEnemyRange then
                dist = Vector3_Distance2D(enemyPos,heroPosition) - self:GetModelRadius(v) - self:GetModelRadius(self.m_owner)
                --找出来距离英雄自己最近的敌人
                if dist < minDis and self.m_owner:SightRayCast(v:GetTransform()) then
                    minDis = dist
                    enemy = v
                end
            end
        end

        ::continue::
    end

    if enemy ~= nil then
        self.m_enemy = enemy
        self.m_states:SetState(StateType.MoveState)
    else
        self.m_enemy = nil
        if not self.m_states:CurrentStateEqual(StateType.FollowState) and self:CanStartFollow() then
            self.m_states:SetState(StateType.FollowState)
        end
    end
end

function HeroRumbleAI:Destroy()
    self.m_target = nil
    self.m_owner = nil
    self.battleLevel = nil
    self.m_enemy = nil
    self.m_states:Dispose()
    self.skillOrder = nil
    self.hpGroup = nil
end

return HeroRumbleAI