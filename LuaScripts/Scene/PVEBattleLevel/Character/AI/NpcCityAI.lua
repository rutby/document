---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2023/2/28 11:07
---主城NPC氛围组，会说话，溜达，休息
local NpcBaseAI = require("Scene.PVEBattleLevel.Character.AI.NpcBaseAI")
local NpcCityAI = BaseClass("NpcCityAI",NpcBaseAI)
local Const = require("Scene.PVEBattleLevel.Const")

local StateType = {
    TalkState = "TalkState",
    WalkState = "WalkState",
    RestState = "RestState",
    BuildState = "BuildState",
    CollectState = 'CollectState',
}

local ActionType = {
    Walk = 1,   --交谈
    Talk = 2,   --谈话
    Rest = 3,   --休息
    Build = 4,  --建造
    Collect = 5, --采集
}

function NpcCityAI:__init(owner,completeHandler)
    NpcBaseAI.__init(self,owner,completeHandler)
    self.m_info = owner.info
    self.m_actionType = nil
    self.m_intervalTime = 0
    self.m_chatIntervalTime = 0
    self.m_restIntervalTime = 0
	self.pathPos = Vector3.New()
	
    self:__initData()
    self:ChangePath() --为了先有个初始化的坐标点，未来确定出生方式，就可以把这个移动到Start里，或者删除
end

function NpcCityAI:SetData(param, callback)
    NpcBaseAI.SetData(self, param, callback)
    self:__initWorldPos() --初始化出生坐标点,未来确定出生方式后删除
end

function NpcCityAI:__initWorldPos()
    if self.m_data ~= nil and self.m_data.noNeedResetPos then
        return
    end
    
    local pos = self.currentPath[1]
    local worldPos = SceneUtils.TileToWorld(pos)
    self.m_owner:InitForLevelKind(worldPos)
end

function NpcCityAI:__initData()
    local actionGroup = self.m_info:GetActionGroup()
    self.allowTalk = table.indexof(actionGroup,ActionType.Talk) ~= false
    self.allowRest = table.indexof(actionGroup,ActionType.Rest) ~= false
end

function NpcCityAI:__initState()
    self.m_states:AddState(StateType.TalkState,self.Talk_Enter,self.Talk_Update,self.Talk_Exit)
    self.m_states:AddState(StateType.WalkState,self.Walk_Enter,self.Walk_Update,self.Walk_Exit)
    self.m_states:AddState(StateType.RestState,self.Rest_Enter,self.Rest_Update,self.Rest_Exit)
    self.m_states:AddState(StateType.BuildState,self.Build_Enter, nil, self.Build_Exit)
    self.m_states:AddState(StateType.CollectState, self.Collect_Enter)
end

function NpcCityAI:OnUpdate(deltaTime)
    NpcBaseAI.OnUpdate(self,deltaTime)
    if self.m_starting and (self.m_actionType == nil or self.m_actionType == ActionType.Walk) then
        self:ChangeAction(deltaTime)
    end
end

function NpcCityAI:Start()
    NpcBaseAI.Start(self)
    self.m_states:SetState(StateType.WalkState)
end

---------------逻辑行为检测判定-----------------------

function NpcCityAI:ChangeAction(deltaTime)
    self.m_chatIntervalTime = self.m_chatIntervalTime + deltaTime
    self.m_restIntervalTime = self.m_restIntervalTime + deltaTime
    
    self.m_intervalTime = self.m_intervalTime + deltaTime
    if self.m_intervalTime < 0.5 then
        return
    end
    self.m_intervalTime = 0

    if self.allowTalk and self.m_chatIntervalTime > self.m_info:GetChatIntervalTime() then
        self:CheckTalk()
    end

    if self.allowRest and self.m_restIntervalTime > self.m_info:GetRestIntervalTime() then
        self:CheckRest()
    end
end

function NpcCityAI:CheckTalk()
    local roleMgr = DataCenter.BattleLevel:GetRoleMgr()
    local target = roleMgr:SearchTalkRoleByRange(self.m_owner,self.m_info:GetNpcChatGroup(),self.m_info:GetPlayerChatRadius(),CharacterType.Player)
    local probability = self.m_info:GetPlayerChatProbability()
    if target == nil then
        target = roleMgr:SearchTalkRoleByRange(self.m_owner,self.m_info:GetNpcChatGroup(),self.m_info:GetNpcChatRadius(),CharacterType.Npc)
        probability = self.m_info:GetChatProbability()
    end
    if target ~= nil then
        local random = Mathf.Random(0,100)
        if random <= probability then
            --分配剧本
            local groupIds
            if target.isPlayer then
                groupIds = self.m_info:GetPlayerChatGroupId()
            else
                groupIds = self.m_info:GetNpcChatGroupId()
            end
            local random = Mathf.Random(1,#groupIds)
            local chatGroupId = groupIds[random]
            local chatTemplateGroup = DataCenter.PveChatTemplateManager:GetChatTemplateGroup(chatGroupId)
            if chatTemplateGroup ~= nil then
                self:PrepareTalk(chatTemplateGroup,0)
                if not target.isPlayer then
                    target:PrepareTalk(chatTemplateGroup,1)
                    target:Idle()
                end
                self.m_owner:Idle()
            end
        end
    end
end
--已经使用的休息点
NpcCityAI.UsedRestIndex = {}

function NpcCityAI:CheckRest()
    local probability = self.m_info:GetRestProbability()
    local random = Mathf.Random(0,100)
    if random <= probability then
        --找出最近的休息点
        local ownerPos = self.m_owner:GetPosition()
        local minDis = IntMaxValue
        local targetRestPos
        local targetRestIndex
        local restCoordinates = self.m_info:GetRestCoordinates()
        local dis
        for i,pos in ipairs(restCoordinates) do
            if table.indexof(NpcCityAI.UsedRestIndex,i) == false then
                dis = Vector3.Distance(ownerPos,pos)
                if dis < self.m_info:GetRestTrigger() and dis < minDis then
                    minDis = dis
                    targetRestPos = pos
                    targetRestIndex = i
                end
            end
        end
        if targetRestPos ~= nil then
            self.targetRestPos = targetRestPos
            self.targetRestIndex = targetRestIndex
            self.m_states:SetState(StateType.RestState)
        end
        
    end
end

---------------------------------------------------

-------------------------行走------------------------------

function NpcCityAI:ChangePath()
    local paths = self.m_info:GetWalkPath()
    local index = Mathf.Random(1,#paths)
    self.currentPath = paths[index]
    self.m_currentPathIndex = 1
end

function NpcCityAI:WalkToPos()
    if self.currentPath == nil or self.m_currentPathIndex == nil or self.m_currentPathIndex > #self.currentPath then
        self:ChangePath()
    end
    --做一步容错，如果没有行走路径则直接结束
    if self.currentPath == nil or self.m_currentPathIndex > #self.currentPath then
        self.isWalkCompleted = true
        return
    end
    local pos = self.currentPath[self.m_currentPathIndex]
    if pos == nil or pos.x == nil then
        self.isWalkCompleted = true
        return
    end
    
    self.pathPos.x, self.pathPos.z = SceneUtils.TileXYToWorldXY(pos.x, pos.y)
    
    self.isWalkCompleted = false
    self.m_owner:MovePath(self.pathPos,function()
        self.isWalkCompleted = true
    end)

    --TimerManager:GetInstance():DelayInvoke(function()
        --if self.m_owner ~= nil then self.m_owner:PlayAnim('nvlieshou_low_walk_01') end
    --end, 0.05)
	
	TimerManager:GetInstance():DelayNextFrameAction(
		function()
			if self.m_owner ~= nil then 
				self.m_owner:PlayAnim('nvlieshou_low_walk_01') 
			end
		end)
end

function NpcCityAI:CheckDestination()
    local dis = Vector3.Distance(self.m_owner:GetPosition(),self.pathPos)
    if dis < 2 then
        --抵达目的地
        self.m_currentPathIndex = self.m_currentPathIndex + 1
    end
end

function NpcCityAI:Walk_Enter()
    self.m_actionType = ActionType.Walk
    self:WalkToPos()


end

function NpcCityAI:Walk_Update(deltaTime)
    if self.isWalkCompleted then
        self:CheckDestination()
        self:WalkToPos()
    end
end

function NpcCityAI:Walk_Exit()
    self:CheckDestination()
    --self.pathPos = nil
    self.isWalkCompleted = true
end

----------------------------------------------------------------
---
-----------------------交谈-------------------------------
--准备交谈
function NpcCityAI:PrepareTalk(chatTemplateGroup,chatObjectType)
    self.chatTemplateGroup = chatTemplateGroup
    self.chatObjectType = chatObjectType

    self.m_states:SetState(StateType.TalkState)
end

function NpcCityAI:Talk(chatTemplate)
    if chatTemplate.chat_object == self.chatObjectType then
        --该自己说话了
        UIUtil.ShowCharacterDialogId(chatTemplate.dialogID,self.m_owner,chatTemplate.view_time / 1000)
    end
end

function NpcCityAI:Talk_Enter()
    self.m_actionType = ActionType.Talk
    
    self.m_chatIntervalTime = 0
    self.talkTime = 0
    self.talkViewTime = 0
    self.chatGroupIndex = 1
end

function NpcCityAI:Talk_Update(deltaTime)
    self.talkTime = self.talkTime + deltaTime
    if self.talkTime >= self.talkViewTime then
        if self.chatGroupIndex <= #self.chatTemplateGroup then
            local chatTemplate = self.chatTemplateGroup[self.chatGroupIndex]
            self.talkViewTime = chatTemplate.view_time / 1000
            self.talkTime = 0
            self.chatGroupIndex = self.chatGroupIndex + 1
            self:Talk(chatTemplate)
        else
            --交谈结束，继续行走
            self.m_states:SetState(StateType.WalkState)
        end
    end
end

function NpcCityAI:Talk_Exit()
    self.m_actionType = nil 
    self.chatTemplateGroup = nil
    self.chatObjectType = nil
end

--------------------------------------------------------

------------------休息--------------------------
function NpcCityAI:Rest_Enter()
    self.m_actionType = ActionType.Rest
    self.m_restIntervalTime = 0
    self.startRest = false
    self.restTime = 0
    self.m_owner:MovePath(self.targetRestPos,function()
        self.startRest = true
    end)
    table.insert(NpcCityAI.UsedRestIndex,self.targetRestIndex)
end

function NpcCityAI:Rest_Update(deltaTime)
    if self.startRest then
        self.restTime = self.restTime + deltaTime
        if self.restTime >= self.m_info:GetRestTime() then
            --休息时间到了
            self.m_states:SetState(StateType.WalkState)
        end
    end
end

function NpcCityAI:Rest_Exit()
    self.m_actionType = nil
    self.startRest = false
    table.removebyvalue(NpcCityAI.UsedRestIndex,self.targetRestIndex)
    self.targetRestIndex = nil
    self.targetRestPos = nil
end

-----------------------------------------------



----------------------拾取----------------------
function NpcCityAI:MoveToCollect(param)
    self.m_states:SetState(StateType.CollectState, param)
end

function NpcCityAI:Collect_Enter(data)
    self.m_actionType = ActionType.Collect

    local pos = self.m_owner:GetPosition()
    self.lastPosition = {x = pos.x,y = pos.y,z = pos.z}
    self.lastActionType = self.m_actionType

    self.m_owner:MovePathWithSpecifiedSpeed(data.dstPos, DataCenter.GirlBehaviorManager.GirlRunSpeed, data.callback)
    TimerManager:GetInstance():DelayInvoke(function() self.m_owner:PlayAnim('nvlieshou_low_run_01') end, 0.05)
    
    DataCenter.BattleLevel:GetGirlCollectMgr():ShowPathLine(self.m_owner)
end

function NpcCityAI:EndCollect()
    DataCenter.BattleLevel:GetGirlCollectMgr():RemovePathLine(self.m_owner)
    
    --self.m_owner:MovePathWithSpecifiedSpeed(self.lastPosition, DataCenter.GirlBehaviorManager.GirlRunSpeed, function(isEnd)
        if self.lastActionType == ActionType.Rest then
            self.m_states:SetState(StateType.RestState)
        else
            self.m_states:SetState(StateType.WalkState)
        end
    --end)
end
-----------------------------------------------



function NpcCityAI:CanTalk()
    return (not self:IsTalk()) and self.m_chatIntervalTime > self.m_info:GetChatIntervalTime()
end

function NpcCityAI:IsWalk()
    return self.m_actionType == ActionType.Walk
end

function NpcCityAI:IsTalk()
    return self.m_actionType == ActionType.Talk
end

function NpcCityAI:IsRest()
    return self.m_actionType == ActionType.Rest
end

function NpcCityAI:IsBuild()
    return self.m_actionType == ActionType.Build
end

function NpcCityAI:Destroy()
    NpcBaseAI.Destroy(self)

    if self:IsBuild() then
        self:Build_Exit()
    end
    
    self.m_info = nil
    self.chatTemplateGroup = nil
end

return NpcCityAI