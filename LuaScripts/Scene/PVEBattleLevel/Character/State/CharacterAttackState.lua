---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2022/9/23 18:38
---
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local CharacterBaseState = require("Scene.PVEBattleLevel.Character.State.CharacterBaseState")
local CharacterAttackState = BaseClass("CharacterAttackState",CharacterBaseState)
local Resource = CS.GameEntry.Resource
local VFXBase = require("Scene.PVEBattleLevel.VFX.VFXBase")
local FanRange = require("Scene.PVEBattleLevel.Character.Skill.Range.FanRange")

local BeginTime = 0.05

function CharacterAttackState:SetData(data)
    CharacterBaseState.SetData(self,data)
    self.m_target = data
end

function CharacterAttackState:OnEnter()
    --self:__addEvent()
    self:StartAttack()
    self:SearchEnemy(false)
    self.time = 0
    self.begun = false
    self.done = false
    self.ended = false
end

function CharacterAttackState:PlayAttackVFX(attackAnimName)
    --if self.m_owner:GetType() ~= CharacterType.Player then
    --    return
    --end
    
    if self.attackVFX ~= nil then
        self.attackVFX:Destroy()
        self.attackVFX = nil
    end
    
    local vfx = DataCenter.PveActVFXTemplateManager:GetTemplate(attackAnimName)
    if vfx ~= nil and not string.IsNullOrEmpty(vfx.atk_eff[1]) then
        self.attackVFX = VFXBase.New(0,vfx.atk_eff[1])
        self.attackVFX:SetParent(self.m_owner:GetTransform())
        self.attackVFX:Create()
    end
end

function CharacterAttackState:StartAttack()
    self.m_animName = self.m_owner:GetAttackAnimName()
    self.m_owner:PlayAnim(self.m_animName)
    self.m_owner:SetAnimSpeed(1)
    self.m_updateAttackSpeed = true
    self:PlayAttackVFX(self.m_animName)
    --if self.m_owner.isPlayer then
        self.m_owner:PlayWeaponAttackAnim()
    --end
    self.m_isDone = false
end

function CharacterAttackState:UpdateAttackSpeed()
    if self.m_updateAttackSpeed then
        local length = self.m_owner:GetCurrentAnimLength(self.m_animName)
        if length ~= -1 then
            self.m_updateAttackSpeed = false
            local attackCount = self.m_owner:GetAttackSpeed() --每秒攻击次数
            local animSpeed = length /  (1 / attackCount)
            self.m_owner:SetAnimSpeed(animSpeed)
            self.m_owner.attackIntervalTime = Time.time + length / animSpeed
            --Logger.LogError("m_animName:"..self.m_animName..",length:"..length..",attackCount:"..attackCount..",animSpeed:"..animSpeed)
        end
    end
end

function CharacterAttackState:SearchEnemy(needSearch)
    local attackArc = self.m_owner:GetAttackArc()
    if attackArc > 0 then
        if self.m_targetList == nil then
            if self.m_target ~= nil then
                local pos = self.m_target:GetPosition() - self.m_owner:GetPosition()
                pos.y = 0
                self.m_owner:SetRotation(Quaternion.LookRotation(Vector3.Normalize(pos), Vector3.up))
            end
            local x,y,z= self.m_owner:GetTransform():Get_localEulerAngles()
            --每次攻击得时候角度都不一样
            local attackRange = FanRange.New(self.m_owner:GetPosition(),self.m_owner:GetAttackRange(),attackArc,y)
            local targetList = SceneManager.GetLevel().RoleMgr:SearchEnemyByRangeObject(self.m_owner:GetType(),attackRange)

            if targetList ~= nil and #targetList > 0 then
                self.m_targetList = targetList

                if self.m_target == nil or self.m_target:GetCurBlood() <= 0 then
                    self.m_target = targetList[1]
                end
            end
        end
    elseif needSearch or self.m_target == nil or self.m_target:GetCurBlood() <= 0 then
        self.m_target = self.m_owner:SearchEnemyTarget()
    end
end

function CharacterAttackState:OnUpdate(deltaTime)
    CharacterBaseState.OnUpdate(self,deltaTime)
    
    self.time = self.time + deltaTime
    if not self.begun then
        if self.time >= BeginTime then
            self:__onAttackBegin()
            self.begun = true
        end
    elseif not self.done then
        if self.time >= self.m_owner.info:GetAttackDelay() then
            self:__onAttackDone()
            self.done = true
        end
    elseif not self.ended then
        if self.time >= self.m_owner.info:GetAttackDuration() then
            self:__onAnimPlayEnd()
            self.ended = true
        end
    end
    
    if self.m_target ~= nil then
        local pos = self.m_target:GetPosition() - self.m_owner:GetPosition()
        pos.y = 0
        pos = Vector3.Normalize(pos)
        if pos.x ~= 0 or pos.z ~= 0 then
            local lookRot = Quaternion.LookRotation(pos, Vector3.up)
            self.m_owner:SetRotation(lookRot)
        end
    end

    self:UpdateAttackSpeed()
end

--function CharacterAttackState:__addEvent()
--    if self.m_owner.animEvent then
--        self.m_owner.animEvent.animation_attackBegin = function() self:__onAttackBegin()  end
--        self.m_owner.animEvent.animation_attackDone = function() self:__onAttackDone() end
--        self.m_owner.animEvent.animation_playEnd = function() self:__onAnimPlayEnd()  end
--    end
--end

function CharacterAttackState:__onAttackBegin()
    --self:PlayWeaponSound(SUSoundUtil.WeaponAction.Attack) --播放武器挥出音效
end

--function CharacterAttackState:__removeEvent()
--    if self.m_owner.animEvent then
--        self.m_owner.animEvent.animation_attackBegin = nil
--        self.m_owner.animEvent.animation_attackDone = nil
--        self.m_owner.animEvent.animation_playEnd = nil
--    end
--end

function CharacterAttackState:__onAttackDone()
    self.m_isDone = true
    local hasWeaponSound = false
    local attackSuccess = false
    local isLife = false
    if self.m_targetList ~= nil then
        local param1 = false
        local param2 = false
        for _,target in ipairs(self.m_targetList) do
            param1,param2 = self:__attackEnemy(target)
            attackSuccess = attackSuccess or param1
            isLife = isLife or param2
        end

        self.m_targetList = nil
    else
        attackSuccess,isLife = self:__attackEnemy(self.m_target)
    end
    if attackSuccess then
        if isLife then
            --武器普通击打声音
            --hasWeaponSound = self:PlayWeaponSound(SUSoundUtil.WeaponAction.BeHit)
        else
            --武器击杀声音
            --hasWeaponSound = self:PlayWeaponSound(SUSoundUtil.WeaponAction.BeHitKill)
        end
        if self.m_owner:GetType() == CharacterType.Player then
            self.m_owner:OnAttackLoseHungerAndDurability()
        end
    end
    --播放枪械开火特效
    self.m_owner:PlayWeaponFireVFX()
    --发射武器子弹
    self.m_owner:FireWeaponTrackVFX(self.m_target ~= nil and self.m_target:GetPosition() or nil)
end

function CharacterAttackState:__attackEnemy(target)
    if (target ~= nil and target:GetCurBlood() > 0) then
        if self.m_owner:GetType() == CharacterType.Zombie then
            local dis = Vector3.Distance(self.m_owner:GetPosition(),target:GetPosition()) - target:GetModelRadius()
            if dis > self.m_owner:GetAttackDropDistance() then
                return false,false--没打着
            end
        end
        if self.m_animName == "male1_attack1" or self.m_animName == "female1_attack1" then
            local timeIndex = math.random(1, 2)
            local str = "Effect_pve_knife_0"..timeIndex
            SoundUtil.PlayEffect(str)
        elseif self.m_animName == "male1_attack2" or self.m_animName == "female1_attack2" then
            SoundUtil.PlayEffect("Effect_pve_gun")
        elseif string.contains(self.m_animName,"zombie_") then
            local timeIndex = math.random(1, 3)
            local str = "Effect_pve_zombie_attack0"..timeIndex
            SoundUtil.PlayEffect(str)
        end
        self.m_owner:AttackEnemy(target)
        --播放被击特效
        if target.PlayBeAttackVFX ~= nil then
            target:PlayBeAttackVFX(self.m_animName)
        end

        return true,target:GetCurBlood() > 0
    end
    return false,false
end

function CharacterAttackState:__onAnimPlayEnd()
    if not self.m_isDone then
        --容错，没有打击点，执行一下打击
        self:__onAttackDone()
    end
    self:__UnSneak()
    -- 这个地方要加一个处理,之前我们长按攻击是可以播放攻击动画的.但是在AI模式下,我们只要发现对方死了或不存在就直接exit
    if self.m_owner:GetType() == CharacterType.Player then
        if (self.m_owner:IsAIMode()) then
            if (self.m_target == nil or self.m_target:GetCurBlood() <= 0) then
                self:OnExit()
                return
            end
        end
    end
    
    if self.m_owner:IsAttacking() then
        if self.m_owner:GetType() == CharacterType.Player then
            if not self:CheckAttackInterval() then
                if self:CheckContinueAttack() then
                    self:StartAttack()
                end
            end
        else
            self:SearchEnemy(false)
        end
    else
        --没有再攻击了
        self:OnExit()
    end
end

function CharacterAttackState:CheckAttackInterval()
    local cooldown = self.m_owner:GetCoolDown()
    if cooldown > 0 then
        self.m_owner:SetAnimSpeed(1) --cooldown需要动画速度正常
        if self.m_owner:IsSneak() then
            self.m_owner:PlayAnim(self.m_owner:GetDefaultAnimName())
        else
            local anim = self.m_owner:GetEquipAnim(self.m_owner.info:GetInertialIdle(), PlayerAnimationName.Idle_KongShou)
            self.m_owner:PlayAnim(anim)
        end

        self.attackIntervalTimer = TimerManager:GetInstance():GetTimer(cooldown / 1000,function()
            self:ClearAttackIntervalTimer()
            if self.m_owner:IsAttacking() then
                if self:CheckContinueAttack() then
                    self:StartAttack()
                end
            else
                self:OnExit()
            end
        end)
        self.attackIntervalTimer:Start()
        return true
    end
    return false
end

function CharacterAttackState:CheckContinueAttack()
    local isOutAttackRange = self:CheckOutAttackRange() --检查目标是否出攻击范围
    self:SearchEnemy(true) --重新搜寻最近的目标
    if self.m_target == nil and (isOutAttackRange or self.m_owner.ai:GetLastZombieSelected() ~= nil) then
        --正在攻击中但是攻击范围内没有目标了，则再启动搜寻视野范围内目标逻辑
        self.m_owner:MoveToAttack()
        self:OnExit()
        return false
    end
    return true
end

function CharacterAttackState:__UnSneak()
    if self.m_owner:GetType() == CharacterType.Player then
        self.m_owner:Sneak(false)
    end
end

function CharacterAttackState:CheckOutAttackRange()
    if self.m_target == nil then
        return false
    end
    local dis = Vector3.Distance(self.m_owner:GetPosition(),self.m_target:GetPosition()) - self.m_target:GetModelRadius()
    if dis > self.m_owner:GetAttackRange() then
        --超出攻击范围清空目标
        self.m_target = nil
        return true
    end
end

--播放武器音效
function CharacterAttackState:PlayWeaponSound(action)
    local weaponName = self.m_owner:GetWeaponName()

	-- 如果没有武器的话，就播放人物attack动作的音效
	-- 如果手持武器的话，就播放武器挥舞的音效
    if string.IsNullOrEmpty(weaponName) then
		--SUSoundUtil.PlayMainActorActionSound('attack')
        return false
    end

    SUSoundUtil.PlayWeaponEffect(weaponName, action)
    return true
end

function CharacterAttackState:RemoveVFX()
    if self.fireVFX ~= nil then
        self.fireVFX:Destroy()
        self.fireVFX = nil
    end
    if self.attackVFX ~= nil then
        self.attackVFX:Destroy()
        self.attackVFX = nil
    end
end

function CharacterAttackState:ClearAttackIntervalTimer()
    if self.attackIntervalTimer ~= nil then
        self.attackIntervalTimer:Stop()
        self.attackIntervalTimer = nil
    end
end

function CharacterAttackState:OnExit()
    --if (self.m_owner:GetEnemyType() == CharacterType.Zombie) then
    --    print(">>>>attackstate: exit")
    --end
    self.m_owner:SetAnimSpeed(1)
    self.m_owner:DoStopAttack()
    self.m_target = nil
    --self:__removeEvent()
    self:RemoveVFX()
    self:ClearAttackIntervalTimer()
    self:OnStateComplete()
end

function CharacterAttackState:AllowStopByType(type)
    return CharacterStateType.Die == type or CharacterStateType.Move == type or CharacterStateType.BeHit == type or CharacterStateType.PeeOrStool == type
end

function CharacterAttackState:Destroy()
    self.m_target = nil
    --self:__removeEvent()
    self:RemoveVFX()
    self:ClearAttackIntervalTimer()
    CharacterBaseState.Destroy(self)
end

return CharacterAttackState