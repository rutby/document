---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2022/9/23 18:40
---
---路径移动
---
local CharacterBaseState = require("Scene/PVEBattleLevel/Character/State/CharacterBaseState")
local CharacterMovePathState = BaseClass("CharacterMovePathState",CharacterBaseState)
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")

function CharacterMovePathState:__init(owner,type,completeHandler)
    CharacterBaseState.__init(self,owner,type,completeHandler)
    self.m_agent = self.m_owner:GetNavmeshAgent()
	-- 移动目标及回调
    self.targetPos = Vector3.New(0, 0, 0)
	self.callback = nil
    self.speed = 3
    self.updatePos = false
    self.m_tmpV = Vector3.New(0,0,0)
	self.moveSoundTick = 0

    if self.m_owner:GetType() == CharacterType.Player then
        self.characterController = self.m_owner:GetCharacterController();
        if not IsNull(self.characterController) and not self.characterController.enabled then
            self.characterController.enabled = true --在移动的时候再启用，只需要启动一次就行
        end
    end
end

function CharacterMovePathState:__delete()
	self.m_agent = nil
	self.targetPos = nil
	self.callback = nil
	self.updatePos = nil
end

function CharacterMovePathState:OnEnter()
    self.m_owner:PlayAnim(self.m_owner:GetMoveAnimName())
    self.m_owner:SetAnimSpeed(self.m_owner:GetMoveAnimSpeed())
    self.m_agent.enabled = true
    if (self.m_agent.enabled) then
        self.m_agent.isStopped = false
    end
    
    self.m_agent.speed = self.speed --self.m_owner:GetMoveSpeed()
    self.m_agent.angularSpeed = 1000
    
    --Logger.Log('#CharacterMovePathState# set speed' .. self.m_owner:GetObjId()  .. ', [1] data speed:' .. self.speed .. ', agent speed:' .. tostring(self.m_agent.speed))
end

function CharacterMovePathState:SetData(data)
    CharacterBaseState.SetData(self, nil)
	
    if not self.targetPos:Equals(data["pos"]) then
		self.targetPos:Set(data.pos.x, data.pos.y, data.pos.z)
        self.updatePos = true
    end
	self.callback = data.callback
    self.speed = data.speed --Mathf.Clamp(data.speed, 1, 6)
    self.m_agent.speed = self.speed
    --Logger.Log('#CharacterMovePathState# set speed objId:' .. self.m_owner:GetObjId() .. ', [2] data speed:' .. data.speed .. ', agent speed:' .. tostring(self.m_agent.speed))
end

function CharacterMovePathState:OnUpdate(deltaTime)
    --local _nextPos = self.m_agent.nextPosition
    --
    --local _curPos = self.m_owner:GetPosition()
    --print(">>>>>>lsz nextPos: x: " .. tostring(_nextPos.x) .. " z: " .. tostring(_nextPos.z) .. " cx:" .. tostring(_curPos.x) .. " cz:" .. tostring(_curPos.z))
    --local _distance = Vector3.New(_nextPos.x-_curPos.x, 0, _nextPos.z-_curPos.z)
    --if (not _distance:Equals(ResetPosition)) then
    --    --local _dir = Vector3.Normalize( _distance )
    --    --self.m_owner:GetTransform().forward = _dir
    --    --self.m_owner:TurnToDir(_dir, deltaTime)
    --    self.m_owner:GetTransform():LookAt(_nextPos)
    --end
    local updatePos = self.updatePos --这个是为了刚启动agent的时候，空一针检测是否完成
    if self.updatePos then
        self.updatePos = false
        self.m_agent:SetDestinationXYZ(self.targetPos.x, self.targetPos.y, self.targetPos.z)
    end
    
    --[[直接通过调用c#计算
    if (self.m_agent.hasPath) then
        local _corners = self.m_agent.path.corners
        if (_corners.Length > 1) then
            local _dir = _corners[1]-self.m_owner:GetTransform().position
            if (not _dir:Equals(ResetPosition)) then
                _dir = Vector3.Normalize( _dir )
                self.m_owner:TurnToDir(_dir, deltaTime)
            end
        end
    end
    ]]
    
    --local curPos = self.m_owner:GetPosition()
    --local steeringTarget = Vector3.Normalize(self.m_agent.steeringTarget - curPos)
    --local x, y, z = steeringTarget.x, steeringTarget.y, steeringTarget.z
    --self.m_tmpV:Set(x, y, z)
    --self.m_owner:TurnToDir(self.m_tmpV, deltaTime)

    self.m_owner:UpdateShaderPos()
    -- 我们检测如果已经到达了destination,或者速度已经足够小的时候这个时候直接停止,退出
    --if (not updatePos and not self.m_agent.pathPending and (self.m_agent:IsVelocityZero() or self.m_agent.remainingDistance < 0.3)) then
    if (not updatePos and 
            self.m_agent.enabled and
            self.m_agent.isOnNavMesh and -- 必须要在navmesh上
            not self.m_agent.pathPending and 
            self.m_agent.remainingDistance < 0.05) then
        self:OnExit(true)
    end
    
	
	self.moveSoundTick = self.moveSoundTick + deltaTime
	if self.moveSoundTick > 0.5 then
		self.m_owner:OnPlayFootstepSound()
		self.moveSoundTick = 0
	end
end

function CharacterMovePathState:OnExit(isEnd)
    --self.targetPos = nil
    self.m_owner:SetAnimSpeed(1)
	self.targetPos:Set(-1, -1, -1)
    if self.m_agent.enabled then
        self.m_agent.isStopped = true
    end
    
    local ownerType = self.m_owner:GetType()
    if ownerType == CharacterType.Player or ownerType == CharacterType.Npc then
        self.m_agent.enabled = false
    end
    self:OnStateComplete()
    --if (self.m_data["callback"] ~= nil) then
        --self.m_data["callback"]()
    --end
	if (self.callback ~= nil) then
        local _callback = self.callback
		self.callback = nil  -- 只调用一次
        _callback(isEnd)
	end
end

function CharacterMovePathState:ChangeCharacterState()
    self.m_owner:PlayAnim(self.m_owner:GetMoveAnimName())
    self.m_agent.speed = self.speed --self.m_owner:GetMoveSpeed()
    --Logger.Log('#CharacterMovePathState# set speed' .. self.m_owner:GetObjId()  .. ', [3] data speed:' .. self.speed .. ', agent speed:' .. tostring(self.m_agent.speed))
end
    --
--function CharacterMovePathState:FindPath(targetPos)
--    self.targetPos = targetPos
--    
--    local destTileIdx = SceneUtils.WorldToTileIndex(targetPos)
--    local curPos = self.m_owner:GetPosition()
--    local startTileIdx = SceneUtils.WorldToTileIndex(curPos)
--    if destTileIdx == startTileIdx then
--        return false
--    end
--    
--    local pathList = self.m_owner.battleLevel.pathFinder:FindPath(curPos, targetPos)
--    if pathList == nil then
--        return false
--    end
--
--    --如果寻路和之前的结果一样 还按原来的走
--    if self.pf_pathList ~= nil then
--        if Vector3.Distance(pathList[#pathList], self.pf_pathList[#self.pf_pathList]) < 0.4 then
--            return true
--        end
--    end
--    
--    self.pf_pathList = pathList
--    self.pf_moveIdx = 0
--    
--    self:PF_DoNext()
--    return true
--end
--
--function CharacterMovePathState:PF_DoNext()
--    if self.pf_pathList == nil or self.pf_moveIdx < 0 then
--        return
--    end
--
--    self.pf_moveIdx = self.pf_moveIdx + 1
--    if self.pf_moveIdx >= #self.pf_pathList then
--        self.pf_pathList = nil
--        return
--    end
--
--    self:calculate()
--end
--
--function CharacterMovePathState:OnUpdate(deltaTime) 
--    if self.pf_pathList == nil or self.pf_moveIdx < 0 then
--        self:OnExit()
--        return
--    end
--    if self.targetPos == nil or self.m_data == nil then
--        self:OnExit()
--        return
--    end
--
--    if self.targetPos ~= self.m_data["pos"] then
--        --目标位置数据发生改变，重新寻路
--        self.lastUsePathFinding = self:FindPath(self.m_data["pos"])
--    end
-- 
--    if self.lastUsePathFinding then
--        self.pf_curTime = self.pf_curTime + deltaTime
--        if self.pf_curTime < self.pf_curDuration then
--            self.m_owner:TurnToDir(self.pf_moveForward, deltaTime)
--            self.m_owner:SetPosition(Vector3.Lerp(self.pf_curStartPos, self.pf_curDstPos, self.pf_curTime / self.pf_curDuration))
--        else
--            self:PF_DoNext()
--        end
--    else
--        --临时逻辑，因为PathFinder寻路有BUG，移除的障碍物无法通过，所以临时添加以下逻辑
--        local dir = Vector3.Normalize(self.targetPos - self.m_owner:GetPosition())
--        self.m_owner:TurnToDir(dir, deltaTime)
--        self.m_owner:MoveToDir(dir, deltaTime)
--    end
--end
--
--function CharacterMovePathState:OnExit()
--    self.pf_pathList = nil
--    self.pf_moveIdx = -1
--    self:OnStateComplete()
--    if (self.m_data["callback"] ~= nil) then
--        self.m_data["callback"]()
--    end
--end
--
--function CharacterMovePathState:ChangeCharacterState()
--    self.m_owner:PlayAnim(self.m_owner:GetMoveAnimName())
--    if self.lastUsePathFinding then
--        self:calculate()
--    end
--end
--
--function CharacterMovePathState:calculate()
--    if self.pf_pathList == nil or self.pf_moveIdx < 0 then
--        return
--    end
--    self.pf_curStartPos = self.m_owner:GetPosition()--self.pf_pathList[self.pf_moveIdx]
--    self.pf_curDstPos = self.pf_pathList[self.pf_moveIdx+1]
--    self.pf_curDistance = Vector3.Distance(self.pf_curStartPos, self.pf_curDstPos)
--    self.pf_curDuration = self.pf_curDistance / self.m_owner:GetMoveSpeed()
--    self.pf_curTime = 0
--    self.pf_moveForward = Vector3.Normalize(self.pf_curDstPos - self.pf_curStartPos)
--end

--function CharacterBaseState:AllowStopByType(type)
--    return CharacterStateType.Default ~= type and CharacterStateType.Move ~= type and CharacterStateType.Run ~= type
--        and CharacterBaseState.MoveByPath ~= type
--end

return CharacterMovePathState