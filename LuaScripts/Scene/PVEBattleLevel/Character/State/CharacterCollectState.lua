---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2022/10/18 16:18

local CharacterBaseState = require("Scene.PVEBattleLevel.Character.State.CharacterBaseState")
local CharacterCollectState = BaseClass("CharacterCollectState",CharacterBaseState)
local Const = require "Scene.PVEBattleLevel.Const"

--[[
    整体的逻辑大致如下
    我们在点击了采集按钮后,进入该状态,执行动作进行采集
        采集分为 Pick[瞬间收取] -- OpenBox[收取箱子,需要走cd]  -- Cut[砍树]  --  Dig[石头]
        在上面三个类型中,Pick/Cut/Dig 都走帧事件回调来处理  OpenBox我们走timer时间到了结束
        在ActionDone之后进行重新筛选,如果当前目标已经finish了,再重走状态机
        Animation_CollectDone  发送消息
        Animation_ClipDone  整体动画操作完成
]]
function CharacterCollectState:SetData(data)
    self.m_collectParam = data
    local _triggerId = self.m_collectParam["trigger"]
    self.m_curTriggerId = _triggerId
    local _itemInfo = DataCenter.SV_MapItemInfoManager:GetItemInfoList():GetTriggerByTriggerId(_triggerId)
    self.m_resInfo = _itemInfo -- 赋值采集点信息
    if _itemInfo == nil then return end
    local _objUuid = _itemInfo:GetUuid()
    local _targetObj = DataCenter.BattleLevel:GetObjMgr():GetObjectByUuid(_objUuid)
    self.m_target = _targetObj
end

function CharacterBaseState:GetCollectParam()
    return self.m_collectParam
end

function CharacterCollectState:OnEnter()
    self:__addEvent()
    self:DoOnceCollect()
end

-- 添加帧事件
function CharacterCollectState:__addEvent()
    if self.m_owner.animEvent then
        self.m_owner.animEvent.animation_callback = function(animEvent) self:__onAnimationRecv(animEvent)  end
    end
end

function CharacterCollectState:__removeEvent()
    if self.m_owner.animEvent then
        self.m_owner.animEvent.animation_callback = nil
    end
end

function CharacterCollectState:__onAnimationRecv( animEvent )
    if (animEvent == Const.RoleAniCallback.Collect_Done) then
        self:RecvCollectEvent()
    elseif animEvent == Const.RoleAniCallback.Animation_Done then
        self:AnimationPlayDone()
    end
end

--[[ 整体动作播放完成 ]]
function CharacterCollectState:AnimationPlayDone()
    self.m_playCollectState = false
    -- 如果不是长按,动画播放完成后退出collect状态
    local isHoldButton = self.m_owner:IsCollecting()
    if isHoldButton then  -- 长按采集键进行下一次采集
        self:DoOnceCollect() 
        return
    end

    if (self.m_resInfo ~= nil and 
            not self.m_resInfo:IsResourceEmpty() and 
            self.m_resInfo:GetConfigTriggerState() == Const.ConfigTriggerState.Normal) then -- 树木,石头点击一下可以直接拾取完
        self:DoOnceCollect()
    else
        self:OnExit()
    end
end

--[[ 播放奖励提示 ]]
function CharacterCollectState:ShowRewardPanel( callback )
    local _param = {}
    _param["triggerId"] = self.m_curTriggerId
    _param["callback"] = function()
        if (callback) then callback() end
        -- 飞动画
        local _targetObj, _itemInfo = self:GetTargetObjAndInfoByCacheId()
        local _targetWorldPos = _targetObj:GetPosition()
        local _screenPos = CS.SceneManager.World:WorldToScreenPoint(_targetWorldPos)
        local _resDetail = _itemInfo:GetRewardImage()
        for _, resInfo in pairs(_resDetail) do
            local resIcon = resInfo["iconpath"]
            local resCount = resInfo["count"]
            UIUtil.DoFly(RewardType.GOODS,resCount,resIcon,_screenPos,Vector3.New(0,0,0))
        end
    end
    UIManager:GetInstance():OpenWindow(UIWindowNames.UI_GetRewardTips, {anim = true, UIMainAnim = UIMainAnimType.AllHide} ,_param)
end

function CharacterCollectState:GetTargetObjAndInfoByCacheId()
    local _itemInfo = DataCenter.SV_MapItemInfoManager:GetItemInfoList():GetTriggerByTriggerId(self.m_curTriggerId)
    if _itemInfo == nil then return nil end
    local _objUuid = _itemInfo:GetUuid()
    local _targetObj = DataCenter.BattleLevel:GetObjMgr():GetObjectByUuid(_objUuid)
    return _targetObj, _itemInfo
end

--[[ 采集帧事件回调 ]]
function CharacterCollectState:RecvCollectEvent()
    local _, _itemInfo = self:GetTargetObjAndInfoByCacheId()
    
    -- 检测是否需要加提示面板
    if (_itemInfo:IsNeedShowRewardTip()) then
        self:ShowRewardPanel(BindCallback(self, self.ToCollectDone))
    else
        if self.m_resInfo:IsNeedShowTriggerGiveTip() then
            local gatherId = self.m_resInfo:GetGatherId()
            UIManager:GetInstance():OpenWindow(UIWindowNames.UITriggerGiveItem, {anim = true}, gatherId,self.m_curTriggerId)
        else
            self:ToCollectDone()
        end
    end
	
	--播放打击音效
	self:PlayWeaponSound() 
end

function CharacterCollectState:ToCollectDone()
    local _targetObj, _itemInfo = self:GetTargetObjAndInfoByCacheId()
    if _targetObj == nil or _itemInfo == nil then
        Logger.LogError('#zlh# 采集过程中 目标没了！ 可能是后端同步消息移除了triggerObj')
        self:OnExit()
        return
    end
    -- 如果当前的类型是4(Normal_WithoutCollect),这种类型不采集,如果配了noviceboot,走Noviceboot
    if (_itemInfo:GetConfigTriggerState() == Const.ConfigTriggerState.Normal_WithoutCollect) then
        local _guideId = tonumber(GetTableData(TableName.PVETrigger, _itemInfo:GetUuid(), "GuideId")) or 0
        if (_guideId ~= 0) then
            DataCenter.GuideManager:SetCurGuideId(_guideId)
            DataCenter.GuideManager:DoGuide()
            return
        end
    end
    --[[ 如果是传送门的点,直接走movelevel,不做下面的处理 ]]
    if _itemInfo ~= nil and _itemInfo:IsEventPortal() then
        self:OnExit()
        local _levelId = _itemInfo:GetUnclockPara2()
        if (not string.IsNullOrEmpty(_levelId)) then
            _levelId = tonumber(_levelId)
            SceneManager.ChangeToLevelById(_levelId)
        end
        return
    end
    self.m_isCollecting = false
    _targetObj:ToCollect() --通知被采集物
    self:SendCollectMsg() --通知后端
    local triggerId = self.m_collectParam["trigger"]
    local levelId = self.m_collectParam["level"]
    if (triggerId == Const.E_TriggerId.Bonfire or 
            _itemInfo:IsAlwaysEventPoint() ) then -- 如果是初始的篝火只是作为一个展示,不走下面的东西
        self:OnExit()
        return
    end
    
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPrograssBar)
    local _objectType = self.m_resInfo:GetObjectType()
    if _objectType == Const.ObjectType.NO_REWARD_NO_TIPS then
        self:OnExit()
    elseif self:CheckEmptyBox() then
        DataCenter.BattleLevel.ObjMgr:ShowAnimation_X(_targetObj:GetDisplayPosition() + Vector3.New(0.1, 0.5, 0.0))
        self:OnExit()
    else
        -- 是否开启背包
        if _itemInfo:IsNeedOpenBag() then
            --如果快捷拾取界面存在且id和当前相同 再次点击手 直接一键拾取
            local window = UIManager:GetInstance():GetWindow(UIWindowNames.UIBagPickUp)
            if window ~= nil and window.View:GetOtherUuid() == BagUtil.TriggerIdToGridUuid(levelId, triggerId) then
                window.View:TakeAll()
                self:OnExit()
                return
            end
            BagUtil.OpenTriggerBag(levelId, triggerId)
        else
            --11类型的不要结束
            local objType = self.m_resInfo:GetObjectType()
            if objType == Const.ObjectType.DeadBody_1  then
                return
            end
            -- 这个地方加一个特殊处理,策划同学想使用openBox动画,进行非箱子的采集.因为openbox是一个循环动画,没有回调的.所以如果不加处理就会造成
            -- 角色播放openbox1后,即不弹背包,动作也不恢复
            local actionName = self:GetFirstAnim()
            -- 按照动作来区分,如果是 采集箱子动作 [OpenBox] 我们通过倒计时的方式来处理
            if actionName == PlayerAnimationName.OpenBox then
                self:OnExit()
                return
            end
        end
    end
end

--[[ 开箱子,这种情况下不能依赖于帧事件,需要走延时回调 ]]
function CharacterCollectState:CollectBox()
    local _collectTime = self.m_resInfo:GetCollectTime()
    self:StopDelayTimer()
    self.delayTimer = TimerManager:GetInstance():DelayInvoke(function()
        self:PlayBoxOpenedAnim()
        self:RecvCollectEvent()
    end, _collectTime)
end

function CharacterCollectState:StopDelayTimer()
    if self.delayTimer ~= nil then
        self.delayTimer:Stop()
        self.delayTimer = nil
    end
end

--[[ 采集 ]]
function CharacterCollectState:DoOnceCollect()
    -- 没有目标直接退出
    if self.m_target == nil or self.m_resInfo == nil then
        self:OnExit()
        return
    end
    
    -- 检测所带武器[因为目前石头和数需要改成点击一下btn,做成连续砍伐,所以需要在这个地方增加一个判定]
    local weaponId = self.m_resInfo:GetTools()
    if not string.IsNullOrEmpty(weaponId) then
        if not DataCenter.BagGridDataManager:HasItemInPocket(weaponId) and not DataCenter.BagGridDataManager:GetEquipGridData():HasItem(weaponId) then
            self:OnExit()
            return
        end
    end
    
    -- 树,资源已经被采完,重新选择
    local objType = self.m_resInfo:GetObjectType()
    if objType ~= Const.ObjectType.Box and 
            objType ~= Const.ObjectType.Monster and
            objType ~= Const.ObjectType.SpecialMonster and
            objType ~= Const.ObjectType.DeadBody and
            objType ~= Const.ObjectType.DeadBody_1 and
            objType ~= Const.ObjectType.EmptyBox then
        if self.m_resInfo:IsResourceEmpty() then
            self:OnExit()
            return
        end
    end
    --[[
        开始进行采集state的处理,这个是为了做是否采集被中断的处理,因为在采集中我们可能是需要装备的.如果被打断[攻击或者直接行走],这个时候没有匹配出现,所以
        我们需要修正武器状态
    ]]
    self.m_playCollectState = true
    local _collectTime = self.m_resInfo:GetCollectTime()
    --首次开箱需要播进度条
    if (not self.m_resInfo:IsClickableTipPoint() and self.m_resInfo:GetObjectType() == Const.ObjectType.Box or
            self.m_resInfo:GetObjectType() == Const.ObjectType.EmptyBox or
            self.m_resInfo:GetObjectType() == Const.ObjectType.SpecialMonster or
            self.m_resInfo:GetObjectType() == Const.ObjectType.DeadBody or
            self.m_resInfo:GetObjectType() == Const.ObjectType.DeadBody_1 or
            self.m_resInfo:GetObjectType() == Const.ObjectType.Monster) then
        if (_collectTime > 0 and not self.m_resInfo:IsGuidePoint()) then
            SUSoundUtil.PlayFirstGatherSound(self.m_resInfo:GetGatherId())
            UIManager:GetInstance():OpenWindow(UIWindowNames.UIPrograssBar, { anim = true }, {objId = self.m_collectParam.objId,totalTime = _collectTime})
        end
        self.m_owner:HideWeapon() --隐藏武器
    end
    
    -- 装带武器
    
    self.requireWeapon = false
    if not string.IsNullOrEmpty(weaponId) then
        self.requireWeapon = true
        self.m_owner:ShowToolEquip(weaponId)
    end

    self:LookAtTarget()
    self:PlayCollectAnim()

    -- 如果是10002关卡的丧尸,先做引导
    if self.m_curTriggerId == Const.E_TriggerId.Level_10002_DeadBody then
        self.m_target:HideSelectVFX()
        local _guideId = tonumber(GetTableData(TableName.PVETrigger, self.m_curTriggerId, "GuideId"))
        if (_guideId ~= 0) then
            DataCenter.GuideManager:SetCurGuideId(_guideId)
            DataCenter.GuideManager:DoGuide()
        end
    end

    
    self.m_isCollecting = true
    local _targetObj = self:GetTargetObjAndInfoByCacheId() --这里为什么不用self.m_target，因为有可能时第二次采集，而self.m_target没有更新过，可能存在别的地方删除了对象而self.m_target还存在的情况
    if _targetObj ~= nil and _targetObj.StartCollect ~= nil then
        _targetObj:StartCollect()
    end
end

-- 找到对象实体后,直接朝向
function CharacterCollectState:LookAtTarget()
    if self.m_target == nil then
        return
    end
    
    local objPos = self.m_target:GetPosition()
    self.m_owner:LookAt(objPos)
end

function CharacterCollectState:GetFirstAnim()
    -- 播放动画
    local actionName = self.m_resInfo:GetCollectActionName()
    local tabAniName = string.string2array_s(actionName, "|")
    if (table.count(tabAniName) > 0) then
        actionName = tabAniName[1]
    end
    return actionName
end

function CharacterCollectState:GetSecondAnim()
    -- 播放动画
    local actionName = self.m_resInfo:GetCollectActionName()
    local tabAniName = string.string2array_s(actionName, "|")
    local actionName1 = ""
    local actionName2 = ""
    if (table.count(tabAniName) > 0) then
        actionName1 = tabAniName[1]
    end
    if (table.count(tabAniName) > 1) then
        actionName2 = tabAniName[2]
    else
        actionName2 = actionName1
    end
    return actionName2
end

function CharacterCollectState:PlayNormalAnim()
    -- 播放动画
    local actionName = self:GetFirstAnim()
    if not string.IsNullOrEmpty(actionName) then
        self.m_owner:PlayAnim(actionName)
    end
end

function CharacterCollectState:PlayBoxOpenedAnim()
    -- 播放动画
    local actionName = self:GetSecondAnim()
    if not string.IsNullOrEmpty(actionName) then
        self.m_owner:PlayAnim(actionName)
    end
end

--[[ 开始播放对应的采集动画 ]]
function CharacterCollectState:PlayCollectAnim()
    local actionName = self:GetFirstAnim()
    local levelId = self.m_collectParam["level"]

    -- 不是首次开启,这个时候有可能是新点击打开背包,也有可能是全部拾取
    local triggerId = self.m_collectParam["trigger"]
    if triggerId == Const.E_TriggerId.Bonfire  then
        self:RecvCollectEvent()
        return
    end
    
    ---- 10002关卡女丧尸直接播放引导
    --if triggerId == Const.E_TriggerId.Level_10002_DeadBody then
    --    local _guideId = tonumber(GetTableData(TableName.PVETrigger, triggerId, "GuideId"))
    --    if (_guideId ~= nil) then
    --        DataCenter.GuideManager:SetCurGuideId(_guideId)
    --        DataCenter.GuideManager:DoGuide()
    --    end
    --    self:RecvCollectEvent()
    --    return
    --end
    
    local window = UIManager:GetInstance():GetWindow(UIWindowNames.UIBagPickUp)
    if window ~= nil and window.View:GetOtherUuid() == BagUtil.TriggerIdToGridUuid(levelId, triggerId) then
        -- 这种情况下不做动画播放
    else
        if (self.m_resInfo:GetObjectType() == Const.ObjectType.Box or
                self.m_resInfo:GetObjectType() == Const.ObjectType.EmptyBox) then
            local _collectTime = self.m_resInfo:GetCollectTime()
            if _collectTime > 0 then
                -- 表示箱子首次开启
                self:PlayNormalAnim()
            else
                self:PlayBoxOpenedAnim()
            end
        else
            self:PlayNormalAnim()
        end
    end
    EventManager:GetInstance():Broadcast(EventId.SU_BeginToPlayCollectAnim, self.m_resInfo.triggerId)

    -- 按照动作来区分,如果是 采集箱子动作 [OpenBox] 我们通过倒计时的方式来处理
    if actionName == PlayerAnimationName.OpenBox then
        self:CollectBox()
    end
end


--[[
    是否是空的引导点箱子[在配置中就是空的],这种情况下直接弹一个 X 的提示,同时将这个引导点 trigger finish掉
]]
function CharacterCollectState:CheckEmptyBox()
    local _objectType = self.m_resInfo:GetObjectType()
    if (_objectType == Const.ObjectType.Box ) then --and _isGuidPoint
        local _reward = self.m_resInfo:GetReward()
        if (table.count(_reward) == 0) then
            return true
        end
    end
    return false
end

function CharacterCollectState:PlayWeaponSound()
    --Logger.Log('#zlh# step in CharacterCollectState:PlayWeaponSound!')
    if self.m_owner == nil or not self.requireWeapon then
        return
    end

    local currentEquip = self.m_owner:GetWeaponName()
    if currentEquip then
        SUSoundUtil.PlayWeaponGatherEffect(currentEquip)
    end
end

--这个函数仅用与更新数据并同步至服务器
function CharacterCollectState:SendCollectMsg()
    self.m_collectParam["state"] = Const.TriggerState.TriggerFinish
    local triggerType = tonumber(GetTableData(TableName.PVETrigger, self.m_collectParam["trigger"], "UnclockPara"))

    -- 如果是怪物的尸体,则不需要发送Update的消息
    if triggerType == Const.TriggerType.LevelZombie or self.m_resInfo:IsAlwaysEventPoint() then
        return
    end

    --[[
        在这块,我们普通的资源点给其hp=0(默认值而已),需要砍多次的hp=xx,每采集一次 hp-1,
        当hp != 0 的时候,我们发送消息更新其进度
        当hp == 0 的时候,发送消息设置状态为已采集完成
    ]]

    if (self.m_resInfo:IsResourceEmpty()) then -- 被采集完全
        if (self.m_resInfo:IsFinished() == false) then
            self.m_resInfo:SetFinished()
            self.m_collectParam["hp"] = self.m_resInfo:GetCurCutDownCnt()
            SFSNetwork.SendMessage(MsgDefines.SU_PveTriggerUpdate, self.m_collectParam)
            self:AddDurability()
            self.m_owner.hunger:OnPickLoseHunger() --采集扣饥饿值
        end
    else
        -- 更新状态
        self.m_collectParam["state"] = Const.TriggerState.TriggerUpdateState
        self.m_collectParam["hp"] = self.m_resInfo:GetCurCutDownCnt()
        SFSNetwork.SendMessage(MsgDefines.SU_PveTriggerUpdate, self.m_collectParam)
        self:AddDurability()
        self.m_owner.hunger:OnPickLoseHunger() --采集扣饥饿值
    end
end

function CharacterCollectState:AddDurability()
    local toolsId = self.m_resInfo:GetTools()
    if (not string.IsNullOrEmpty(toolsId)) then
        local hasAdd = false
        toolsId = tonumber(toolsId)
        local griduuid = DataCenter.BagGridDataManager:GetEquipGridUuid()
        local gridData = DataCenter.BagGridDataManager:GetGridData(griduuid)
        if gridData then
            local bagItemData = gridData:GetSlotData(4)
            if bagItemData and bagItemData.itemId == toolsId then
                local idxs = {}
                table.insert(idxs, 4)
                DataCenter.BagGridDataManager:AddEquipDurability(idxs, -1)
                hasAdd = true
            end
            if hasAdd == false then
                bagItemData = gridData:GetSlotData(6)
                if bagItemData and bagItemData.itemId == toolsId then
                    local idxs = {}
                    table.insert(idxs, 6)
                    DataCenter.BagGridDataManager:AddEquipDurability(idxs, -1)
                    hasAdd = true
                end
            end
        end
        if hasAdd == false then
            DataCenter.BagGridDataManager:AddPocketDurability(toolsId, -1)
        end
    end
end

function CharacterCollectState:AllowStopByType(type)
    -- return CharacterStateType.Die == type
    -- 采集先允许任何状态打断，以后状态流程调整后再改
    return true
end

function CharacterCollectState:StopCollect()
    local _targetObj = self:GetTargetObjAndInfoByCacheId()
    if _targetObj ~= nil and _targetObj.StopCollect ~= nil then
        _targetObj:StopCollect()
    end
end

function CharacterCollectState:OnExit()
    self:__removeEvent()
    
    if self.m_isCollecting then
        self:StopCollect()
    end
    if (self.m_playCollectState == true and self.requireWeapon) then
        self.m_owner:ResetWeapon()
    end
    self.m_owner:ShowWeapon() --显示武器  这块是在采箱子的时候我们需要隐藏武器,但是在退出的时候,我们需要显示武器
    self:StopDelayTimer()
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPrograssBar)
    self.m_target = nil
    self:OnStateComplete(self.requireWeapon)
end

return CharacterCollectState