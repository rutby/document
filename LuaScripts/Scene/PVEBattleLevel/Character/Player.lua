---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2022/9/22 15:12
---主角，玩家操控的人物
local CharacterBase = require("Scene.PVEBattleLevel.Character.CharacterBase")
local Player = BaseClass("CharacterBase",CharacterBase)
local Const = require("Scene.PVEBattleLevel.Const")
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local PlayerSemiAutoAI = require("Scene.PVEBattleLevel.Character.AI.PlayerSemiAutoAI")
local PlayerLevelAutoAI = require("Scene.PVEBattleLevel.Character.AI.PlayerLevelAutoAI")
local SU_Util = require("Scene.PVEBattleLevel.Utils.SU_Util")
local PlayerHunger = require "Scene.PVEBattleLevel.Character.PlayerHunger"
local CharacterHP = require "Scene.PVEBattleLevel.Character.CharacterHP"
local PveHeroHungerBar = require "Scene.PVEBattleLevel.UI.PveHeroHungerBar"
local PlayerLevel = require "Scene.PVEBattleLevel.Character.PlayerLevel"
local PlayerSkin = require "Scene.PVEBattleLevel.Character.PlayerSkin"
local MiniMapUtil = require "Scene.PVEBattleLevel.Utils.MiniMapUtil"
local PvePlayerInfo = require "DataCenter.Survival.Character.PvePlayerInfo"
local Shader = CS.UnityEngine.Shader
local SU_BuildRoofUtil = require "Scene.PVEBattleLevel.Utils.SU_BuildRoofUtil"
local SU_AutoAIModule = require "Scene.PVEBattleLevel.Character.PlayerAutoAIModule"
local SU_ColliderEventUtil = require "Scene.PVEBattleLevel.Utils.SU_ColliderEventUtil"

local CloseUITutorialAnimationTime = 1
local StartMoveTriggerGuideTime = 1.5
--人物状态
local State = {
    Normal = "Normal",      -- 正常
    Sneak = "Sneak",        -- 潜行
    Weakness = "Weakness"   -- 虚弱
}

local function RandomDefaultAttackAnimName()
    local anims = {[1] = "atk1_kongshou",[2] = "atk2_kongshou",[3] = "atk3_kongshou",[4] = "atk4_kongshou"}
    local index = math.random(1,#anims)
    return anims[index]
end

function Player:BeginToBuild()
    self:SetState(CharacterStateType.Build)
end

function Player:BeginToPickGarbage(anim)
    self:SetState(CharacterStateType.PickGarbage, anim)
end

function Player:EndBuild()
    local currentState = self.m_stateManager:GetCurrentState()
    if currentState ~= nil and currentState:GetType() == CharacterStateType.Build then
        self:Idle()
    end
end

function Player:EndPickGarbage()
    local currentState = self.m_stateManager:GetCurrentState()
    if currentState ~= nil and currentState:GetType() == CharacterStateType.PickGarbage then
        self:Idle()
    end
end

function Player:__init(battleLevel,objId,playerInfo,prefabName) 
    CharacterBase.__init(self,battleLevel,objId,playerInfo)
    self.isPlayer = true --暂时还叫这个名字
    self.isReady = false
    self.readyCallback = nil
    self.prefabName = prefabName
    self.m_isCollecting = false -- 正在长按采集
    self.state = State.Normal
    self.m_roofUtil = SU_BuildRoofUtil.New()
    self.m_colliderEventUtil = SU_ColliderEventUtil.New()
    self.m_isAIMode = false;
    self.m_AutoAIModule = battleLevel:IsHeroBossLevel() and PlayerLevelAutoAI.New(self) or SU_AutoAIModule.New(self)
	self.m_lastPos = {} -- 上一次玩家的位置
    self.m_gravity = Vector3.New(0,0,0)
    self:AddListener(EventId.SU_ClickToChangeViewMode, self.CheckRoleTopArrowBtn)
    
    self.isAutoAttack = false --是否自动射击

    local _levelId = self.battleLevel:GetSpecialLevelId()
    self.needPlayFootprint = tonumber(SU_Util.GetItemConfig(_levelId, "foot_print")) == 1
    self:SetCurrentGroundType(SurvivalGroundType.None)
    self.m_delayGravity = false
end

function Player:CheckRoleTopArrowBtn( viewMode )
    print(">>>CheckRoleTopArrowBtn " .. tostring(viewMode))
    if (viewMode == ViewMode.RPG) then
        self.arrow.gameObject:SetActive(false)
    end
end

function Player:StartAIMode()
    if self:IsDie() then
        return
    end
    self.m_isAIMode = true
    if (self.m_AutoAIModule ~= nil) then
        self.m_AutoAIModule:StartAI()
    end
end
function Player:StopAIMode()
    self.m_isAIMode = false
    if (self.m_AutoAIModule ~= nil) then
        self.m_AutoAIModule:StopAI()
    end
end
function Player:IsAIMode()
    return self.m_isAIMode
end
function Player:GetTargetInAIMode()
    if (self.m_isAIMode == true) then
        return self.m_AutoAIModule:GetTarget()
    end
    return nil
end

-- 初始化头部功能区域
function Player:InitHeadFunction()
	local topTf = self.m_transform:Find("PveHero_Top")
	if topTf then
		self.top_transform = topTf
		self.top_transform.gameObject:SetActive(true)

		local hungerBar = topTf:Find("PVEHero_Hunger")
		if not IsNull(hungerBar) then
			self.hungerBar = PveHeroHungerBar.New(hungerBar.gameObject)
			self.hungerBar:SetActive(false)
		end

		local arrow = topTf:Find("PVEHero_Arrow")
		if not IsNull(arrow) then
			self.arrow = arrow
            self.arrow.gameObject:SetActive(false)
			self.arrowTrigger = arrow:Find("Trigger"):GetComponent(typeof(CS.TouchObjectEventTrigger))
			self.arrowTrigger.onPointerClick = BindCallback(self, self.OnArrowTriggerClick)
            self.arrowImg1 = arrow:Find("Arrow"):GetComponent(typeof(CS.UnityEngine.SpriteRenderer))
            self.arrowImg2 = arrow:Find("Arrow/image"):GetComponent(typeof(CS.UnityEngine.SpriteRenderer))
			self.isSlg = DataCenter.BattleLevel:GetViewMode() == ViewMode.SLG
            self.zoom = 0
            self.maxZoom = DataCenter.BattleLevel:GetCamera():GetZoomMax(ViewMode.SLG)
            self.initZoom = DataCenter.BattleLevel:GetCamera():GetBubbleInitSLGZoom()
		end
	end
end

--设置头部功能图标是否显示
function Player:SetHeadFunctionVisible(visible)
    if self.top_transform ~= nil then
        self.top_transform.gameObject:SetActive(visible)
    end
end


-- 释放头部功能的交叉变量
function Player:DestroyHeadFunction()
	if self.arrowTrigger then
		self.arrowTrigger.onPointerClick = nil
	end
	
	self.arrowTrigger = nil
	self.isSlg = nil
	self.zoom = nil
	self.hungerBar = nil
	self.top_transform = nil
end

function Player:__assetCreateComplete()
    CharacterBase.__assetCreateComplete(self)
    self.m_transform.gameObject.name = "PVEPlayer"
    
	self:InitHeadFunction()
	
    self.info:initEquip()
	
	-- 根据当前关卡设置当前角色移动基础速度
	local levelId = self:GetCurLevelId()
	local move_speed = tonumber(SU_Util.GetItemConfig(levelId, "move_speed"))
	local sneak_speed = tonumber(SU_Util.GetItemConfig(levelId, "move_sneak"))
	local weakness_speed = tonumber(SU_Util.GetItemConfig(levelId, "move_weakness"))
	self.info:SetBaseMoveSpeed(move_speed,sneak_speed,weakness_speed)
	
	-- 装备相关
	self.EquipSlotChangedHandler = function(data) self:EquipSlotChanged(data) end
	self.InfoChangedHandler = function(update_info) self:OnInfoChanged(update_info) end
	self.info:AddListener(PvePlayerInfo.PvePlayerInfoEventId.EquipChanged, self.EquipSlotChangedHandler)
	self.info:AddListener(PvePlayerInfo.PvePlayerInfoEventId.InfoChanged, self.InfoChangedHandler)

    if self:GetCurLevelId() ~= 10002 then
        self.m_skin = PlayerSkin.New(self.m_transform,self.info,self.m_gameObject.layer)
    end

    self:CreateMiniMapIcon()
    
    self:SetAnimSpeed(1) --人物资源是复用的，这里重置一下
    self:SetAnimFloat("speed",1) --人物资源是复用的，这里重置一下

    self:ReInit()
    
    self.isReady = true
    if self.readyCallback then
        self.readyCallback()
        self.readyCallback = nil
    end

    --这块先这样处理。等主角创建完后，等待两秒就将主角的碰撞器打开。主要是为了处理
    --主角第一次上线，在房车内，第一次触发是否在房车内的情况
    TimerManager:GetInstance():DelayInvoke(function()
        if not IsNull(self.m_characterController) and not self.m_characterController.enabled then
            self.m_characterController.enabled = true
        end
    end, 2)
end

function Player:InitPosAndRot()
    self:SetPosition(self.battleLevel:GetSpawnPos())
    local spawnRotation = self.battleLevel:GetLevelTemplate().spawnRotation
    self:SetRotation(Quaternion.Euler(0, spawnRotation, 0))
--    self:GetTransform().localScale = Vector3.New(1,1,1)
	self:GetTransform():Set_localScale(1,1,1)
end

function Player:ReInit()
    self:InitPosAndRot()
    
    self:Idle()

    -- 这个地方缓存一下骨骼数据,为了timeline做骨骼数据还原使用
    self:GetGameObject():CacheCurModel()

	--人物本身加个碰撞监听
	self.triggerHandler = self.m_transform.gameObject:GetComponent(typeof(CS.ColliderEventHandler)) 
	if self.triggerHandler ~= nil then
		self.initTime = 0
		self.bindTriggerHandlerEnd = false
		--Logger.LogError("------bind triggerHandler------")
		self.triggerHandler.OnTriggerEnterAction = function(obj) self:OnTriggerEnter(obj) end
		self.triggerHandler.OnTriggerExitAction = function(obj) self:OnTriggerExit(obj) end
	end
    
    self.ai = PlayerSemiAutoAI.New(self)

	-- 数值体系
    self.hunger = PlayerHunger.New(self)
    self.HP = CharacterHP.New(self)
    self.HP:AddHpBar(self.top_transform,true)
    self.level = PlayerLevel.New(self)
    
    local _levelId = self.battleLevel:GetSpecialLevelId()
    self:InitLight(_levelId)

    if self.HP:GetCurBlood() <= 0 then
        self:Die()
        UIManager:GetInstance():OpenWindow(UIWindowNames.UIPVELose, { anim = false })
    end

	local levelId = self:GetCurLevelId()
    self.m_characterController = self.m_transform:GetComponent(typeof(CS.UnityEngine.CharacterController))
    --因为OnUpdate中加了重力代码，一开始启动的时候会抽，需要先禁止掉，等移动的时候再打开
    self.m_characterController.enabled = false
    self.m_characterController.slopeLimit = tonumber(SU_Util.GetItemConfig(levelId, "player_slope_limit")) or 40
    self.m_characterController.stepOffset = tonumber(SU_Util.GetItemConfig(levelId, "player_step_offset")) or 0.1

    if self.battleLevel:IsHeroBossLevel() then
        self:ShowCircleEffect()
    end

    EventManager:GetInstance():Broadcast(EventId.SU_PlayerCreateComplete)
end
--初始化天气时间组件和人物身上的灯
function Player:InitLight( levelId )
    self.skyTimeline = self.battleLevel:GetSkyTime()
    local lightTransform = self.m_transform:Find("Point Light")
    if lightTransform ~= nil then
        self.light = lightTransform.gameObject
        self.light:SetActive(false)
        --根据配置设置主角灯光强度
        local lightCom = self.light:GetComponent(typeof(CS.UnityEngine.Light))
        if lightCom ~= nil then
            lightCom.intensity = tonumber(SU_Util.GetItemConfig(levelId, 'focus_light')) or 10
            --local shadowType = tonumber(SU_Util.GetItemConfig(levelId, 'shadow_type')) or 0
            --lightCom.shadows = Mathf.Clamp(shadowType, 0, 2)
        end
    end
    self.checkLightTime = 0
end

function Player:CheckToggleLight(deltaTime)
    if self.skyTimeline ~= nil and self.light ~= nil then
        --0.5秒检测一次
        self.checkLightTime = self.checkLightTime + deltaTime
        if self.checkLightTime < 0.5 then
            return
        end
        self.checkLightTime = 0
        
        local timeline = self.skyTimeline:GetTime()
        if timeline >= 18.9 or timeline <= 6.45 then
            if not self.light.activeSelf then
                self.light:SetActive(true)
            end
        else
            if self.light.activeSelf then
                self.light:SetActive(false)
            end
        end
    end
end

--添加重力，防止浮空情况，PS：虽然在移动的时候用的函数有重力，但是移动到浮空中停止移动后还是会浮空，现在有不同高度的地形，所以需要计算重力
function Player:CheckGravity(deltaTime)
    --刚复活,延迟重力检测，解决死亡后下线，再上线重置坐标，马上进行重力检测坐标会错误的BUG
    if self.m_delayGravity then
        self.m_delayGravity = false
        return
    end
    if not IsNull(self.m_characterController) and self.m_characterController.enabled then
        if not self.m_characterController.isGrounded then
            --Logger.LogError("Player:CheckGravity")
            self.m_gravity.y = self.m_gravity.y + -10 * deltaTime

            self.m_characterController:Move(self.m_gravity * deltaTime)
        else
            self.m_gravity.y = 0
        end
    end
end
--重置主角行为和状态
function Player:Reset()
    if self.ai == nil then
        return
    end
    self.ai:Stop()
    self.m_stateManager:ExitCurrentState()
    print("*********  reset idle")
    self:Idle()
end

function Player:GetCurrentStateType()
    if (self.m_stateManager ~= nil) then
        return self.m_stateManager:GetCurrentStateType()
    end
    return CharacterStateType.Default
end

function Player:BeAttack(attackNum, damageType)
    if self.m_stateManager:GetCurrentStateType() == CharacterStateType.StrideOver or LuaEntry.Player:GetIsNeverDie() == true then
        --翻越的时候无敌
        return
    end
    damageType = damageType or Const.DamageType.TargetAttack
    CharacterBase.BeAttack(self, attackNum)
    
    local _curLevelId = self:GetCurLevelId()
    if ( _curLevelId ~= 10002 and
            damageType == Const.DamageType.TargetAttack and 
            self.m_stateManager ~= nil and 
            self.m_stateManager:GetCurrentState() ~= nil and 
            self.m_stateManager:GetCurrentState():GetType() == CharacterStateType.Collect) then
        self:Idle()
    end
    
    --不是英雄关才扣除装备耐久
    if damageType == Const.DamageType.TargetAttack and self.battleLevel:CanConsumeEquipLevel() then
        local idxs = {}
        table.insert(idxs, 0)
        table.insert(idxs, 1)
        table.insert(idxs, 2)
        table.insert(idxs, 3)
        DataCenter.BagGridDataManager:AddEquipDurability(idxs, -1)
    end

    if self:GetCurBlood() <= 0 then
        self:SetCauseOfDeath(799008)
    end

    if damageType == Const.DamageType.TargetAttack then
        --震屏
        if self.shakeParam == nil then
            local shakeParamStr = LuaEntry.DataConfig:TryGetStr("camera_fragment", "k10")
            self.shakeParam = string.string2array_f(shakeParamStr,"|")
        end
        local duration = self.shakeParam[1] or 0.2 --震屏时间（秒）
        local magnitude = self.shakeParam[2] or 0.02 --震屏幅度（米）
        local vibrato = self.shakeParam[3] or 5  --震屏次数/秒
        local subMagnitude = self.shakeParam[4] or 0.8  --每次递减倍数

        self.battleLevel:GetCamera():Shake(duration,magnitude,vibrato,subMagnitude)
    end
end

function Player:EquipSlotChanged(data)
    self.m_skin:EquipSlotChanged(data)
    local partType = data["partType"]
    if partType == SurvivalEquipType.Weapon then
        self.m_stateManager:ChangeCharacterState()
    end
end

-- 参数为更新的数据
function Player:OnInfoChanged(update_info)
	if update_info == nil then
		return 
	end
	
	if update_info.hp_changed then
    	self.HP:UpdateHpBarVal(self.info:GetCurBlood(),self.info:GetMaxBlood())
	end
	
end

function Player:CreateMiniMapIcon()
    local param = {
        parentNode = self.m_transform,
        iconName = 'Icon_small_11',
        orderInLayer = MiniMapUtil.DefaultOrder.Player,
        yRotation = 40,
        scale = Vector3.New(2.6, 2.6, 1),
        localPosition = Vector3.New(-0.06, 0, 0.39)
    }
    self.miniMapIconRequest = MiniMapUtil.CreateMiniIcon(param)
end

function Player:DestroyMiniMapIcon()
    if self.miniMapIconRequest ~= nil then
        self.miniMapIconRequest:Destroy()
        self.miniMapIconRequest = nil
    end
end

function Player:OnUpdate(deltaTime)
	ProfilerUtil.BeginSample("[Lua]Player:OnUpdate")

    if self.isSlg ~= nil then
        local bl = self.battleLevel
        if self.isSlg ~= (bl:GetViewMode() == ViewMode.SLG) then
            self.isSlg = bl:GetViewMode() == ViewMode.SLG
            if self.hunger ~= nil then
                self.hunger:OnCheck()
            end
        end

        --头顶箭头不要了
        --if self.arrow ~= nil and not bl:IsChangeViewMode() then
        --    if self.isSlg then
        --        local zoom = bl:GetCamera():GetZoom()
        --        if math.abs(zoom - self.zoom) > 0.1 then
        --            self.zoom = zoom
        --            local tempZoom = math.min(zoom, self.maxZoom)
        --            local x, y, z = self.m_transform:Get_localScale()
        --            local scale = tempZoom / self.initZoom / x * 5.2
        --            self.arrow.transform:Set_localScale(scale, scale, scale)
        --        end
        --
        --        local characterDialog = DataCenter.CharacterDialogManager:GetCharacterDialogByObjId(self.m_objId)
        --        local showDialog = characterDialog ~= nil and characterDialog:IsShow()
        --        local worldTileUIShow = false
        --        if UIManager:GetInstance():IsPanelLoadingComplete(UIWindowNames.UIWorldTileUI) then
        --            local window = UIManager:GetInstance():GetWindow(UIWindowNames.UIWorldTileUI)
        --            if window ~= nil and window.View ~= nil and window.View.activeSelf then
        --                worldTileUIShow = true
        --            end
        --        end
        --        local buildUpgradeShow = false
        --        if UIManager:GetInstance():IsPanelLoadingComplete(UIWindowNames.UINewBuildUpgrade) then
        --            local window = UIManager:GetInstance():GetWindow(UIWindowNames.UINewBuildUpgrade)
        --            if window ~= nil and window.View ~= nil and window.View.activeSelf then
        --                buildUpgradeShow = true
        --            end
        --        end
        --
        --        if UIManager:GetInstance():IsPanelLoadingComplete(UIWindowNames.UINewBuildUpgrade) then
        --            local window = UIManager:GetInstance():GetWindow(UIWindowNames.UINewBuildUpgrade)
        --            if window ~= nil and window.View ~= nil and window.View.activeSelf then
        --                buildUpgradeShow = true
        --            end
        --        end
        --        self.isArrowShow = not showDialog and not worldTileUIShow and not buildUpgradeShow
        --        self.arrow.gameObject:SetActive(self.isArrowShow)
        --        if self.arrowImg1 ~= nil and self.arrowImg1.enabled == false then
        --            self.arrowImg1.enabled = true
        --        end
        --        if self.arrowImg2 ~= nil and self.arrowImg2.enabled == false then
        --            self.arrowImg2.enabled = true
        --        end
        --    else
        --        if self.isArrowShow then
        --            self.zoom = 0
        --            self.arrow.gameObject:SetActive(false)
        --            self.isArrowShow = false
        --            self.arrow.transform:Set_localScale(1, 1, 1)
        --        end
        --    end
        --end
    end
    
    if self.m_isPause then
		ProfilerUtil.EndSample()
        return
    end
    
    CharacterBase.OnUpdate(self,deltaTime)
    if self.ai then
        self.ai:OnUpdate(deltaTime)
    end
    if self.HP then
        self.HP:OnUpdate(deltaTime)
    end
    if self.hunger then
        self.hunger:OnUpdate(deltaTime)
    end
    if self.m_AutoAIModule then
        self.m_AutoAIModule:OnUpdate(deltaTime)
    end
    if self.initTime ~= nil then
        self.initTime = self.initTime + deltaTime
    end
    self:CheckToggleLight(deltaTime)
    
	-- 玩家每次移动的时候同步一下AudioListener的位置
	local cur_pos = self:GetPosition()
	if self.m_lastPos.x ~= cur_pos.x or 
		self.m_lastPos.y ~= cur_pos.y or
		self.m_lastPos.z ~= cur_pos.z then
		--SUSoundUtil.SyncListenerPos(cur_pos.x, cur_pos.y, cur_pos.z)
		self.m_lastPos.x = cur_pos.x
		self.m_lastPos.y = cur_pos.y
		self.m_lastPos.z = cur_pos.z
	end

    self:UpdateAddBloodEffPos()
    
    self:CheckGravity(deltaTime)
    
    ProfilerUtil.EndSample()

    self:CheckKeyBoard()
end

-- 关闭引导指示窗口
function Player:CloseTutorialWindow()
    -- 指示窗口
    local t = UIManager:GetInstance():IsWindowOpen(UIWindowNames.UITutorialAnimation)
    if t and not self.timer then
        self.timer = TimerManager:GetInstance():DelayInvoke(function()
            UIManager:GetInstance():DestroyWindow(UIWindowNames.UITutorialAnimation)
            self.timer = nil
        end, CloseUITutorialAnimationTime)
    end
    if self.startMoveTimer == nil then
        self.startMoveTimer = TimerManager:GetInstance():DelayInvoke(function()
            self.startMoveTimer = nil
            DataCenter.GuideManager:CheckDoTriggerGuide(GuideTriggerType.PrologueStartMove, SaveGuideDoneValue)
        end, StartMoveTriggerGuideTime)
    end

end

--为了兼容老接口
function Player:Walk(vx,vz,length)
    if self.m_transform == nil then
        return
    end

    self:CloseTutorialWindow()
    
    if self.ai then
        self.ai:Stop()
    end
    self:Move(vx,vz,length)
end

function Player:SetState(type,data)
    -- 每次修改状态的时候,修正武器状态,在接下来的state中重新设置成当前所要求的显隐
    self:ShowWeapon()
    local preState = self:GetStateManager():GetCurrentStateType()
    CharacterBase.SetState(self,type,data)
    self:CancelGarbageCollect(preState, type)
    EventManager:GetInstance():Broadcast(EventId.SU_SetCurPlayerState, type)
end

function Player:CancelGarbageCollect(preState, curState)
    if curState == CharacterStateType.PickGarbage then
        return
    end
    if curState == CharacterStateType.Default then
        return
    end
    local mainRoleQueue = DataCenter.BuildQueueManager:GetMainRoleQueue()
    if mainRoleQueue and mainRoleQueue.state == RobotState.SU_Collect then
        local girlQueueData = DataCenter.GirlBehaviorManager:GetQueueData(mainRoleQueue.uuid)
        if girlQueueData then
            DataCenter.GirlBehaviorManager:CancelCollect(girlQueueData.triggerId, girlQueueData.robotUuid)
        end
    end
end

function Player:OnStateComplete(type,data)
    CharacterBase.OnStateComplete(self,type,data)
    if type == CharacterStateType.Attack or type == CharacterStateType.Collect then
        local needInertialIdle = true
        if type == CharacterStateType.Collect then
            if self:IsAIMode() then
                needInertialIdle = false
                self:ResetWeapon()
            elseif self:IsCollecting()  then
                --连续采集处理逻辑
                self.ai:CheckTarget()
                local obj = self.ai:GetLastItemObjSelected()
                if obj ~= nil and
                        obj.GetObjectType ~= nil and (obj:GetObjectType() == Const.ObjectType.Tree or obj:GetObjectType() == Const.ObjectType.Normal) and
                        obj:GetInfo() ~= nil and not obj:GetInfo():IsResourceEmpty() then
                    needInertialIdle = false
                    self:ResetWeapon()
                    self.ai:MoveToCollect()
                end
            end
        end
        
        if needInertialIdle then
            self:SetState(CharacterStateType.InertialIdle,{type = type,isCollectTools = data})
        end
    end
    EventManager:GetInstance():Broadcast(EventId.SU_PlayerStateDone, type)
end
--采集
function Player:MoveToCollect( presstype )
    if (presstype == Const.FingerAction.Down) then
        self.m_isCollecting = true
        if self.ai ~= nil then
            self.ai:MoveToCollect()
        end
    else
        self.m_isCollecting = false
    end
end

function Player:MoveToTargetAndCollect(target)
    --self.m_isCollecting = true
    if self.ai ~= nil then
        self.ai:MoveToTargetAndCollect(target) 
    end
end

function Player:IsCollecting()
    return self.m_isCollecting
end

function Player:Attack(target)
    CharacterBase.Attack(self,target)
    --采集显示洗澡提示
    DataCenter.BatheManager:CheckShowBatheDialog()
end

--[[ 角色开始采集,直接执行collect state,在状态机里做具体动作等处理 ]]
function Player:Collect(target)
    local _objId = target:GetUuid()
    local _itemInfo = DataCenter.SV_MapItemInfoManager:GetItemInfoList():GetItemInfoByUuid(_objId)
    if (_itemInfo == nil) then return end

    --采集显示洗澡提示
    DataCenter.BatheManager:CheckShowBatheDialog()

    local toolsId = _itemInfo:GetTools()
    if (not string.IsNullOrEmpty(toolsId)) then
        self.needShowWeapon = true
        if (not DataCenter.BagGridDataManager:HasItemInPocket(toolsId) and not DataCenter.BagGridDataManager:GetEquipGridData():HasItem(toolsId)) then
            local goodTemplate = DataCenter.ItemTemplateManager:GetItemTemplate(toolsId)
            UIUtil.ShowSUMainMsg(Localization:GetString("799018", Localization:GetString(goodTemplate.name)), SurvivalTipsColor.BagFull_Orange)
            self:Idle()
            return
        end
    else
        self.needShowWeapon = false
    end
    
    --针对非箱子的采集物才检查口袋是否可以放下，，，怪物的尸体也同样处理！
	local objType = _itemInfo:GetObjectType()
	if objType ~= Const.ObjectType.Box and objType ~= Const.ObjectType.Monster and objType ~= Const.ObjectType.SpecialMonster and objType ~= Const.ObjectType.DeadBody and objType ~= Const.ObjectType.DeadBody_1 then
        local _reward = _itemInfo:GetReward()
        for itemId, itemNum in pairs(_reward) do
            if (not BagUtil.CanPutItemInPocket(itemId, itemNum)) then
                Logger.Log("CannotPutItem itemId:" , tostring(itemId) , ', itemNum:' , tostring(itemNum))
                UIUtil.ShowSUMainMsgId(799017)
                return
            end
        end
    end

    local _trigger = _itemInfo:GetTriggerId()
    local _level = self:GetCurLevelId()
    local param = { ["trigger"] = _trigger, ["level"] = _level, ["objId"] = _objId }
    self:SetState(CharacterStateType.Collect,param)
    --self.ai:UnlockTriggerId()
end
--跨越
function Player:StrideOver(target)
    self:SetState(CharacterStateType.StrideOver,target)
end

function Player:MoveToAttack()
    self.m_attacking = true
    if self.attackIntervalTime ~= nil and self.attackIntervalTime > Time.time then
        return--没有到下次攻击时间
    end
    if self.ai ~= nil then
        self.ai:MoveToAttack()
    end
end

function Player:MoveToBuild()
    if self.ai ~= nil then
        self.ai:MoveToBuild()
    end
end

function Player:MoveToTargetBuild(build, callback)
    if self.ai ~= nil then
        self.ai:MoveToTargetBuild(build, callback)
    end
end

function Player:MoveToQuestTarget(data)
    if self.ai ~= nil then
        self.ai:MoveToQuestTarget(data)
    end
end

function Player:StopAI()
    if self.ai ~= nil then
        self.ai:Stop()
    end
end

function Player:AttackEnemy(enemy)
    if enemy == nil or enemy:IsDie() then
        return
    end
    local attackNum = self:GetAttack()
    if self.isSuperMan then
        attackNum = 999
    end
    if self:IsSneak() then
        local angle = SU_Util.GetAngle(enemy:GetPosition(), self:GetPosition());
        angle = Mathf.Abs(angle - enemy:GetTransform().localEulerAngles.y % 360);
        if angle > 60 and angle < 300 then
            attackNum = attackNum * 3
        end
    end
    local weaponData = self:GetWeaponSpecialData()
    local data
    if weaponData ~= nil then
        data = {}
        data.weaponData = weaponData
        data.dir = Vector3.Normalize(self:GetPosition() - enemy:GetPosition())
    end

    enemy:BeAttack(attackNum,data)
    
    self:Sneak(false)

    EventManager:GetInstance():Broadcast(EventId.SU_PlayerAttack,enemy)
end

function Player:OnAttackLoseHungerAndDurability()
    --不是英雄关才扣除装备耐久
    if self.battleLevel:CanConsumeEquipLevel() then
        local idxs = {}
        table.insert(idxs, 4)
        DataCenter.BagGridDataManager:AddEquipDurability(idxs, -1)
    end

    self.hunger:OnAttackLoseHunger()
end

function Player:StopAttack()
    CharacterBase.StopAttack(self)
    self.info:UpdateAttackTime()
end

function Player:Die()
    CharacterBase.Die(self)
    self:StopAttack()
    self:StopAI()
    self:StopAIMode()
end

-- 吃某个道具
function Player:UseFeedItem(itemId)
	local feedTemplate = LocalController:instance():getLine(TableName.SU_C_Feed, itemId)
	if feedTemplate == nil then
		Logger.LogError("UseFeedItem - not found item : " .. tostring(itemId))
		return
	end
	
	--SUSoundUtil.PlayMainActorActionSound('eat')
	
	local hunger = tonumber(feedTemplate:getValue("hunger")) or 0
	local thirsty = tonumber(feedTemplate:getValue("thirsty")) or 0
	local hp = tonumber(feedTemplate:getValue("health")) or 0
	local buff = feedTemplate:getValue("restorehealth")
    local pee = tonumber(feedTemplate:getValue("pee")) or 0
    local stool = tonumber(feedTemplate:getValue("shit")) or 0
	-- FIXME : 这里判断>0是不是不太好，有可能<0，理论上应该是~=0
    -- 确实有可能出现类似:(+hunger, -thirsty)的道具
	if hunger ~= 0 then
		self.hunger:AddHunger(hunger)
	end
	if thirsty ~= 0 then
		self.hunger:AddThirsty(thirsty)
	end
    if pee ~= 0 then
        self.hunger:AddPee(-pee)
    end
    if stool ~= 0 then
        self.hunger:AddStool(-stool)
    end
	if hunger ~= 0 or thirsty ~= 0 or pee ~= 0 or stool ~= 0 then
		self.hunger:OnCheck()
	end
	if buff ~= nil and buff ~= "" then
        if not UIManager:GetInstance():IsPanelLoadingComplete(UIWindowNames.UIBagView) then
            self:AddBloodTimer()
        end
		self.HP:AddBuff(buff)
	else
		if hp > 0 then
            if not UIManager:GetInstance():IsPanelLoadingComplete(UIWindowNames.UIBagView) then
                self:AddBloodTimer()
            end
			self.HP:AddCurBlood(hp)
		end
	end
end

function Player:AddBloodTimer()
    if self.bloodTimer ~= nil then
        return
    end
    self.bloodTimer = TimerManager:GetInstance():DelayInvoke(function()
        self:RemoveBloodTimer()
    end, 1.5)
    self:AddBloodEff()
end

function Player:RemoveBloodTimer()
    if self.bloodTimer then
        self.bloodTimer:Stop()
        self.bloodTimer = nil
    end
    self:RemoveBloodEff()
end

function Player:AddBloodEff()
    local r = CommonUtil.LoadResAsync(VFXAssets.UIPlayerAddBloodEff,
            function(request)
                if request.isError then
                    return
                end

                local obj = request.gameObject
                obj.transform.gameObject.name = 'playerAddBloodEff'
                obj.transform:SetParent(DataCenter.BattleLevel:GetSceneRoot())
                obj.transform:Set_localScale(1, 1, 1)
                obj.transform.gameObject:SetActive(false)
            end)

    self.addBloodRequest = r
end

function Player:RemoveBloodEff()
    if self.addBloodRequest ~= nil then
        self.addBloodRequest:Destroy()
        self.addBloodRequest = nil
    end
end

function Player:UpdateAddBloodEffPos()
    if self.addBloodRequest == nil or not self.addBloodRequest.isDone or self.addBloodRequest.gameObject == nil then
        return
    end
    local pos = self:GetPosition()
    local transform = self.addBloodRequest.gameObject.transform
    transform.gameObject:SetActive(true)
    transform:Set_position(pos.x, 0, pos.z)
end

function Player:Sneak(value)
    if self.info:IsWeakness() then
        if value then
            UIUtil.ShowTipsId(799004)
        end
        return
    end
    if value then
        self:ChangeState(State.Sneak)
    else
        self:ChangeState(State.Normal)
    end
end

function Player:Weakness(value)
    if value then
        self:ChangeState(State.Weakness)
    else
        if self:IsWeakness() then
            self:ChangeState(State.Normal)
        end
    end
end

--复活
function Player:Revive()
    self.m_delayGravity= true --刚复活,延迟重力检测，解决死亡后下线，再上线重置坐标，马上进行重力检测坐标会错误的BUG
    self:ChangeState(State.Normal)
    self:EnableCollider(true)
end

--更改人物状态，使用Hero.State
function Player:ChangeState(state)
    self.state = state
    self.info:SetSneak(state == State.Sneak)
    self.m_stateManager:ChangeCharacterState()
end

function Player:SetVisible(value)
    CharacterBase.SetVisible(self,value)
    if value then
        self.m_stateManager:ChangeCharacterState()
        self:SetAnimFloat("speed",1) --隐藏后会被重置，这里需要重新设置一下
    end
end

function Player:SearchEnemyTarget()
    if self.battleLevel == nil or self.battleLevel.SearchInfo == nil then
        return
    end

    local targetData = {}
    local enemy
    local pos = self:GetPosition()
    self.battleLevel.SearchInfo:DoAroundCheck(pos,targetData)
    if targetData.type == Const.TargetType.Zombie then
        local target = targetData.obj
        if target ~= nil then
            local dis = Vector3.Distance2D_XZ(target:GetPosition(),pos) - target:GetModelRadius() - self:GetModelRadius()
            if dis <= self:GetAttackRange() then
                enemy = target
            end
        end
    end
    return enemy
end

function Player:SearchCollectTarget()
    return self.battleLevel.ObjMgr:SearchItemTarget(self:GetPosition(),self:GetCollectRange(),self:GetType())
end

-- 获取摄像机朝向角色的位置,不是角色脚底,会存在一个偏移
function Player:GetLookAtPlayerPos()
    local yOffset = tonumber(SU_Util.GetItemConfig(DataCenter.BattleLevel:GetLevelId(), "camera_offsety")) or 0.8
    local _rolePos = self:GetPosition()
    _rolePos.y = _rolePos.y + yOffset
    return _rolePos
end

function Player:IsSneak()
    return self.state == State.Sneak
end

function Player:IsWeakness()
    return self.state == State.Weakness or DataCenter.GuideManager:IsPlayerShowWeakness()
end

function Player:GetCollectRange()
    return self.info:GetCollectRange()
end

function Player:GetDetectCollectRange()
    return self.info:GetDetectCollectRange()
end

function Player:GetDetectEnemyRange()
    return self.info:GetDetectEnemyRange()
end

function Player:TopFaceToCamera()
    if not IsNull(self.top_transform) and self:NeedRefreshTopBarRotation() then
        self.top_transform.rotation = self.battleLevel:GetCamera():GetCameraRotation()
    end
end

function Player:NeedRefreshTopBarRotation()
    return self.isArrowShow == true or self.hungerBar:IsShow() or self.HP:HpBarIsActive()
end

function Player:GetMoveSpeed()
    if DataCenter.GuideManager:GetIsWalkState() then
        return self.info:GetMoveSpeed() / 20
    end
    if not string.IsNullOrEmpty(DataCenter.GuideManager:GetForceWalkState()) then
        return self.info:GetMoveSpeed() / 20
    end
    local _configMoveAnim = SU_Util.GetCurItemConfig("force_run")
    if _configMoveAnim == AnimationType.Move then
        return self.info:GetMoveSpeed() / 10
    elseif _configMoveAnim == AnimationType.Run then
        return self.info:GetMoveSpeed() / 20
    elseif _configMoveAnim == AnimationType.WeakenWalk then
        return self.info:GetWeaknessMoveSpeed()/10
    end
    return self.info:GetMoveSpeed() / 10
end

function Player:GetCoolDown()
    return self.info:GetCoolDown()
end

function Player:GetEquipAnim(equipAnim,defaultAnim)
    if string.IsNullOrEmpty(equipAnim) then
        return defaultAnim
    end
    return equipAnim
end

function Player:GetAttackAnimName()
    return self:GetEquipAnim(self.info:GetAttackAnimName(),RandomDefaultAttackAnimName())
end

function Player:GetDefaultAnimName()
    if not string.IsNullOrEmpty(DataCenter.GuideManager:GetForceIdleState()) then
        return DataCenter.GuideManager:GetForceIdleState()
    end
    if self:IsSneak() then
        return self:GetEquipAnim(self.info:GetSneakIdleAnimName(), PlayerAnimationName.SneakIdle)
    elseif self:IsWeakness() then
        return PlayerAnimationName.weakenIdle
    end
    return self:GetEquipAnim(self.info:GetDefaultAnimName(), PlayerAnimationName.Idle)
end 

function Player:GetMoveAnimName()
    if self:IsSneak() then
        return self:GetEquipAnim(self.info:GetSneakMoveAnimName(), PlayerAnimationName.SneakWalk)
    elseif self:IsWeakness() then
        return PlayerAnimationName.weakenWalk
    end
    local _aniName = ""
    
    if not string.IsNullOrEmpty(DataCenter.GuideManager:GetForceWalkState()) then
        _aniName = DataCenter.GuideManager:GetForceWalkState()
    elseif DataCenter.GuideManager:GetIsWalkState() then
        _aniName = self:GetEquipAnim(self.info:GetRunAnimName(), PlayerAnimationName.Walk)
    else
        local _configMoveAnim = SU_Util.GetCurItemConfig("force_run")
        if _configMoveAnim == AnimationType.Move then
            _aniName = self:GetEquipAnim(self.info:GetMoveAnimName(), PlayerAnimationName.Run)
        elseif _configMoveAnim == AnimationType.Run then
            _aniName = self:GetEquipAnim(self.info:GetRunAnimName(), PlayerAnimationName.Walk)
        elseif _configMoveAnim == AnimationType.WeakenWalk then
            _aniName =  PlayerAnimationName.weakenWalk
        else
            _aniName = self:GetEquipAnim(self.info:GetMoveAnimName(), PlayerAnimationName.Run)
        end
    end
    return _aniName
end

function Player:GetDeadAnimName()
    return PlayerAnimationName.Dead
end

function Player:GetStrideOverAnimName()
    return PlayerAnimationName.StrideOver
end

 --已注释，用了actor1.prefab，animator组件就在根prefab上
--用回actor.prefab后解注
--function Player:GetAnimatorPath()
--    return "hero_nanshibing_01"
--end

function Player:PrefabPath()
    --return "Assets/_Art_LastDay/Models/Soldier/LastDayActor/prefab/actor.prefab"
    if self:GetCurLevelId() == 10002 then
        return string.format(LoadPath.PlayerPrefabPath,"actor2")
    else
        return string.format(LoadPath.PlayerPrefabPath,"actor1")
    end
    
end

function Player:GetPrefabName()
	return "0" -- 因为主角模型来回换，这里用0表示主角的模型名字
    --return self.prefabName
end

function Player:GetType()
    return CharacterType.Player
end

function Player:OnTriggerExit(otherObj)
    self.m_roofUtil:ExitRoom(otherObj)
    self.m_colliderEventUtil:OnTriggerExit(otherObj)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UIPVEChangeSceneTip)
    UIManager:GetInstance():DestroyWindow(UIWindowNames.UICommonMessageTip)
end

function Player:OnTriggerEnter(otherObj)
    if self.battleLevel:GetViewMode() == ViewMode.SLG then
        return
    end
    self.m_colliderEventUtil:OnTriggerEnter(otherObj)
    self.m_roofUtil:EnterRoom(otherObj)
    --if self.initTime ~= nil and self.bindTriggerHandlerEnd ~= nil then
    --    if self.initTime < 2 or self.bindTriggerHandlerEnd == false then
    --        self.bindTriggerHandlerEnd = true
    --        return
    --    end
    --else
    --    return
    --end
    local tag = otherObj.tag
    if not string.IsNullOrEmpty(tag) and tag == "Plane" then
        local level = self:GetCurLevelId()
        if level == LevelId.Main then
            UIManager:GetInstance():OpenWindow(UIWindowNames.UILevelList, {anim = true})
        else
            function ChangeToMainLevel()
                local param = {}
                param.context = "723101"
                param.time = SU_Util.GetItemConfig(level, "scene_switch_time")
                param.callback = SceneManager.ChangeToMainLevel
                UIManager:GetInstance():OpenWindow(UIWindowNames.UIPVEChangeSceneTip, {},param)
            end
            local showTips = tonumber(SU_Util.GetItemConfig(level, "leave_tips"))
            if showTips ~= nil and showTips == 1 then
                UIUtil.ShowMessage(Localization:GetString("830286"), 2, GameDialogDefine.CONFIRM, GameDialogDefine.CANCEL, ChangeToMainLevel)
            else
                ChangeToMainLevel()
            end

        end
    end
end

function Player:SetCurStayRoomUuid(uuid)
    --Logger.LogError('#Player# SetCurStayRoomUuid uuid:' .. tostring(uuid))

    if uuid == self.curStayRoomUuid then
        return
    end

    local oldUuid = self.curStayRoomUuid
    self.curStayRoomUuid = uuid

    if oldUuid ~= nil then
        local buildObj = DataCenter.BattleLevel:GetObjMgr():GetObjectByUuid(oldUuid)
        if buildObj ~= nil then
            buildObj:RefreshWallAndRoof()
        end
    end

    local buildObj = DataCenter.BattleLevel:GetObjMgr():GetObjectByUuid(uuid)
    if buildObj ~= nil then
        buildObj:RefreshWallAndRoof()
    end
end

function Player:GetCurStayRoomUuid()
    return self.curStayRoomUuid
end

function Player:ShowToolEquip(equipId)
    if self.m_skin == nil then return end -- 先暂时加这么一个处理吧。缺少一个alldone to begin game 的处理,目前地表,角色有点散
    self.m_skin:ShowTool(equipId)
end

function Player:ShowToolByPath(path)
    if self.m_skin == nil then return end -- 先暂时加这么一个处理吧。缺少一个alldone to begin game 的处理,目前地表,角色有点散
    self.m_skin:ShowToolByPath(path)
end

function Player:ResetWeapon()
    if self.m_skin == nil then return end -- 先暂时加这么一个处理吧。缺少一个alldone to begin game 的处理,目前地表,角色有点散
    self.m_skin:ResetWeapon()
end

function Player:HideWeapon()
    if self.m_skin == nil then return end -- 先暂时加这么一个处理吧。缺少一个alldone to begin game 的处理,目前地表,角色有点散
    self.m_skin:HideWeapon()
end

function Player:ShowWeapon()
    if self.m_skin == nil then return end -- 先暂时加这么一个处理吧。缺少一个alldone to begin game 的处理,目前地表,角色有点散
    self.m_skin:ShowWeapon()
end

--[[
  在引导阶段需要强制设置穿一个套装  
]]
function Player:ShowVirtualSuit()
    if self.m_skin == nil then return end
    self.m_skin:ShowVirtualSuit()
end
--[[
    还原真实装备
]]
function Player:ResetRealSuit()
    if self.m_skin == nil then return end
    self.m_skin:__initEquip()
end

function Player:SetCauseOfDeath(cause)
    Setting:SetPrivateInt(SettingKeys.PlayerCauseOfDeath, cause)
end

function Player:GetCauseOfDeath()
    return Setting:GetPrivateInt(SettingKeys.PlayerCauseOfDeath, 0)
end

function Player:GetHeadPostion()
	if self.m_transform then
	    local head = self.m_transform:Find("PveHero_Top/PVEHero_Hunger").gameObject
	    if head then
	        return head.transform.position
	    end
	end
	
	-- FIXME: 这块写的不是很好！！！
	--Logger.LogError("GetHeadPostion but no transform!")
	return Vector3.zero
end

function Player:UpdateShaderPos()
	--先暂时在C#里调
    --local centerPosID = Shader.PropertyToID("_CenterPos");
   -- Shader.SetGlobalVector(centerPosID, self:GetPosition());
end

function Player:CanTalk()
    return true
end

function Player:EqualsChatGroup()
    return true
end

function Player:GetWeaponName()
    return self.m_skin:GetWeaponName()
end

function Player:GetCharacterController()
    return self.m_characterController
end

function Player:GetFixedTransitionDuration()
    return 0.1
end

--function Player:GetAttackArc()
--    if self.info ~= nil then
--        return tonumber(self.info:GetEquipValue(SurvivalEquipType.Weapon,"arc",0))
--    end
--    return CharacterBase.GetAttackArc()
--end


function Player:ShowCircleEffect()
    if self.m_circleEffectReq ~= nil then
        return
    end
    self.m_circleEffectReq = CommonUtil.LoadResAsync("Assets/_Art_LastDay/Effect/Prefab/Eff_renwujiaoxia_ring.prefab",
        function(req)
            local transform = req.gameObject.transform
            transform:SetParent(self.m_transform)
            transform:Set_localPosition(0, 0.06, 0)
            transform:Set_localScale(0.8,1, 0.8)
        end
    )
end

function Player:DestroyCircleEffect()
    if self.m_circleEffectReq ~= nil then
        self.m_circleEffectReq:Destroy()
        self.m_circleEffectReq = nil
    end
end

function Player:Destroy()
    self:RemoveListener(EventId.SU_ClickToChangeViewMode, self.CheckRoleTopArrowBtn)
    self.m_characterController = nil
    self.skyTimeline = nil
    self.light = nil
    if self.info ~= nil then
    	self.info:RemoveListener(PvePlayerInfo.PvePlayerInfoEventId.EquipChanged, self.EquipSlotChangedHandler)
        self.info:RemoveListener(PvePlayerInfo.PvePlayerInfoEventId.InfoChanged,self.InfoChangedHandler)
        self.EquipSlotChangedHandler = nil
        self.InfoChangedHandler = nil
    end
    self.info = nil
	
	if self.m_skin then
    	self.m_skin:Destroy()
	end
    self:DestroyMiniMapIcon()
    self.m_AutoAIModule:Destroy()

    CharacterBase.Destroy(self)
	
	-- FIXME:这几个变量都做成初始化就New出来的，不用来回判空！！
	if self.ai then
    	self.ai:Destroy()
	end

	if self.hunger then
    	self.hunger:Destroy()
	end
	
	if self.HP then
    	self.HP:Destroy()
	end
	
	if self.level then
    	self.level:Destroy()
	end
	self:DestroyHeadFunction()

    if self.triggerHandler then
        self.triggerHandler.OnTriggerEnterAction = nil
        self.triggerHandler.OnTriggerExitAction = nil
        self.triggerHandler = nil
    end
	self:DestroyCircleEffect()
    self:RemoveBloodTimer()
end

function Player:OnArrowTriggerClick()
    if self.battleLevel:GetViewMode() == ViewMode.SLG then
		self.battleLevel:ChangeViewMode(ViewMode.RPG)
        self.battleLevel:GetCamera():ResumeCameraFollow()
    end
end

function Player:CheckKeyBoard()
    if CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.K) then
        self.isSuperMan = true
    end
end

function Player:GetStateManager()
    return self.m_stateManager
end

function Player:DoCollect(pressType)
    -- deleted
end

function Player:GetTargetData()
    if self.ai then
        return self.ai:GetTargetData()
    end
end

function Player:OnPlayFootstepSound()
    local levelId = DataCenter.BattleLevel:GetLevelId()
    --10002脚步声特殊处理
    if levelId == 10002 then
        local currentGroundType = self:GetCurrentGroundType()
        if currentGroundType == SurvivalGroundType.Floor then
            --SUSoundUtil.PlayMainActorActionSound('floorrun')
        else
            --SUSoundUtil.PlayMainActorActionSound('rainrun')
        end
        
        return
    end
    
    if self:IsSneak() then
		--SUSoundUtil.PlayMainActorActionSound('sneakwalk')
	else
		--SUSoundUtil.PlayMainActorActionSound('run')
	end
end

local WaterSplashEffectPath = 'Assets/_Art_LastDay/Effect/Prefab/%s.prefab'
local FootprintEffectPath = 'Assets/_Art_LastDay/Effect/Prefab/Eff_Jiaoyin_%s.prefab'
local tempFootPrintVector1 = Vector3.New(0, 0, 0)
local tempFootPrintVector2 = Vector3.New(0, 0, 0)
local tempFootPrintVector3 = Vector3.New(0, 0, 0)
function Player:OnPlayFootprintEffect()
    local currentGroundType = self:GetCurrentGroundType()
    if currentGroundType == SurvivalGroundType.HideFootprint then
        return
    end
    
    local pos = self:GetPosition()
    local forward = self:GetForward():Normalize()
    tempFootPrintVector1:Set(pos.x, pos.y, pos.z)
    tempFootPrintVector2:Set(forward.x, forward.y, forward.z)
    
    local _, rotationY = self:GetEulerXYZ()
    local isNight = SceneManager.GetLevel():GetSkyTime():IsNight()
    
    --默认地表 播放普通脚印特效
    if self.footprintIdx == nil then
        self.footprintIdx = 0
    end

    self.footprintIdx = Mathf.Repeat(self.footprintIdx + 1, IntMaxValue)
    local isLeft = self.footprintIdx % 2 == 1
    
    
    --踩到水坑 播放水花特效
    if currentGroundType == SurvivalGroundType.Puddle then
        --水花频率比脚步减少一半
        if not isLeft then
            return
        end
        
        local effectPath = string.format(WaterSplashEffectPath, isNight and 'Eff_Shuihua_dark' or 'Eff_Shuihua')
        CommonUtil.LoadResAsync(effectPath, function(req)
            local go = req.gameObject
            if go == nil then
                return
            end

            go.transform:Set_position(tempFootPrintVector1.x, 0, tempFootPrintVector1.z)
            local s = math.random(10, 12) / 10.0
            go.transform:Set_localScale(s, s, s)
            TimerManager:GetInstance():DelayInvoke(function() req:Destroy() end, 3)
        end)
        
        return
    end

    if currentGroundType == SurvivalGroundType.None then
        if not self.needPlayFootprint then
            return
        end
        
        local path = string.format(FootprintEffectPath, isLeft and 'left' or 'right')
        CommonUtil.LoadResAsync(path, function(req)
            local go = req.gameObject
            if go == nil then
                return
            end

            if not SceneManager.IsInCity() then
                req:Destroy()
                return
            end


            local flashNode = go.transform:Find('Jiaoyin_flash')
            local darkNode = go.transform:Find('Jiaoyin_dark')
            if flashNode ~= nil then
                flashNode.gameObject:SetActive(not isNight)
            end
            if darkNode ~= nil then
                darkNode.gameObject:SetActive(isNight)
            end

            tempFootPrintVector3:Set(tempFootPrintVector2.z, 0, -tempFootPrintVector2.x)
            tempFootPrintVector3 = tempFootPrintVector3:Normalize() * (isLeft and -0.13 or 0.13)
            --Logger.Log('footprint: vector3:' .. tempFootPrintVector3:ToString())

            tempFootPrintVector1 = tempFootPrintVector1 + tempFootPrintVector3
            go.transform:Set_position(tempFootPrintVector1.x, 0, tempFootPrintVector1.z)

            go.transform:Set_eulerAngles(0, rotationY, 0)
            TimerManager:GetInstance():DelayInvoke(function() req:Destroy() end, 10)
        end)
        
        return
    end
end

--洗澡状态
function Player:BeginToShower()
    self:SetState(CharacterStateType.Shower)
end

--大小便状态
function Player:BeginToPeeOrStool()
    self:SetState(CharacterStateType.PeeOrStool)
end

--还原身上所有初始部件(光身)
function Player:RevertBaseParts()
    self.m_skin:RevertBaseParts()
end

--恢复正常部件
function Player:RevertParts()
    self.m_skin:RevertParts()
end

--使用道具播放动作
function Player:UseItemAction(data)
    if self:IsIdle() then
        self:SetState(CharacterStateType.UseItemAction,data)
    end
end


function Player:SetCurrentGroundType(survivalGroundType)
    self.currentGroundType = survivalGroundType
    Logger.Log('#SetCurrentGroundType# survivalGroundType:' .. tostring(survivalGroundType))
end

function Player:GetCurrentGroundType()
    return self.currentGroundType
end

function Player:SetReadyCallback(callback)
    if self.isReady then
        self.readyCallback = nil
        if callback then
            callback()
        end
    else
        self.readyCallback = callback
    end
end

-- 表示角色是否创建完毕
function Player:IsReady()
	return self.isReady
end

return Player