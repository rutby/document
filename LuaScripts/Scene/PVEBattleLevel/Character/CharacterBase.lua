---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1022.
--- DateTime: 2022/9/22 15:10
---人物基础类，定义了好多基础属性和函数
---在第二期重构场景的时候，还需要再次拆分，拆分的逻辑是，场景基础对象->可攻击对象/可交互对象->人物/物品/建筑
local CharacterBase = BaseClass("CharacterBase")
local CharacterStateManager = require("Scene.PVEBattleLevel.Character.State.CharacterStateManager")
local CharacterStateType = require("Scene.PVEBattleLevel.Character.State.CharacterStateType")
local ConstModelConfig = require("Scene.PVEBattleLevel.ConstModelConfig")
local Const = require "Scene.PVEBattleLevel.Const"
local Resource = CS.GameEntry.Resource
local NavMeshAgent = typeof(CS.UnityEngine.AI.NavMeshAgent)
local TypeAnimator = typeof(CS.UnityEngine.Animator)
local TypeAnimationListener = typeof(CS.CitySpaceManAnimationListener)
local VFXManager = require("Scene.PVEBattleLevel.VFX.VFXManager")


local RotationSpeed = 1440
local TurnToleranceCos = 0.996 -- 转向角度容差cos，5度

CharacterType = 
{
    Player = "Player",
    Zombie = "Zombie",
    Npc = "Npc",
    Hero = "Hero"
}
CharacterBase.CharacterType = CharacterType

-- 注册UI数据监听事件，别重写
function CharacterBase:AddListener(msg_name, callback)
    local bindFunc = function(...) callback(self, ...) end
    self.__event_handlers[msg_name] = bindFunc
    EventManager:GetInstance():AddListener(msg_name, bindFunc)
end

-- 注销UI数据监听事件，别重写
function CharacterBase:RemoveListener(msg_name, callback)
    local bindFunc = self.__event_handlers[msg_name]
    if not bindFunc then
        Logger.LogError(msg_name, " not register")
        return
    end
    self.__event_handlers[msg_name] = nil
    EventManager:GetInstance():RemoveListener(msg_name, bindFunc)
end

function CharacterBase:__init(battleLevel,objId,info)
    self.__event_handlers = {}
    self.battleLevel = battleLevel
    self.m_objId = objId
    self.isCharacter = true
    self.info = info
    self.m_isPause = false
    self.m_animator = nil
    self.animEvent = nil
    self.m_attacking = false
    self.m_position = Vector3.New(0, 0, 0)
	self.m_forward = Vector3.New(0, 0, 1)
    self.m_rotation = Quaternion.Euler(0, 0, 0)
    self.m_defenceFactor = LuaEntry.DataConfig:TryGetNum("survival_battle", "k17")
    self.m_configState = Const.ConfigTriggerState.Normal
    self.m_collider = nil
	self.m_farOptiFlag = 0
    self.m_vfxManager = VFXManager.New(battleLevel)
    self.m_vfxManager:Init()
    self:__initStates()
end

function CharacterBase:__delete()
	self.m_position = nil
	self.m_forward = nil
	self.m_rotation = nil
end

function CharacterBase:Create(completeHandler)
    self.m_createCompleteHandler = completeHandler
    self:__loadAsset()
end

function CharacterBase:SetTriggerId(triggerId)
    self.m_triggerId = triggerId
    -- 预设值configstate
    local _State = GetTableData(TableName.PVETrigger, triggerId, "State")
    if string.IsNullOrEmpty(_State) or tonumber(_State) == Const.ConfigTriggerState.DelayCreate then
        _State = Const.ConfigTriggerState.Normal
    else
        _State = tonumber(_State)
    end
    local _triggerInfo = DataCenter.SV_MapItemInfoManager:GetItemInfoList():GetFinishTriggerById(triggerId)
    if (_triggerInfo ~= nil) then 
        _State = _triggerInfo["clientState"]
    end
    self:SetConfigTriggerState(_State)
end

function CharacterBase:SetConfigTriggerState( value )
    if value == nil then
        return
    end
    self.m_configState = value
    
    local _show = true
    if value == Const.ConfigTriggerState.Hide then
        _show = false
    end
    self:SetVisible(_show)
end

function CharacterBase:GetConfigTriggerState()
    return self.m_configState or Const.ConfigTriggerState.Normal
end

function CharacterBase:__loadAsset()
    local path = self:PrefabPath()
	
	self:__destroyAsset()
    local req = CS.GameEntry.Resource:InstantiateAsync(path)
    self.m_req =req
    req:completed('+',function()
					
        if req.isError or req.gameObject == nil then
            --self:__assetCreateComplete()
            Logger.LogError("CharacterBase Load Error:" .. path)
            return
        end
        
        self.m_gameObject = req.gameObject
        self.m_transform = self.m_gameObject.transform

        local layer
        if DataCenter.BattleLevel.qualityLevel <= EnumQualityLevel.Low then
            layer = "Default"
        else
            layer = "OutlineAndShadow"
        end
        self.m_gameObject:SetLayerRecursively(CS.UnityEngine.LayerMask.NameToLayer(layer))
    
        local rootNode
        if self.m_parent ~= nil then
            rootNode = self.m_parent
        else
            rootNode = self.battleLevel:GetSceneRoot()
        end

        if rootNode then
            self.m_transform:SetParent(rootNode)
        end
        
        self:__initAnim()
        self:__assetCreateComplete()
        
        self:__checkPauseState()

        if self.m_createCompleteHandler ~= nil then
            self.m_createCompleteHandler()
        end
    end)
end

function CharacterBase:__destroyAsset()
	if self.m_req ~= nil then
		
		---- 删除声音绑定
		--if self.animEvent ~= nil then
		--	self.animEvent.playFootstepSound = nil
		--end
		
		self.m_req:Destroy() --这里会回收gameobject
		self.m_req = nil
	end
end

--资源创建完毕，子类复写
function CharacterBase:__assetCreateComplete()
    self.loadDone = true
    -- navmeshAgent放这吧
    local _agent = self.m_transform:GetComponent(NavMeshAgent)
    if not IsNull(_agent) then
        self.m_navmeshAgent = _agent
        self.m_navmeshAgent.enabled = false
    end
    
    -- 根据state状态进行修正
    self:SetConfigTriggerState(self:GetConfigTriggerState())
    
end

--检查是否需要暂停
function CharacterBase:__checkPauseState()
    local isPauseAll = self.battleLevel:GetRoleMgr():IsPauseAll()
    if isPauseAll then
        self:SetAllCharacterActionState(Const.CharacterActionState.Pause)
    end
end

function CharacterBase:__initAnim()
	--local path = self:GetAnimatorPath()
    local model= self.m_transform
    --if string.IsNullOrEmpty(path) then
    --    model = self.m_transform
    --else
    --    model = self.m_transform:Find(path)
    --end
	if model then
    	self.m_animator = model:GetComponentInChildren(TypeAnimator)
    	self.animEvent = model:GetComponentInChildren(TypeAnimationListener)
        --just for test
        --if self.animEvent ~= nil then
        --    --self.animEvent.playFootstepSound = BindCallback(self, self.OnPlayFootstepSound)
        --    self.animEvent.animation_playSoundId = function(id) self:OnPlaySoundId(id) end
        --end


	else
		Logger.LogError("Not found model path!!! triggerID: ", tostring(self.m_triggerId))
	end
end

function CharacterBase:SetParent(parent)
    self.m_parent = parent
    if not IsNull(self.m_transform) then
        self.m_transform:SetParent(parent)
    end
end

-- 跑步声音
function CharacterBase:OnPlayFootstepSound()
	--local prefabName = self:GetPrefabName()
	--SUSoundUtil.PlayActorActionSound(prefabName, 'run')
end

function CharacterBase:GetNavmeshAgent()
    return self.m_navmeshAgent
end

function CharacterBase:__initStates()
    self.m_stateManager = CharacterStateManager.New(self,self.OnStateComplete)
end

function CharacterBase:SetAllCharacterActionState( actionState )
    local _state = actionState == Const.CharacterActionState.Pause
    if _state == self.m_isPause then return end
    self.m_isPause = _state
    if self.m_isPause then
        if not self:IsDie() then
            --self:SetAnimatorEnabled(false)
            self:Idle()
            self:StopAttack()
        end
    end
end

function CharacterBase:SetAnimatorEnabled( active )
    if self.m_animator ~= nil then
        self.m_animator.enabled = active
    end
end

function CharacterBase:OnUpdate(deltaTime)
    if (self.m_isPause == true) then
        return
    end
    self.m_stateManager:OnUpdate(deltaTime)
    self.m_vfxManager:OnUpdate(deltaTime)
end
--封装一下设置状态机接口
function CharacterBase:SetState(type,data)
    self.m_stateManager:SetState(type,data)
end

function CharacterBase:CreateVFX(effectName,parent)
    parent = parent or self.m_transform
    return self.m_vfxManager:CreateVFX(effectName,parent)
end

--状态机完成，子类可以复写
function CharacterBase:OnStateComplete(type,data)
    
end

function CharacterBase:PlayAnim(animName)
    --self:ResetAllTrigger()
	--
	if self.m_animator ~= nil then
		--local hashId = GlobalCache.Animator_StringToHash(animName)
	    self.m_animator:SetTrigger(animName)
	else
		Logger.Log("PlayAnim nil!")
	end
    --if self:GetType() == CharacterType.Player then
    --    Logger.Debug("****aniName: " .. animName)
    --end
    --
    --if not IsNull(self.m_animator) then
    --    local hashId = CS.UnityEngine.Animator.StringToHash(animName)
    --    self.m_animator:CrossFadeInFixedTime(hashId,self:GetFixedTransitionDuration(),0)
    --else
    --    Logger.Log("PlayAnim no animator : ", animName)
    --end
end

--动画融合时间
function CharacterBase:GetFixedTransitionDuration()
    return 0.2
end

function CharacterBase:SetAnimSpeed(speed)
    if not IsNull(self.m_animator) then
        self.m_animator.speed = speed
	else
		Logger.Log("SetAnimSpeed nil!")
	end
end

function CharacterBase:SetAnimFloat(parameter,value)
    if not IsNull(self.m_animator) then
		local hashId = GlobalCache.Animator_StringToHash(parameter)
        self.m_animator:SetFloat(hashId, value)
	else
		Logger.Log("SetAnimFloat nil!")
	end
end
--获取当前动画的时长，如果是同一帧刚播放，则下一帧获取才可以获得准确的时间
--如果当前播放的不是目标动画，则时长返回-1
function CharacterBase:GetCurrentAnimLength(animName)
    local duration = -1
    --if not IsNull(self.m_animator) then
    --    local clips = self.m_animator.runtimeAnimatorController.animationClips
    --    for i = 0, clips.Length - 1 do
    --        if string.endswith(clips[i].name,animName) then
    --            duration = clips[i].length
    --            return duration
    --        end
    --    end
    --end
    return -1
end

function CharacterBase:GetAnimLength(animName)
    local duration = 0.5
    --if not IsNull(self.m_animator) then
    --    local clips = self.m_animator.runtimeAnimatorController.animationClips
    --    for i = 0, clips.Length - 1 do
    --        if string.endswith(clips[i].name,animName) then
    --            duration = clips[i].length
    --            return duration
    --        end
    --    end
    --end
    return -1
end

function CharacterBase:GetAnimatorObj()
    if not IsNull(self.m_animator) then
        return self.m_animator.gameObject
    end 
    return nil
end

--使用动画位移
function CharacterBase:SetApplyRootMotion(value)
    if not IsNull(self.m_animator) then
        self.m_animator.applyRootMotion = value
    end
end

function CharacterBase:HasAnim(animName)
    if not IsNull(self.m_animator) then
        local hashId = GlobalCache.Animator_StringToHash(animName)
        return self.m_animator:HasState(0,hashId)
    end
    return false
end
function CharacterBase:CanLookAt()
    return true
end
--看向某个坐标
function CharacterBase:LookAt(pos)
    if not self:CanLookAt() then
        return
    end
    local selfPos = self:GetPosition()
    local offset = pos - selfPos
    offset.y = 0
    local lookRot = Quaternion.LookRotation(Vector3.Normalize(offset), Vector3.up)
    self:SetRotation(lookRot)
end

function CharacterBase:GetForward()
    if self.m_transform then
        return self.m_transform.forward
		--local x, y, z = self.m_transform:Get_forward()
		--self.m_forward:Set(x, y, z)
    end
    return self.m_forward
end

function CharacterBase:TurnToDir(dir, deltaTime)
    if Vector3.Dot(self:GetForward(), dir) > TurnToleranceCos then
        return
    end
    local rot = Quaternion.RotateTowards(self.m_transform.rotation, Quaternion.LookRotation(dir), RotationSpeed * deltaTime)
    self:SetRotation(rot)
end

function CharacterBase:MoveToDir(dirVec, deltaTime)
    dirVec.y = 0
    local pos = self:GetPosition() + dirVec * self:GetMoveSpeed() * deltaTime
    self:SetPosition(pos)
end

function CharacterBase:SetPosition(pos)
    self.m_position:Set(pos.x, pos.y, pos.z)
    if self.m_transform then
        --self.m_transform.position = pos
		self.m_transform:Set_position(pos.x, pos.y, pos.z)
    end
end

--[[
***** 这里有个限定规则，就是外部不能直接保存这个返回值pos
      因为保存后将变成引用，而这个值其实是内部的一个持续改变的值
      虽然目前这个限定比较容易使用错误，但是想处理好有点麻烦，只能暂时如此
]]
function CharacterBase:GetPosition()
    if self.m_transform then
		self.m_position.x, self.m_position.y, self.m_position.z = self.m_transform:Get_position()
    end 
    return self.m_position
end

function CharacterBase:LostFocus()

end
function CharacterBase:Focus()

end

function CharacterBase:SetRotationEluer( eluer )
    local quaternion = Quaternion.Euler(eluer.x, eluer.y, eluer.z)
    self:SetRotation(quaternion)
end

function CharacterBase:SetRotation(quaternion)
    self.m_rotation:Set(quaternion.x, quaternion.y, quaternion.z, quaternion.w)
    if self.m_transform then
        self.m_transform.rotation = quaternion
		--self.m_transform:Set_rotation(self.m_rotation.x, self.m_rotation.y, self.m_rotation.z, self.m_rotation.w)
    end
end

function CharacterBase:SetRotationY( data )
    local _curRotation = self:GetRotation().eulerAngles
    _curRotation.y = data
    local quaternion = Quaternion.Euler(_curRotation.x, _curRotation.y, _curRotation.z)
    self:SetRotation(quaternion)
end

function CharacterBase:GetRotation()
    if self.m_transform then
		local x, y, z, w = self.m_transform:Get_rotation()
		self.m_rotation:Set(x, y, z, w)
        --self.m_rotation = self.m_transform.rotation
    end
    return self.m_rotation
end

function CharacterBase:GetEuler()
    if (self.m_transform) then
        return self.m_transform.rotation.eulerAngles
    end
    return Vector3.New(0,0,0)
end

function CharacterBase:GetEulerXYZ()
    if (self.m_transform) then
        return self.m_transform:Get_eulerAngles()
    end
    
    return 0, 0, 0
end

--特殊逻辑需要用到transform
--一般不建议外部调用transform，除非确定外部调用逻辑不会修改transform数据，以免出现问题不好查
function CharacterBase:GetTransform()
    return self.m_transform
end

function CharacterBase:GetGameObject()
    return self.m_gameObject
end

function CharacterBase:DoDefaultState()
    self:Idle()
end

function CharacterBase:Idle()
    self:SetState(CharacterStateType.Default)
end

function CharacterBase:Attack(target)
    self.m_attacking = true
    self:SetState(CharacterStateType.Attack,target)
end

function CharacterBase:StopAttack()
    self.m_attacking = false
end

function CharacterBase:DoStopAttack()
    if self.m_skin ~= nil then
        return self.m_skin:StopWeaponAttackAnim()
    end
end
--攻击敌人，里面写各自的计算伤害逻辑
function CharacterBase:AttackEnemy(enemy)
    
end

function CharacterBase:BeAttack(attackNum,data)
    --local hurt = Mathf.Floor(attackNum * self.m_defenceFactor / (self:GetDefence() + self.m_defenceFactor))
    local hurt = Mathf.CeilToInt(attackNum - self:GetDefence()/self.m_defenceFactor)
    hurt = Mathf.Max(hurt,1)
    self.HP:AddCurBlood(-hurt)
	
	local prefabName = self:GetPrefabName()
	--SUSoundUtil.PlayActorActionSound(prefabName, 'damage')
end
--播放被击特效，子类可以复写
function CharacterBase:PlayBeAttackEffect(attackAnimName)
end

function CharacterBase:IsDead()
    return self.HP:IsDead()
end

function CharacterBase:Die()
    self:SetState(CharacterStateType.Die)
end


local globalMoveParam = {}
function CharacterBase:Move(vx,vz,length)
	--local param = {}
	--param.vx = vx
	--param.vz = vz
	--param.length = length
    --self:SetState(CharacterStateType.Move, param) --{vx = vx,vz = vz,length = length})
	
	globalMoveParam.vx = vx
	globalMoveParam.vz = vz
	globalMoveParam.length = length
	self:SetState(CharacterStateType.Move, globalMoveParam) --{vx = vx,vz = vz,length = length})
end


local globalMovePathParam = {pos = Vector3.New(0, 0, 0), speed = 1}
function CharacterBase:MovePath(pos, callback)
    self:MovePathWithSpecifiedSpeed(pos, self:GetMoveSpeed(), callback)
end

--指定移动速度
function CharacterBase:MovePathWithSpecifiedSpeed(pos, speed, callback)
    globalMovePathParam.pos:Set(pos.x, pos.y, pos.z)
    globalMovePathParam.speed = speed or self:GetMoveSpeed()
    globalMovePathParam.callback = callback
    self:SetState(CharacterStateType.MoveByPath, globalMovePathParam)
end

function CharacterBase:StopWalk()
    self:Idle()
end

function CharacterBase:IsAttacking()
    return self.m_attacking
end

function CharacterBase:IsDie()
    return self:GetCurBlood() <= 0
end

--获取当前血量
function CharacterBase:GetCurBlood()
    if (self.info) then
        return self.info:GetCurBlood()
    end
	
	--Logger.LogError("this object already destroy!!!")
    return 0
end

function CharacterBase:GetMaxBlood()
    return self.info:GetMaxBlood()
end

--寻找自己的敌人，子类复写，由于寻找目标没有统一逻辑，所以先子类各自复写
function CharacterBase:SearchEnemyTarget()
    return nil
end

function CharacterBase:SetVisible(value)
    if self.m_gameObject then
        self.m_gameObject:SetActive(value)
    end
end

function CharacterBase:GetVisible()
    if self.m_gameObject then
        return self.m_gameObject.activeSelf
    end
end

function CharacterBase:HasTransform()
    return self.m_transform ~= nil
end

function CharacterBase:GetObjId()
    return self.m_objId
end

function CharacterBase:GetMoveAnimSpeed()
    return self.info:GetMoveAnimSpeed()
end

--获取移动速度
function CharacterBase:GetMoveSpeed()
    return self.info:GetMoveSpeed()
end

function CharacterBase:GetRunSpeed()
    return self.info:GetRunSpeed()
end

--获取防御力
function CharacterBase:GetDefence()
    return self.info:GetDefence()
end

--获取攻击力
function CharacterBase:GetAttack()
    return self.info:GetAttack()
end
--攻击速度
function CharacterBase:GetAttackSpeed()
    return self.info:GetAttackSpeed()
end
--攻击范围
function CharacterBase:GetAttackRange()
    return self.info:GetAttackRange()
end

--获取默认动画名称，一般是待机动画，子类复写，后续名字统一后可以删除
function CharacterBase:GetDefaultAnimName()
    return ""
end

--获取攻击动画名字，子类复写，后续名字统一后可以删除
function CharacterBase:GetAttackAnimName()
    return ""
end
--获取移动动画名字，子类需写，后续名字统一后可以删除
function CharacterBase:GetMoveAnimName()
    return ""
end

--目前Animator挂的节点不一致，所以子类需复写这个函数
function CharacterBase:GetAnimatorPath()
    return ""
end

--获取移动动画名字，子类需写，后续名字统一后可以删除
function CharacterBase:GetDeadAnimName()
    return ""
end
--子类复写
function CharacterBase:GetPrefabName()
    return ""
end
--获取资源路径，子类需复写
function CharacterBase:PrefabPath()
    return ""
end
--获取人物类型，子类需复写
function CharacterBase:GetType()
    return ""
end
--获取武器名字，子类复写
function CharacterBase:GetWeaponName()
    return ""
end

function CharacterBase:GetModelRadius()
    if self.m_modelRadius == nil then
        self.m_modelRadius = ConstModelConfig.GetModelRadius(self:GetPrefabName())
    end
    return self.m_modelRadius
end
--获取敌人类型
function CharacterBase:GetEnemyType()
    return self:GetType() == CharacterType.Zombie and CharacterType.Player or CharacterType.Zombie
end
--向shader中传递坐标，子类复写，目前只有英雄需要
function CharacterBase:UpdateShaderPos()
    
end

function CharacterBase:IsIdle()
    if self.m_stateManager ~= nil then
        local state = self.m_stateManager:GetCurrentState()
        if state ~= nil then
            local stateType = state:GetType()
            return stateType == CharacterStateType.Default or stateType == CharacterStateType.InertialIdle
        end
    end
    return false
end

function CharacterBase:EnableCollider(enable)
    if IsNull(self.m_collider) and (not IsNull(self.m_transform)) then
        self.m_collider = self.m_transform:GetComponent(typeof(CS.UnityEngine.Collider))
    end
    if (not IsNull(self.m_collider)) then
        self.m_collider.enabled = enable
    end
end

function CharacterBase:EnableNavmeshAgent(value)
    if not IsNull(self.m_navmeshAgent) and self.m_navmeshAgent.enabled then
        self.m_navmeshAgent.isStopped = not value
        self.m_navmeshAgent.enabled = value
    end
end

function CharacterBase:HideHpBar()
    if self.HP ~= nil then
        self.HP:HideHpBar()
    end
end
--视线，发射一条射线是否打到transform上，用于判断中间是否有阻挡
function CharacterBase:SightRayCast(transform)
    if transform == nil or self.m_transform == nil or self.battleLevel == nil or self.battleLevel:IsHeroAutoLevel() then
        return true
    end
    return self.m_transform:Raycast(transform)
end

function CharacterBase:PlayWeaponAttackAnim()
    if self.m_skin ~= nil then
        return self.m_skin:PlayWeaponAttackAnim()
    end
end

function CharacterBase:GetWeaponSpecialData()
    if self.m_skin ~= nil then
        return self.m_skin:GetWeaponSpecialData()
    end
    return nil
end

function CharacterBase:GetWeaponFireTransform()
    if self.m_skin ~= nil then
        return self.m_skin:GetWeaponFireTransform()
    end
    return nil
end

function CharacterBase:GetWeaponTransform_R()
    if self.m_skin ~= nil then
        return self.m_skin:GetWeaponTransform_R()
    end
    return nil
end

function CharacterBase:GetWeaponTransform_L()
    if self.m_skin ~= nil then
        return self.m_skin:GetWeaponTransform_L()
    end
    return nil
end

function CharacterBase:PlayWeaponFireVFX(vfx)
    if self.m_skin == nil then
        return
    end
    if string.IsNullOrEmpty(vfx) then
        vfx = self.m_skin:GetWeaponAtkEffect()
    end
    if not string.IsNullOrEmpty(vfx) then
        local parent,parent2 = self.m_skin:GetWeaponFireTransform()
        if parent ~= nil then
            self:CreateVFX(vfx,parent)
        end
        if parent2 ~= nil then
            self:CreateVFX(vfx,parent2)
        end
    end
end

function CharacterBase:FireWeaponTrackVFX(targetPosition,vfxId)
    if self.m_skin == nil then
        return
    end

    if string.IsNullOrEmpty(vfxId) then
        vfxId = self.m_skin:GetWeaponTrackEffect()
    end
    if not string.IsNullOrEmpty(vfxId) then
        function createVFX(firePosTransform)
            if firePosTransform == nil then
                return
            end
            local firePos
            local x,y,z = firePosTransform:Get_position()
            local pos1 = self.m_transform:InverseTransformPoint(Vector3.New(x,y,z))
            firePos = self.m_transform:TransformPoint(pos1)
            local vfx = self.battleLevel:CreateVFX(tonumber(vfxId),firePos,self:GetRotation())
            if targetPosition ~= nil then
                vfx:SetData({pos = targetPosition})
            end
        end

        local firePosTransform,firePosTransform2 = self.m_skin:GetWeaponFireTransform()
        createVFX(firePosTransform)
        createVFX(firePosTransform2)
    end
end

--获取普通攻击范围
function CharacterBase:GetAttackArc()
    if self.m_skin ~= nil then
        return self.m_skin:GetWeaponArc()
    end
    return 0
end


function CharacterBase:Destroy()
    -- self:SetAnimSpeed(1) --重置动画速度为1
    self.m_stateManager:Destroy() --状态Destroy中依赖asset 所以先对DestroyAllState
    self.m_vfxManager:Destroy()
	self:__destroyAsset()
    
    self.battleLevel = nil
    self.m_parent = nil
    self.m_createCompleteHandler = nil
    if not IsNull(self.m_animator) then
		self.m_animator.speed = 1  --重置动画速度为1
        --self.m_animator.applyRootMotion = false
        self.m_animator = nil
    end
    if self.animEvent ~= nil then
        --self.animEvent.playFootstepSound = nil
        self.animEvent = nil
    end
    self.m_gameObject = nil
    self.m_transform = nil
    self.m_collider = nil
    if self.info ~= nil then
        self.info:Delete()
        self.info = nil
    end
end

function CharacterBase:RemoveEffectAfterDead()
end

-- 设置物件距离人物过远优化标志，默认为3
function CharacterBase:SetFarFlag(flag)
	flag = flag or 3
	self.m_farOptiFlag = flag
end

-- 返回是否疑似距离过远，true表示过远
function CharacterBase:TickFarFlag()
	self.m_farOptiFlag = self.m_farOptiFlag - 1
	if self.m_farOptiFlag <= 0 then
		return false
	end

	return true
end

function CharacterBase:IsMoveByPath()
    if self.m_stateManager ~= nil then
        local state = self.m_stateManager:GetCurrentState()
        if state ~= nil then
            local stateType = state:GetType()
            return stateType == CharacterStateType.MoveByPath
        end
    end
    return false
end

function CharacterBase:IsCollect()
    return self:EqualsStateType(CharacterStateType.Collect)
end

function CharacterBase:IsMoving()
    return self:EqualsStateType(CharacterStateType.Move)
end

function CharacterBase:IsAttackState()
    return self:EqualsStateType(CharacterStateType.Attack)
end

function CharacterBase:EqualsStateType(type)
    if self.m_stateManager ~= nil then
        return self.m_stateManager:GetCurrentStateType() == type or self.m_stateManager:GetNextStateType() == type
    end
    return false
end

function CharacterBase:IsAttackState()
    if self.m_stateManager ~= nil then
        local state = self.m_stateManager:GetCurrentState()
        if state ~= nil then
            local stateType = state:GetType()
            return stateType == CharacterStateType.Attack
        end
    end
    return false
end

function CharacterBase:ExitCurrentState()
    if self.m_stateManager ~= nil then
        self.m_stateManager:ExitCurrentState()
    end
end

function CharacterBase:GetCurLevelId()
	return self.battleLevel:GetLevelId()
end

function CharacterBase:OnPlaySoundId(soundId)
    if soundId == nil then return end
    local t = {}
    t.c_sound_id = soundId
    --SUSoundUtil.FinalPlaySound(t)
end

return CharacterBase