---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Beef.
--- DateTime: 2022/6/13 18:20
---

local PveUtil = {}
local Setting = CS.GameEntry.Setting
local Localization = CS.GameEntry.Localization
local Physics = CS.UnityEngine.Physics
local WORLD = CS.UnityEngine.Space.World
local Const = require "Scene.LWBattle.Const"
local UIHeroInfoView = require "UI.UIHero2.UIHeroInfo.View.UIHeroInfoView"

local UP = Vector3.up
local cannonWorldForward = Vector3.zero
local Epsilon = 0.0001
local ColliderArrayCapacity = 64
local colliderArray = CS.System.Array.CreateInstance(typeof(CS.UnityEngine.Collider), ColliderArrayCapacity)

local HeroPowerCache = nil -- Dict<key, val>
local ShowHeroSlotEmptyFlag = true -- 有位置没上英雄
local ShowHeroRarityFlag = true -- 有更好品质的英雄可选
local ShowHeroBeyondFlag = true -- 英雄需要突破
local ShowHeroMaxedFlag = true -- 英雄已满级

local CheckFlag =
{
    None = 0,
    HeroSlotEmpty = 1 << 0,
    HeroRarity = 1 << 1,
    HeroBeyond = 1 << 2,
    HeroMaxed = 1 << 3,
    All = 0x7FFFFFFF,
}

local function GetCheckFlag()
    local flag = CheckFlag.HeroSlotEmpty | CheckFlag.HeroRarity
    return flag
end

local function CheckConfigChanged()
    local k3 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k3") or ""
    local k4 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k4") or ""
    local k5 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k5") or ""
    local k6 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k6") or ""
    local str = k3 .. k4 .. k5 .. k6
    local cacheStr = Setting:GetString(SettingKeys.PVE_HERO_POWER_CONFIG_CACHE .. LuaEntry.Player.uid, "")
    if str ~= cacheStr then
        Setting:SetString(SettingKeys.PVE_HERO_POWER_CONFIG_CACHE .. LuaEntry.Player.uid, str)
        PveUtil.ClearHeroPowerCache()
    end
end

local function LoadHeroPowerCache()
    HeroPowerCache = {}
    local cacheStr = Setting:GetString(SettingKeys.PVE_HERO_POWER_CACHE .. LuaEntry.Player.uid, "")
    if cacheStr == "" then
        return
    end
    
    local strs = string.split(cacheStr, "|")
    for _, str in ipairs(strs) do
        local spls = string.split(str, ";")
        if #spls == 2 then
            local key = tostring(spls[1])
            local val = tonumber(spls[2])
            HeroPowerCache[key] = val
        end
    end
end

local function SaveHeroPowerCache()
    local strs = {}
    for key, val in pairs(HeroPowerCache) do
        local str = key .. ";" .. val
        table.insert(strs, str)
    end
    local cacheStr = string.join(strs, "|")
    Setting:SetString(SettingKeys.PVE_HERO_POWER_CACHE .. LuaEntry.Player.uid, cacheStr)
end

local function GetHeroPowerCache(key)
    if HeroPowerCache == nil then
        PveUtil.LoadHeroPowerCache()
    end
    return HeroPowerCache[key]
end

local function SetHeroPowerCache(key, val)
    if HeroPowerCache == nil then
        PveUtil.LoadHeroPowerCache()
    end
    HeroPowerCache[key] = val
end

local function ClearHeroPowerCache()
    Setting:SetString(SettingKeys.PVE_HERO_POWER_CACHE .. LuaEntry.Player.uid, "")
    HeroPowerCache = {}
end

local function GetCacheKey(heroDataDict)
    local heroUuidList = table.keys(heroDataDict)
    table.sort(heroUuidList)
    local key = string.join(heroUuidList, ";")
    return key
end

local function GetRecommendMonsterId(diff)
    local k3 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k3") or ""
    local k4 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k4") or ""
    local k3Strs = string.split(k3, "|")
    local k4Strs = string.split(k4, "|")
    local x
    local y
    local startId
    local endId

    if k3Strs[diff] == nil then
        return nil
    end

    local xySpls = string.split(k3Strs[diff], ";")
    if #xySpls == 2 then
        x = tonumber(xySpls[1])
        y = tonumber(xySpls[2])
    end

    if x == nil or y == nil then
        return nil
    end

    if #k4Strs == 2 then
        startId = tonumber(k4Strs[1])
        endId = tonumber(k4Strs[2])
    end

    if startId == nil or endId == nil then
        return nil
    end

    local originHeroDataList = DataCenter.HeroDataManager:GetHeroSortList()
    table.sort(originHeroDataList, function(heroA, heroB)
        local heroPowerA = PveUtil.GetHeroPower({ [heroA.uuid] = heroA })
        local heroPowerB = PveUtil.GetHeroPower({ [heroB.uuid] = heroB })
        if heroPowerA ~= heroPowerB then
            return heroPowerA > heroPowerB
        else
            return heroA.heroId < heroB.heroId
        end
    end)
    
    local heroDataList = {}
    for _, heroData in ipairs(originHeroDataList) do
        if #heroDataList >= x then
            break
        end
        if heroData.level < heroData.finalLevel and heroData.level < heroData.curMaxLevel then
            table.insert(heroDataList, heroData)
        end
    end
    if #heroDataList == 0 then
        table.insert(heroDataList, originHeroDataList[1])
    end

    local originPower = math.floor(PveUtil.GetAverageHeroPower(heroDataList))
    local power = math.floor(originPower * (1 + y))

    local selectId = startId
    local min = IntMaxValue
    for id = startId, endId do
        local recommendPower = DataCenter.MonsterTemplateManager:GetRecommendPower(id)
        if math.abs(power - recommendPower) < min then
            min = math.abs(power - recommendPower)
            selectId = id
        end
        
    end

    PveUtil.SaveHeroPowerCache()

    return selectId
end

local function GetAverageHeroPower(heroDataList)
    local power = 0
    
    if #heroDataList == 0 then
        return 0
    elseif #heroDataList == 1 then
        local dict = {}
        dict[heroDataList[1].uuid] = heroDataList[1]
        power = power + PveUtil.GetHeroPower(dict)
    else
        if #heroDataList % 2 == 1 then
            local m = #heroDataList // 2 + 1
            table.remove(heroDataList, m)
        end
        
        local dict = {}
        local count = 0
        for _, heroData in ipairs(heroDataList) do
            dict[heroData.uuid] = heroData
            if table.count(dict) == 2 then
                power = power + PveUtil.GetHeroPower(dict)
                count = count + 1
                dict = {}
            end
        end
        power = power / count
    end

    return power
end

local function GetHeroPower(heroDataDict)
    local key = PveUtil.GetCacheKey(heroDataDict)
    
    -- try load cache
    if PveUtil.GetHeroPowerCache(key) ~= nil then
        return PveUtil.GetHeroPowerCache(key)
    end
    
    local army = PveActorMgr:GetInstance():GetArmyDataForHeroExpBattleLevel(heroDataDict)
    local power = MarchUtil.GetFormationPower(heroDataDict, army, 1,MarchUtil.GetCampAddParam(heroDataDict))
    
    -- save cache
    PveUtil.SetHeroPowerCache(key, power)
    
    return power
end

local function GetRecommendLevelLimitMonsterId()
    local k4 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k4") or ""
    local k5 = LuaEntry.DataConfig:TryGetStr("aps_pve_exp", "k5") or ""
    local k4Strs = string.split(k4, "|")
    local k5Strs = string.split(k5, ";")

    local x
    local y
    local startId
    local endId

    if #k5Strs == 2 then
        x = tonumber(k5Strs[1])
        y = tonumber(k5Strs[2])
    end

    if x == nil or y == nil then
        return nil
    end

    if #k4Strs == 2 then
        startId = tonumber(k4Strs[1])
        endId = tonumber(k4Strs[2])
    end

    if startId == nil or endId == nil then
        return nil
    end

    local originHeroDataList = DataCenter.HeroDataManager:GetHeroSortList()
    table.sort(originHeroDataList, function(heroA, heroB)
        local heroPowerA = PveUtil.GetHeroPower({ [heroA.uuid] = heroA })
        local heroPowerB = PveUtil.GetHeroPower({ [heroB.uuid] = heroB })
        if heroPowerA ~= heroPowerB then
            return heroPowerA > heroPowerB
        else
            return heroA.heroId < heroB.heroId
        end
    end)

    local heroDataList = {}
    for _, heroData in ipairs(originHeroDataList) do
        if #heroDataList >= x then
            break
        end
        if heroData.level < heroData.finalLevel then
            table.insert(heroDataList, heroData)
        end
    end
    if #heroDataList == 0 then
        table.insert(heroDataList, originHeroDataList[1])
    end

    local originPower = PveUtil.GetAverageHeroPower(heroDataList)
    local power = originPower * (1 + y)

    local selectId = startId
    local min = IntMaxValue
    for id = startId, endId do
        local recommendPower = DataCenter.MonsterTemplateManager:GetRecommendPower(id)
        if math.abs(power - recommendPower) < min then
            min = math.abs(power - recommendPower)
            selectId = id
        end
    end

    PveUtil.SaveHeroPowerCache()

    return selectId
end

-- 检查突破
local function CheckHeroesBreak(heroUuidList, OnContinue)
    if GetCheckFlag() & CheckFlag.HeroBeyond ~= 0 then
        for _, heroUuid in pairs(heroUuidList) do
            if PveUtil.CheckHeroBreak(heroUuid, OnContinue) then
                return
            end
        end
    end
    if OnContinue then
        OnContinue()
    end
end

local function CheckHeroBreak(heroUuid, OnContinue)
    local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    if heroData ~= nil then
        if heroData:CanBeyond() then
            if ShowHeroBeyondFlag then
                local name = HeroUtils.GetHeroNameByConfigId(heroData.heroId)
                UIUtil.ShowSecondMessage(Localization:GetString("100378"), Localization:GetString("400082", name), 2, GameDialogDefine.GOTO, GameDialogDefine.CONTINUE, function()
                    DataCenter.HeroDataManager:BeyondHero(heroUuid)
                end, function(show)
                    ShowHeroBeyondFlag = show
                end, OnContinue)
                return true
            end
        end
    end
    return false
end

-- 检查满级
local function CheckHeroesMaxed(heroUuidList, OnContinue)
    if GetCheckFlag() & CheckFlag.HeroMaxed ~= 0 then
        for _, heroUuid in pairs(heroUuidList) do
            if PveUtil.CheckHeroMaxed(heroUuid, OnContinue) then
                return
            end
        end
    end
    if OnContinue then
        OnContinue()
    end
end

local function CheckHeroMaxed(heroUuid, OnContinue)
    local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    if heroData ~= nil then
        if heroData.level >= heroData.finalLevel then
            if ShowHeroMaxedFlag then
                local name = HeroUtils.GetHeroNameByConfigId(heroData.heroId)
                UIUtil.ShowSecondMessage(Localization:GetString("100378"), Localization:GetString("400072", name), 2, GameDialogDefine.CANCEL, GameDialogDefine.CONTINUE, nil, function(show)
                    ShowHeroMaxedFlag = show
                end, OnContinue)
                return true
            end
        end
    end
    return false
end

-- 检查更高品质
local function CheckHeroesRarity(heroUuidList, OnConfirm)
    if GetCheckFlag() & CheckFlag.HeroRarity ~= 0 then
        for _, heroUuid in pairs(heroUuidList) do
            if PveUtil.CheckHeroRarity(heroUuidList, heroUuid, OnConfirm) then
                return
            end
        end
    end
    if OnConfirm then
        OnConfirm()
    end
end

-- heroUuidList: 已经选择的英雄，排除用
local function CheckHeroRarity(heroUuidList, heroUuid, OnConfirm)
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    local heroDataList = DataCenter.HeroDataManager:GetHeroSortList()
    local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    if heroData ~= nil then
        for _, v in ipairs(heroDataList) do
            if v.uuid ~= heroUuid and
               v.rarity < heroData.rarity --[[反着来的]] and
               not table.hasvalue(heroUuidList, v.uuid) and
               (entranceType ~= PveEntrance.MineCave or not DataCenter.MineCaveManager:CheckIfHeroIsBusy(v.heroId))
            then
                if ShowHeroRarityFlag then
                    UIUtil.ShowSecondMessage(Localization:GetString("100378"), Localization:GetString("400054"), 2, "400085",
                            GameDialogDefine.CONTINUE, function()
                                DataCenter.GuideManager:CheckDoTriggerGuide(GuideTriggerType.MoreRarityHero, SaveGuideDoneValue)
                    end, function(show)
                        ShowHeroRarityFlag = show
                    end, OnConfirm)
                    return true
                end
            end
        end
    end
    return false
end

-- 检查空位
local function CheckHeroSlotEmpty(curCount, maxCount, OnConfirm)
    if GetCheckFlag() & CheckFlag.HeroSlotEmpty ~= 0 then
        local totalCount = table.count(DataCenter.HeroDataManager:GetMasterHeroList())
        if curCount < maxCount and curCount < totalCount then
            if ShowHeroSlotEmptyFlag then
                UIUtil.ShowSecondMessage(Localization:GetString("100378"), Localization:GetString("400081"), 2, "400083", GameDialogDefine.CONTINUE, nil, function(show)
                    ShowHeroSlotEmptyFlag = show
                end, OnConfirm)
                return
            end
        end
    end
    if OnConfirm then
        OnConfirm()
    end
end

local function ParseArmyRecord(serverData)
    if string.IsNullOrEmpty(serverData) then
        return nil
    end

    -- total = alive + dead
    local total, alive, dead = {}, {}, {}
    local totalCount, aliveCount, deadCount = 0, 0, 0
    local records = string.split(serverData, ",")
    local totalRecord, deadRecord = records[1], records[2]
    if totalRecord then
        local strs = string.split(totalRecord, "|")
        for _, str in ipairs(strs) do
            local spls = string.split(str, ";")
            if #spls == 2 then
                local armsId = tonumber(spls[1])
                local count = tonumber(spls[2])
                total[armsId] = count
                totalCount = totalCount + count
            end
        end
    end
    if deadRecord then
        local strs = string.split(deadRecord, "|")
        for _, str in ipairs(strs) do
            local spls = string.split(str, ";")
            if #spls == 2 then
                local armsId = tonumber(spls[1])
                local count = tonumber(spls[2])
                dead[armsId] = count
                deadCount = deadCount + count
            end
        end
    end
    for armsId, _ in pairs(total) do
        local count = total[armsId] - (dead[armsId] or 0)
        if count > 0 then
            alive[armsId] = count
            aliveCount = aliveCount + count
        end
    end
    local record =
    {
        total = total,
        alive = alive,
        dead = dead,
        totalCount = totalCount,
        aliveCount = aliveCount,
        deadCount = deadCount,
    }
    return record
end

local function CanShowPowerLack(param)
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.Story then
        local str = LuaEntry.DataConfig:TryGetStr("push_level", "k7")
        local spls = string.split(str, ";")
        if #spls == 2 then
            local mapId = tonumber(spls[1])
            local level = tonumber(spls[2])
            local state = DataCenter.StoryManager:GetLevelState(mapId, level)
            if state == StoryLevelState.Finished then
                return false
            end
        end
    end
    
    local lackType = PveUtil.GetPowerLack(param)
    return lackType ~= PvePowerLackType.None
end

-- param: { monsterId, power, armyDict, heroUuidList }
local function GetPowerLack(param)
    local tips = {}
    local needPower = DataCenter.MonsterTemplateManager:GetRecommendPower(param.monsterId)
    
    -- army
    local armyCount = 0
    for id, count in pairs(param.armyDict) do
        local template = DataCenter.ArmyTemplateManager:GetArmyTemplate(id)
        if template.level >= DataCenter.MonsterTemplateManager:GetNeedArmyLevel(param.monsterId) then
            armyCount = armyCount + count
        end
    end
    if armyCount < DataCenter.MonsterTemplateManager:GetNeedArmyCount(param.monsterId) then
        for _, tip in ipairs(PvePowerLackShowTips[PvePowerLackType.Army]) do
            local templates = DataCenter.ResLackManager:GetTemplatesByTip(tip)
            for _, template in ipairs(templates) do
                if template:CheckMainLevel() then
                    table.insert(tips, tip)
                    break
                end
            end
        end
    end
    if #tips > 0 then
        return PvePowerLackType.Army, tips
    end
    
    -- hero
    local heroCount = 0
    for _, heroUuid in ipairs(param.heroUuidList) do
        local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
        if heroData.level >= DataCenter.MonsterTemplateManager:GetNeedHeroLevel(param.monsterId) then
            heroCount = heroCount + 1
        end
    end
    if heroCount < DataCenter.MonsterTemplateManager:GetNeedHeroCount(param.monsterId) then
        for _, tip in ipairs(PvePowerLackShowTips[PvePowerLackType.Hero]) do
            local templates = DataCenter.ResLackManager:GetTemplatesByTip(tip)
            for _, template in ipairs(templates) do
                if template:CheckMainLevel() then
                    table.insert(tips, tip)
                    break
                end
            end
        end
    end
    if #tips > 0 then
        return PvePowerLackType.Hero, tips
    end
    
    -- power
    if param.power < needPower then
        for _, tip in ipairs(PvePowerLackShowTips[PvePowerLackType.Power]) do
            local templates = DataCenter.ResLackManager:GetTemplatesByTip(tip)
            for _, template in ipairs(templates) do
                if template:CheckMainLevel() then
                    table.insert(tips, tip)
                    break
                end
            end
        end
    end
    if #tips > 0 then
        return PvePowerLackType.Power, tips
    end
    
    return PvePowerLackType.None, tips
end

-- 获取战力不足弹板的点击回调
-- param: { tip, heroUuidList, closeFunc, lackType }
local function GetPowerLackTipClickFunc(param)
    --local armyDict = PveActorMgr:GetInstance():GetArmys() or {}
    local func = nil

    -- sort
    local heroUuidList = DeepCopy(param.heroUuidList)
    table.sort(heroUuidList, function(heroUuidA, heroUuidB)
        local heroDataA = DataCenter.HeroDataManager:GetHeroByUuid(heroUuidA)
        local heroDataB = DataCenter.HeroDataManager:GetHeroByUuid(heroUuidB)
        if heroDataA.rarity ~= heroDataB.rarity then
            return heroDataA.rarity < heroDataB.rarity
        elseif heroDataA.level ~= heroDataB.level then
            return heroDataA.level > heroDataB.level
        else
            return heroDataA.heroId < heroDataB.heroId
        end
    end)
    
    --local function GoHeroList()
    --    UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroList, { anim = false, UIMainAnim = UIMainAnimType.AllHide }, nil, nil, nil, function()
    --        -- on close
    --        for _, heroUuid in pairs(heroUuidList) do
    --            local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    --            PveActorMgr:GetInstance():SetModelHeroLv(heroData.heroId, heroData.level)
    --        end
    --        UIUtil.PveSceneHeroListRefresh()
    --    end)
    --end
    
    -- 4 建筑升级
    if param.tip == PvePowerLackTipType.BuildingUpgrade then
        local strs = string.split(param.template.para1, ";")
        for _, str in ipairs(strs) do
            local buildId = tonumber(str) or 0
            local buildData = DataCenter.BuildManager:GetFunbuildByItemID(buildId)
            if buildData and buildData.level > 0 then
                func = function()
                    GoToUtil.GotoCityByBuildId(buildId, WorldTileBtnType.City_Upgrade)
                end
                break
            end
        end
    end

    -- 53 英雄升级
    if param.tip == PvePowerLackTipType.HeroExpBook then
        if #heroUuidList > 0 then
            for _, heroUuid in pairs(heroUuidList) do
                local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
                if heroData then
                    if heroData.level < heroData.finalLevel then
                        local needMainLv = tonumber(GetTableData(TableName.NewHeroesLevelUp, heroData.level + 1, "levelup_require_base")) or 0
                        if DataCenter.BuildManager.MainLv >= needMainLv then
                            func = function()
                                UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroInfo, HeroInfoViewType.HeroList, heroData.uuid, heroUuidList, nil, UIHeroInfoView.TabType.Info)
                            end
                            break
                        end
                    end
                end
            end
        end

    -- (-53) 英雄升级或突破
    --elseif param.tip == PvePowerLackTipType.HeroExpOrBeyond then
    --    func = GoHeroList

    -- 54 英雄升军阶
    --elseif param.tip == PvePowerLackTipType.HeroUpgradeRank then
    --    local toHeroUuid = nil
    --    local maxPower = -1
    --    for _, heroUuid in pairs(heroUuidList) do
    --        local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    --        if heroData and heroData:CanUpMilitaryRank(true) then
    --            local power = HeroUtils.GetHeroPower(heroData)
    --            if power > maxPower then
    --                toHeroUuid = heroUuid
    --            end
    --        end
    --    end
    --    if toHeroUuid then
    --        func = GoHeroList
    --    end

    -- 55 英雄升星
    --elseif param.tip == PvePowerLackTipType.HeroUpgradeStar then
    --    for _, heroUuid in pairs(heroUuidList) do
    --        local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    --        if heroData and HeroAdvanceController:GetInstance():HasFullDogForCore(heroData) then
    --            func = function()
    --                GoToUtil.GotoCityByBuildId(BuildingTypes.APS_BUILD_PUB, WorldTileBtnType.Hero_Advance)
    --            end
    --            break
    --        end
    --    end

    -- 56 英雄升级技能
    --elseif param.tip == PvePowerLackTipType.HeroUpgradeSkill then
    --    func = GoHeroList

    -- 57 训练士兵
    --elseif param.tip == PvePowerLackTipType.TrainUnit then
    --    local count = 0
    --    for _, v in pairs(armyDict) do
    --        count = count + v
    --    end
    --    local maxCount = PveUtil.GetMaxSoldierNum(heroUuidList)
    --    if count < maxCount then
    --        func = function()
    --            GoToUtil.GotoCityByBuildId(BuildingTypes.FUN_BUILD_INFANTRY_BARRACK, WorldTileBtnType.City_TrainingInfantry)
    --        end
    --    end

    -- 58 替换高等级英雄
    --elseif param.tip == PvePowerLackTipType.HeroHigherLevel then
    --    local toHeroUuid = nil
    --    local toLevel = IntMinValue
    --    for _, heroUuid in pairs(heroUuidList) do
    --        local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    --        if heroData and heroData.level > toLevel then
    --            toLevel = heroData.level
    --        end
    --    end
    --    for k, v in pairs(DataCenter.HeroDataManager:GetMasterHeroList()) do
    --        if v.level > toLevel then
    --            toHeroUuid = v.uuid
    --            toLevel = v.level
    --        end
    --    end
    --    if toHeroUuid then
    --        func = function()
    --            UIUtil.PveSceneHeroListScrollToHero(toHeroUuid)
    --        end
    --    end

    -- 59 替换高战力英雄
    --elseif param.tip == PvePowerLackTipType.HeroHigherPower then
    --    local toHeroUuid = nil 
    --    local toPower = IntMinValue
    --    for _, heroUuid in pairs(heroUuidList) do
    --        local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
    --        local power = HeroUtils.GetHeroPower(heroData)
    --        if heroData and power > toPower then
    --            toPower = power
    --        end
    --    end
    --    for k, v in pairs(DataCenter.HeroDataManager:GetMasterHeroList()) do
    --        local power = HeroUtils.GetHeroPower(v)
    --        if power > toPower then
    --            toHeroUuid = v.uuid
    --            toPower = power
    --        end
    --    end
    --    if toHeroUuid then
    --        func = function()
    --            UIUtil.PveSceneHeroListScrollToHero(toHeroUuid)
    --        end
    --    end

    -- 60 英雄突破
    elseif param.tip == PvePowerLackTipType.HeroStrengthen then
        if #heroUuidList > 0 then
            for _, heroUuid in pairs(heroUuidList) do
                local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
                if heroData then
                    if heroData:CanEtoileUp() then
                        func = function()
                            UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroInfo, HeroInfoViewType.HeroList, heroData.uuid, heroUuidList, nil, UIHeroInfoView.TabType.Quality)
                        end
                        break
                    end
                end
            end
        end

    -- 61 首充
    elseif param.tip == PvePowerLackTipType.FirstPay then
        if LuaEntry.DataConfig:CheckSwitch("first_pay_choosen") then
            local needLv = LuaEntry.DataConfig:TryGetNum("first_pay_choosen", "k3")
            if DataCenter.BuildManager.MainLv >= needLv and not DataCenter.ActFirstChargeData:HasBought() then
                func = function()
                    UIManager:GetInstance():OpenWindow(UIWindowNames.UIFirstCharge, { anim = false, UIMainAnim = UIMainAnimType.AllHide })
                end
            end
        else
            if DataCenter.PayManager:CheckIfFirstPayOpen() then
                func = function()
                    UIManager:GetInstance():OpenWindow(UIWindowNames.UIFirstPay, { anim = false, UIMainAnim = UIMainAnimType.AllHide })
                end
            end
        end

    -- 62 主线任务
    --elseif param.tip == PvePowerLackTipType.MainQuest then
    --    func = function()
    --        GoToUtil.CloseAllWindows()
    --        DataCenter.ChapterTaskCellManager:SetPvePowerState(true)
    --    end

    -- 71 英雄招募
    elseif param.tip == PvePowerLackTipType.HeroRecruit then
        local hasBuilding = DataCenter.BuildManager:HasBuilding(BuildingTypes.APS_BUILD_PUB)
        if hasBuilding then
            if DataCenter.LotteryDataManager:HaveFree() or DataCenter.LotteryDataManager:CanAnySingleRecruit() then
                func = function()
                    UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroRecruit)
                end
            end
        end

    -- 74 英雄月卡
    --elseif param.tip == PvePowerLackTipType.HeroMonthCard then
    --    if DataCenter.PayManager:CheckHeroMonthCardTip() then
    --        func = function()
    --            UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroMonthCard, { anim = false, UIMainAnim = UIMainAnimType.AllHide })
    --        end
    --    end
    
    -- 95 更换英雄
    --elseif param.tip == PvePowerLackTipType.HeroChange then
    --    func = function()
    --        
    --    end
    
    -- 2009 英雄更换装备
    elseif param.tip == PvePowerLackTipType.HeroEquip then
        if #heroUuidList > 0 then
            for _, heroUuid in pairs(heroUuidList) do
                local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
                if heroData then
                    if heroData:HasEquipInstall() then
                        func = function()
                            UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroInfo, HeroInfoViewType.HeroList, heroData.uuid, heroUuidList, nil, UIHeroInfoView.TabType.Equip)
                        end
                        break
                    end
                end
            end
        end
        
    -- 2010 查看雷达事件
    elseif param.tip == PvePowerLackTipType.DetectEvent then
        local hasBuilding = DataCenter.BuildManager:HasBuilding(BuildingTypes.FUN_BUILD_RADAR_CENTER)
        if hasBuilding then
            if DataCenter.RadarCenterDataManager:CanShowBuildBubble(true) then
                func = function()
                    UIManager:GetInstance():OpenWindow(UIWindowNames.UIDetectEvent)
                end
            end
        end
    end
    
    if func then
        return function()
            SceneUtils.ChangeToCity(function()
                UIManager:GetInstance():DestroyWindow(UIWindowNames.UIParkourBattleLose)
                func()
                if param.closeFunc then
                    param.closeFunc()
                end
            end)
        end
    end

    return nil
end

-- PVE 最大带兵量
local function GetMaxSoldierNum(heroUuidList)
    local asPlayerMaxSoldiers = LuaEntry.DataConfig:TryGetNum("building_base", "k5")
    local baseSize = LuaEntry.Effect:GetGameEffect(EffectDefine.APS_FORMATION_SIZE)
    local sizeEnhance = LuaEntry.Effect:GetGameEffect(EffectDefine.APS_FORMATION_SIZE_ENHANCE)
    asPlayerMaxSoldiers = asPlayerMaxSoldiers + math.floor(baseSize+0.5)
    local campAdd = 0
    if heroUuidList then
        for _, heroUuid in pairs(heroUuidList) do
            local heroData = DataCenter.HeroDataManager:GetHeroByUuid(heroUuid)
            if heroData~=nil then
                local config = heroData:GetConfig()
                local rankId = heroData:GetCurMilitaryRankId()
                local armyAdd = HeroUtils.GetArmyLimit(heroData.level, rankId, config['rarity'], heroData.heroId,heroData.quality)
                asPlayerMaxSoldiers = asPlayerMaxSoldiers+armyAdd
                local heroBaseSize = heroData:GetEffectNum(EffectDefine.APS_FORMATION_SIZE)
                local heroSizeEnhance = heroData:GetEffectNum(EffectDefine.APS_FORMATION_SIZE_ENHANCE)
                local campAddEffect = LuaEntry.Effect:GetGameEffect(HeroUtils.GetExtraTroopByCamp(heroData:GetCamp()))
                campAdd = campAddEffect + campAdd
                asPlayerMaxSoldiers = asPlayerMaxSoldiers + heroBaseSize
                sizeEnhance = sizeEnhance + heroSizeEnhance
            end
        end
    end
    local formationIndex = 1
    local entranceType = DataCenter.BattleLevel:GetEntranceType()
    if entranceType == PveEntrance.MineCave then
        local _, formationUuid = DataCenter.MineCaveManager:GetBattleParam()
        local formationInfo = DataCenter.ArmyFormationDataManager:GetOneArmyInfoByUuid(formationUuid)
        formationIndex = formationInfo.index
    end
    local finalAddNumByIndex = MarchUtil.GetFormationMaxNumByFormationIndex(formationIndex)
    asPlayerMaxSoldiers = asPlayerMaxSoldiers + finalAddNumByIndex + campAdd
    asPlayerMaxSoldiers = asPlayerMaxSoldiers * (1 + (sizeEnhance / 100))
    local campFinalAdd = MarchUtil.GetHeroCampAddArmyCount(HeroUtils.GetPveHeroDataListByUuids(heroUuidList))
    asPlayerMaxSoldiers = asPlayerMaxSoldiers + campFinalAdd
    return math.floor(asPlayerMaxSoldiers)
end

local function CanAddStamina()
    local para = LuaEntry.DataConfig:TryGetNum("pve_energy", "k5") or 0
    if para == 0 then
        return true
    end

    local buildId = DataCenter.BuildManager:GetBuildId(para)
    local level = DataCenter.BuildManager:GetBuildLevel(para)
    local buildData = DataCenter.BuildManager:GetMaxLvBuildDataByBuildId(buildId)
    if buildData and buildData.level >= level then
        return true
    end

    return false
end

local function ParseBattleContent(message)
    local battleContent = ""
    if message["battleContent"] then
        battleContent = message["battleContent"]
    elseif message["battleContentArr"] then
        for _, v in ipairs(message["battleContentArr"]) do
            battleContent = battleContent .. v
        end
    end
    return battleContent
end

local function ParseDetailContent(message)
    local detailContent = ""
    if message["detailContentList"] then
        return PveUtil.ParseDetailContent(message["detailContentList"][1])
    else
        if message["detailContent"] then
            detailContent = message["detailContent"]
        elseif message["detailContentArr"] then
            for _, v in ipairs(message["detailContentArr"]) do
                detailContent = detailContent .. v
            end
        end
    end
    
    return detailContent
end

local function EnterPve(param)
    assert(param ~= nil and param.pveId ~= nil)
    Logger.Log("PveUtil.EnterPve: " .. param.pveId)
    local pveType = tonumber(GetTableData(TableName.Pve, param.pveId, "type"))
    if pveType == PveType.C_5v5 then
        param.levelId = param.pveId
        DataCenter.BattleLevel:Enter(param)
    elseif pveType == PveType.B_Parkour then
        param.type = PVEType.Parkour
        param.levelId = tonumber(GetTableData(TableName.Pve, param.pveId, "pve_level"))
        DataCenter.LWBattleManager:Enter(param)
    end
end

local function GetPveHeroAttack(heroId, level, rankId)
    local key = "pve_atk"
    local base = tonumber(GetTableData(HeroUtils.GetHeroXmlName(), heroId, key)) or 10000
    local levelAdd = tonumber(GetTableData(TableName.NewHeroesLevelUp, level, key)) or 10
    local rankAdd = tonumber(GetTableData(TableName.HeroMilitaryRank, rankId, key)) or 0
    local equipAdd = DataCenter.HeroEquipManager:GetEquipValueSumByHeroId(heroId, key)
    local atk = base * (levelAdd + rankAdd) / 10000 + equipAdd
    return atk
end

local function GetPveHeroDefence(heroId, level, rankId)
    local key = "pve_def"
    local base = tonumber(GetTableData(HeroUtils.GetHeroXmlName(), heroId, key)) or 10000
    local levelAdd = tonumber(GetTableData(TableName.NewHeroesLevelUp, level, key)) or 10
    local rankAdd = tonumber(GetTableData(TableName.HeroMilitaryRank, rankId, key)) or 0
    local equipAdd = DataCenter.HeroEquipManager:GetEquipValueSumByHeroId(heroId, key)
    local def = base * (levelAdd + rankAdd) / 10000 + equipAdd
    return def
end

local function GetPveHeroHp(heroId, level, rankId)
    local key = "pve_hp"
    local base = tonumber(GetTableData(HeroUtils.GetHeroXmlName(), heroId, key)) or 10000
    local levelAdd = tonumber(GetTableData(TableName.NewHeroesLevelUp, level, key)) or 10
    local rankAdd = tonumber(GetTableData(TableName.HeroMilitaryRank, rankId, key)) or 0
    local equipAdd = DataCenter.HeroEquipManager:GetEquipValueSumByHeroId(heroId, key)
    local hp = base * (levelAdd + rankAdd) / 10000 + equipAdd
    return hp
end

local function GetPveMonsterAttack(id)
    local key = "pve_atk"
    local atk = tonumber(GetTableData(TableName.LW_Monster, id, key)) or 10
    return atk
end

local function GetPveMonsterDefence(id)
    local key = "pve_def"
    local def = tonumber(GetTableData(TableName.LW_Monster, id, key)) or 10
    return def
end

local function GetPveMonsterHp(id)
    local key = "pve_hp"
    local hp = tonumber(GetTableData(TableName.LW_Monster, id, key)) or 10
    return hp
end

local function CalculateAttack(unit)
    if unit.type == Const.ParkourUnitType.Hero then
        return PveUtil.GetPveHeroAttack(unit.hero.heroId, unit.hero.level, unit.hero.curMilitaryRankId)
    else
        return PveUtil.GetPveMonsterAttack(unit.meta.id)
    end
end

local function CalculateDefence(unit)
    if unit.type == Const.ParkourUnitType.Hero then
        return PveUtil.GetPveHeroDefence(unit.hero.heroId, unit.hero.level, unit.hero.curMilitaryRankId)
    else
        return PveUtil.GetPveMonsterDefence(unit.meta.id)
    end
end

local function CalculateHP(unit)
    if unit.type == Const.ParkourUnitType.Hero then
        return PveUtil.GetPveHeroHp(unit.hero.heroId, unit.hero.level, unit.hero.curMilitaryRankId)
    else
        return PveUtil.GetPveMonsterHp(unit.meta.id)
    end
end

--伤害计算
---@param attacker number 攻击方
---@param defender number 挨打方
---@param damageType DamageType 伤害类型：物理or魔法
---@param damageMultiplier number 伤害倍率
---@param exType ExDamageType 额外伤害类型：攻击方攻击力的x%，目标最大生命值的x%
---@param exValue number 额外伤害数值：x% 是一个小数，不是百分数
---返回：damage,isCritical,isMiss,nakedDamage
local function CalculateDamage(attacker,defender,damageType,damageMultiplier,exType,exValue)
    local damage = 0
    local exDamage = 0
    local useStageEffect = false
    if attacker.hero ~= nil then
        useStageEffect = true
    end

    local attack
    if exType then
        if exType==ExDamageType.attackPercent then
            attack = CalculateAttack(attacker)
            exDamage = attack * exValue
        elseif exType==ExDamageType.hpPercent then
            local hp = CalculateHP(defender)
            exDamage = hp * exValue
        end
    end

    if damageMultiplier <= 0 then
        return exDamage, false, false, exDamage
    end

    --攻击力计算：
    if not attack then
        attack = CalculateAttack(attacker)
    end

    --防御力计算：
    local defence = CalculateDefence(defender)

    --暴击率计算：
    local criticalRate = 0.05
    if useStageEffect then
        criticalRate = criticalRate + DataCenter.LWBattleManager.logic.stageEffectMgr:Get(StageEffectType.CriticalRate)
    end

    local isCritical = false
    local criticalDamage = 1
    if math.random() < criticalRate then
        isCritical = true
        if useStageEffect then
            criticalDamage = criticalDamage + DataCenter.LWBattleManager.logic.stageEffectMgr:Get(StageEffectType.CriticalDamage)
        end
    end

    damage = attack * attack / (attack + defence)
    damage = damage * damageMultiplier
    if isCritical then
        damage = damage * (1 + criticalDamage)
    end
    damage = damage + exDamage
    if useStageEffect then
        damage = damage * (1 + DataCenter.LWBattleManager.logic.stageEffectMgr:Get(StageEffectType.Damage))
    end
    damage = math.ceil(damage)

    -- 统计承受伤害用的裸奔伤害
    local nakedDamage = attack * damageMultiplier * (1 + criticalDamage) + exDamage
    nakedDamage = math.ceil(nakedDamage)

    return damage, isCritical, false, nakedDamage
end


---返回一个球型范围内某种类型所有物体
---可选参数：
---@param exclusions table unitGuid 排除项 默认{}
local function GetAllUnitsInSphereRange(battleMgr, center, radius, layerMask, exclusions)
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)
        return units
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        cnt = math.min(ColliderArrayCapacity, cnt)
        local ret={}
        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    table.insert(ret,obj)
                    --if not unitType or obj.unitType&unitType>0 then
                    --    table.insert(ret,obj)
                    --end
                end
            end
        end
        return ret
    end
end

---可选参数：
---@param exclusions table unitGuid 排除项 默认{}
local function GetAllUnitsInBoxRange(battleMgr, center, sizeX, sizeZ, layerMask, exclusions)
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInRect(center, sizeX, sizeZ, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)
        return units
    else
        return {}
    end
end

---检查一个球型范围内是否存在某种类型物体
---三个可选参数：
---@param exclusions table unitGuid 排除项 默认nil
---@param n number 检查一个球型范围内是否存在"n个"某种类型物体，默认n=1
---@param unitType number 检查unitType 默认nil
local function CheckHasUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions, n, unitType)
    n = n or 1
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            if unitType and unit:GetUnitType() & unitType == 0 then
                return false
            end
            return true
        end)
        return #units >= n
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt < n then
            return false
        end
        cnt = math.min(ColliderArrayCapacity, cnt)

        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    if not unitType or obj.unitType&unitType>0 then
                        n = n - 1
                        if n == 0 then
                            return obj
                        end
                    end
                end
            end
        end
        return false
    end
end

--返回一个球型范围内某类物体随机实例
---三个可选参数：
---@param exclusions table unitGuid 排除项 默认nil
local function FindRandomUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions)
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)
        if #units > 0 then
            return table.randomArrayValue(units)
        else
            return nil
        end
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt <= 0 then
            return false
        end
        cnt = math.min(ColliderArrayCapacity, cnt)
        local index = math.random(cnt)--随机一个遍历起点
        for i = 1, cnt do
            local collider = colliderArray[index - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    return obj
                end
            end
            index = index + 1
            if index > cnt then
                index = 1
            end
        end
        return false
    end
end


--返回一个球型范围内某类物体"到指定点"最近实例
---@param exclusions table unitGuid 排除项 默认nil
local function FindNearestUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions, targetPos)
    targetPos = targetPos or center
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)

        local minDis = IntMaxValue
        local minDisUnit = nil
        for _, unit in ipairs(units) do
            local dis = Vector3.ManhattanDistanceXZ(unit:GetPosition(), targetPos)
            if dis < minDis then
                minDis = dis
                minDisUnit = unit
            end
        end
        return minDisUnit
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt <= 0 then
            return nil
        end
        local nearest
        local minDist = 1000000
        cnt = math.min(ColliderArrayCapacity, cnt)
        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    local dist = Vector3.ManhattanDistanceXZ(obj:GetPosition(), targetPos)
                    if dist < minDist then
                        minDist = dist
                        nearest = obj
                    end
                end
            end
        end
        return nearest
    end
end

--返回一个球型范围内某类物体"到指定点"最远实例
---@param exclusions table unitGuid 排除项 默认nil
local function FindFarthestUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions, targetPos)
    targetPos = targetPos or center
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)

        local maxDis = -1
        local maxDisUnit = nil
        for _, unit in ipairs(units) do
            local dis = Vector3.ManhattanDistanceXZ(unit:GetPosition(), targetPos)
            if dis > maxDis then
                maxDis = dis
                maxDisUnit = unit
            end
        end
        return maxDisUnit
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt <= 0 then
            return nil
        end
        targetPos = targetPos or center
        local farthest
        local maxDist = 0
        cnt = math.min(ColliderArrayCapacity, cnt)
        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    local dist = Vector3.Distance(obj:GetPosition(), targetPos)
                    if dist > maxDist then
                        maxDist = dist
                        farthest = obj
                    end
                end
            end
        end
        return farthest
    end
end


--返回一个球型范围内某类物体hp最低实例
---@param exclusions table unitGuid 排除项 默认nil
local function FindLowestHPUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions)
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)

        local minHp = IntMaxValue
        local minHpUnit = nil
        for _, unit in ipairs(units) do
            local hp = unit:GetCurBlood()
            if hp < minHp then
                minHp = hp
                minHpUnit = unit
            end
        end
        return minHpUnit
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt <= 0 then
            return nil
        end
        local lowest
        local lowestHP = 1000000
        cnt = math.min(ColliderArrayCapacity, cnt)
        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    local blood = obj:GetCurBlood()
                    if blood < lowestHP then
                        lowestHP = blood
                        lowest = obj
                    end
                end
            end
        end
        return lowest
    end
end

--返回一个球型范围内某类物体maxHp最高实例
---@param exclusions table unitGuid 排除项 默认nil
local function FindHighestMaxHPUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions)
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)

        local maxHp = -1
        local maxHpUnit = nil
        for _, unit in ipairs(units) do
            local hp = unit:GetCurBlood()
            if hp > maxHp then
                maxHp = hp
                maxHpUnit = unit
            end
        end
        return maxHpUnit
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt <= 0 then
            return nil
        end
        local highest
        local highestHP = 0
        cnt = math.min(ColliderArrayCapacity, cnt)
        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    local blood = obj:GetMaxBlood()
                    if blood > highestHP then
                        highestHP = blood
                        highest = obj
                    end
                end
            end
        end
        return highest
    end
end

--返回一个球型范围内某类物体属性最高实例
---@param exclusions table unitGuid 排除项 默认nil
local function FindHighestPropertyUnitInSphereRange(battleMgr, center, radius, layerMask, exclusions, propertyType)
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)

        local maxProp = -IntMaxValue
        local maxPropUnit = nil
        for _, unit in ipairs(units) do
            local prop = unit:GetProperty(propertyType)
            if prop > maxProp then
                maxProp = prop
                maxPropUnit = unit
            end
        end
        return maxPropUnit
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt <= 0 then
            return nil
        end
        local highest
        local highestProperty = 0
        cnt = math.min(ColliderArrayCapacity, cnt)
        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    local property = obj:GetProperty(propertyType)
                    if property > highestProperty then
                        highestProperty = property
                        highest = obj
                    end
                end
            end
        end
        return highest
    end
end

---@param exclusions table unitGuid 排除项 默认nil
local function CheckHasBossInSphereRange(battleMgr, center, radius, layerMask, exclusions, n)
    n = n or 1
    if DataCenter.LWBattleManager:UseNewDetect() then
        local units = battleMgr.unitMgr:GetUnitsInCircle(center, radius, function(unit)
            if unit.gameObject == nil then
                return false
            end
            if not unit.isBoss then
                return false
            end
            if unit:GetCurBlood() <= 0 then
                return false
            end
            if unit:IsStealth() then
                return false
            end
            if (1 << unit.gameObject.layer) & layerMask == 0 then
                return false
            end
            if exclusions and exclusions[unit:GetGuid()] then
                return false
            end
            return true
        end)
        return #units >= n
    else
        local cnt = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask);
        if cnt < n then
            return false
        end
        cnt = math.min(ColliderArrayCapacity, cnt)

        for i = 1, cnt do
            local collider = colliderArray[i - 1]
            local trigger = collider:GetComponent(typeof(CS.CitySpaceManTrigger))
            if trigger ~= nil and trigger.ObjectId ~= 0 then
                local obj = battleMgr:GetUnit(trigger.ObjectId)
                if obj ~= nil and obj:GetCurBlood() > 0 and (not exclusions or not exclusions[obj.guid]) and not obj:IsStealth() then
                    if obj.isBoss then
                        n = n - 1
                        if n == 0 then
                            return obj
                        end
                    end
                end
            end
        end
        return false
    end
end


local function GetTargetLayer(myUnitType,targetTypeTable)
    local layerMask = 0
    local targetIncludeSelf = false
    local targetIncludeAlly = false
    local targetUnitType = 0
    if myUnitType==UnitType.Member then
        for _, v in ipairs(targetTypeTable) do
            if v==PVECamp.Enemy then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Zombie)
                targetUnitType=targetUnitType|UnitType.Zombie
            elseif v==PVECamp.Ally then
                targetIncludeAlly = true
                layerMask=layerMask|LayerMask.GetMask(LayerType.Member)
                targetUnitType=targetUnitType|UnitType.Member
            elseif v==PVECamp.Neutral then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Junk)
                targetUnitType=targetUnitType|UnitType.Junk
            elseif v==PVECamp.Self then
                targetIncludeSelf=true
            end
        end
    elseif myUnitType==UnitType.Zombie then
        for _, v in ipairs(targetTypeTable) do
            if v==PVECamp.Enemy then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Member)
                targetUnitType=targetUnitType|UnitType.Member
            elseif v==PVECamp.Ally then
                targetIncludeAlly = true
                layerMask=layerMask|LayerMask.GetMask(LayerType.Zombie)
                targetUnitType=targetUnitType|UnitType.Zombie
            elseif v==PVECamp.Neutral then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Junk)
                targetUnitType=targetUnitType|UnitType.Junk
            elseif v==PVECamp.Self then
                targetIncludeSelf=true
            end
        end
    elseif myUnitType==UnitType.Junk then
        for _, v in ipairs(targetTypeTable) do
            if v==PVECamp.Enemy then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Zombie)
                targetUnitType=targetUnitType|UnitType.Zombie
            elseif v==PVECamp.Ally then
                targetIncludeAlly = true
                layerMask=layerMask|LayerMask.GetMask(LayerType.Junk)
                targetUnitType=targetUnitType|UnitType.Junk
            elseif v==PVECamp.Neutral then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Junk)
                targetUnitType=targetUnitType|UnitType.Junk
            elseif v==PVECamp.Self then
                targetIncludeSelf=true
            end
        end
    elseif myUnitType==UnitType.TacticalWeapon then
        for _, v in ipairs(targetTypeTable) do
            if v==PVECamp.Enemy then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Zombie)
                targetUnitType=targetUnitType|UnitType.Zombie
            elseif v==PVECamp.Ally then
                targetIncludeAlly = true
                layerMask=layerMask|LayerMask.GetMask(LayerType.Member)
                targetUnitType=targetUnitType|UnitType.Member
            elseif v==PVECamp.Neutral then
                layerMask=layerMask|LayerMask.GetMask(LayerType.Junk)
                targetUnitType=targetUnitType|UnitType.Junk
            elseif v==PVECamp.Self then
                targetIncludeSelf=true
            end
        end
    end
    local targetAllyExcludeSelf = targetIncludeAlly and not targetIncludeSelf
    local targetSelfExcludeAlly = not targetIncludeAlly and targetIncludeSelf
    return layerMask,targetAllyExcludeSelf,targetSelfExcludeAlly,targetUnitType
end


--检查武器是否指向目标，是-return true；否-转向目标 然后return false
local function CheckCannonLookAt(unit,targetPos)

    local cannonTrans=unit.cannon
    local unitPos = unit:GetPosition()
    local targetDir = Vector3.Normalize(targetPos-unitPos)
    if targetDir:SqrMagnitude()<Epsilon then
        return true
    end
    local cannonForward--c#Vector
    if unit.localForward then
        cannonForward = cannonTrans:TransformDirection(unit.localForward)
    else
        cannonForward = cannonTrans.forward
    end
    --c#Vector转luaVector
    cannonWorldForward.x,cannonWorldForward.z = cannonForward.x,cannonForward.z
    local cross=Vector3.Cross(cannonWorldForward,targetDir)
    local deg=math.abs(cross.y)*60--和目标的夹角的正弦的绝对值（单位：度）
    local maxDeg=unit.angular_speed_deg*Time.deltaTime--每帧最多能转多少度
    --和目标的夹角 小于 每帧转角。仅仅检查正弦不足以判断前后，要同时保证夹角余弦为正
    if deg < maxDeg and Vector3.Dot(cannonWorldForward,targetDir)>0 then
        if cross.y > 0 then
            cannonTrans:Rotate(UP,deg,WORLD)
        else
            cannonTrans:Rotate(UP,-deg,WORLD)
        end
        return true
    end
    if cross.y > 0 then
        cannonTrans:Rotate(UP,maxDeg,WORLD)
    else
        cannonTrans:Rotate(UP,-maxDeg,WORLD)
    end
    return false
end

local function SetLayerRecursively(gameObject,layerString)
    local transforms = gameObject:GetComponentsInChildren(typeof(CS.UnityEngine.Transform),true)
    local length=transforms.Length-1
    for i = 0,length do
        if transforms[i].gameObject.layer ~= LayerMask.NameToLayer("PlaneShadowObject")
                and transforms[i].gameObject.layer ~= LayerMask.NameToLayer("OutLine") then
            transforms[i].gameObject.layer = LayerMask.NameToLayer(layerString)
        end
    end
end



local function TryEnterBattle(stageGroupId,stageId)


    -- local squadData = DataCenter.ArmyFormationDataManager:GetTemplateFormationByIndex(1)
    -- 如果没有编队信息，就打开编队界面
    -- local function AutoUseSupplyEnterBattle()
    --     local heroes = squadData:GetAllHeroes()
    --     local supply = HeroUtils.AutoSetHeroesSupply(heroes)

    --     local canEnterBattle = false

    --     if supply == nil or table.count(supply) <= 0 then
    --         canEnterBattle = false
    --     else
    --         for k, v in pairs(supply) do
    --             if v > 0 then
    --                 canEnterBattle = true
    --             end
    --         end
    --     end

    --     if not canEnterBattle then
    --         if table.count(heroes) > 0 then
    --             UIUtil.ShowTipsId(430009)
    --         end
    --         return
    --     end

    --     local slotIndexToSupplyDic = {}
    --     for heroUuid,supplyCount in pairs(supply) do
    --         local slotIndex = table.keyof(heroes,heroUuid)
    --         if slotIndex ~= false then
    --             if supplyCount > 0 then
    --                 slotIndexToSupplyDic[slotIndex] = supplyCount
    --             else
    --                 heroes[slotIndex] = nil
    --             end
    --         end
    --     end


    --     SFSNetwork.SendMessage(MsgDefines.StartPveStage,stageGroupId,stageId,1,slotIndexToSupplyDic,heroes)
    --     -- local param = {}
    --     -- param.levelId = DataCenter.StageManager.stageId
    --     -- DataCenter.ZombieBattleManager:Enter(param)
    -- end

    -- local function UseSquadDataEnterBattle(squadIndex,supply,heroes)

    -- local canEnterBattle = false

    -- if supply == nil or table.count(supply) <= 0 then
    --     canEnterBattle = false
    -- else
    --     for k, v in pairs(supply) do
    --         if v > 0 then
    --             canEnterBattle = true
    --         end
    --     end
    -- end

    -- if not canEnterBattle then
    --     if table.count(heroes) > 0 then
    --         UIUtil.ShowTipsId(430009)
    --     end
    --     return
    -- end

    -- local slotIndexToSupplyDic = {}
    -- for heroUuid,supplyCount in pairs(supply) do
    --     local slotIndex = table.keyof(heroes,heroUuid)

    --     if slotIndex ~= false then
    --         if supplyCount > 0 then
    --             slotIndexToSupplyDic[slotIndex] = supplyCount
    --         else
    --             heroes[slotIndex] = nil
    --         end
    --     end
    -- end


    --     SFSNetwork.SendMessage(MsgDefines.StartPveStage,stageGroupId,stageId,1,nil,heroes)
    -- end

    -- if squadData == nil or table.count(squadData:GetAllHeroes()) <= 0 then
    -- UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroSquadPanel, {anim = true},EnterHeroSquadPanelWay.PveEnterBattle,UseSquadDataEnterBattle)

    -- UIManager:GetInstance():OpenWindow(UIWindowNames.UIHeroPVEFormation, {anim = true},EnterHeroSquadPanelWay.PveEnterBattle,stageGroupId,stageId)

    --进入战斗
    --DataCenter.StageManager:UpdateData(t["stageGroupId"], t["stageId"])
    DataCenter.ZombieBattleManager:Destroy()
    local param = {}
    param.type = PVEType.Barrage
    param.levelId = stageId
    param.levelGroupId = stageGroupId
    DataCenter.ZombieBattleManager:Enter(param)

    --     return
    -- else
    --     AutoUseSupplyEnterBattle()
    -- end
end

PveUtil.CheckConfigChanged = CheckConfigChanged
PveUtil.LoadHeroPowerCache = LoadHeroPowerCache
PveUtil.SaveHeroPowerCache = SaveHeroPowerCache
PveUtil.GetHeroPowerCache = GetHeroPowerCache
PveUtil.SetHeroPowerCache = SetHeroPowerCache
PveUtil.ClearHeroPowerCache = ClearHeroPowerCache
PveUtil.GetCacheKey = GetCacheKey
PveUtil.GetRecommendMonsterId = GetRecommendMonsterId
PveUtil.GetAverageHeroPower = GetAverageHeroPower
PveUtil.GetHeroPower = GetHeroPower
PveUtil.GetRecommendLevelLimitMonsterId = GetRecommendLevelLimitMonsterId
PveUtil.CheckHeroesBreak = CheckHeroesBreak
PveUtil.CheckHeroBreak = CheckHeroBreak
PveUtil.CheckHeroesMaxed = CheckHeroesMaxed
PveUtil.CheckHeroMaxed = CheckHeroMaxed
PveUtil.CheckHeroesRarity = CheckHeroesRarity
PveUtil.CheckHeroRarity = CheckHeroRarity
PveUtil.CheckHeroSlotEmpty = CheckHeroSlotEmpty
PveUtil.ParseArmyRecord = ParseArmyRecord
PveUtil.CanShowPowerLack = CanShowPowerLack
PveUtil.GetPowerLack = GetPowerLack
PveUtil.GetPowerLackTipClickFunc = GetPowerLackTipClickFunc
PveUtil.GetMaxSoldierNum = GetMaxSoldierNum
PveUtil.CanAddStamina = CanAddStamina
PveUtil.ParseBattleContent = ParseBattleContent
PveUtil.ParseDetailContent = ParseDetailContent

PveUtil.EnterPve = EnterPve

PveUtil.GetPveHeroAttack = GetPveHeroAttack
PveUtil.GetPveHeroDefence = GetPveHeroDefence
PveUtil.GetPveHeroHp = GetPveHeroHp
PveUtil.GetPveMonsterAttack = GetPveMonsterAttack
PveUtil.GetPveMonsterDefence = GetPveMonsterDefence
PveUtil.GetPveMonsterHp = GetPveMonsterHp
PveUtil.CalculateAttack = CalculateAttack
PveUtil.CalculateDefence = CalculateDefence
PveUtil.CalculateHP = CalculateHP
PveUtil.CalculateDamage = CalculateDamage
PveUtil.GetAllUnitsInSphereRange = GetAllUnitsInSphereRange
PveUtil.GetAllUnitsInBoxRange = GetAllUnitsInBoxRange
PveUtil.CheckHasUnitInSphereRange = CheckHasUnitInSphereRange
PveUtil.CheckHasBossInSphereRange = CheckHasBossInSphereRange
PveUtil.FindRandomUnitInSphereRange = FindRandomUnitInSphereRange
PveUtil.FindNearestUnitInSphereRange = FindNearestUnitInSphereRange
PveUtil.FindFarthestUnitInSphereRange = FindFarthestUnitInSphereRange
PveUtil.FindLowestHPUnitInSphereRange = FindLowestHPUnitInSphereRange
PveUtil.SetLayerRecursively = SetLayerRecursively
PveUtil.FindHighestMaxHPUnitInSphereRange = FindHighestMaxHPUnitInSphereRange
PveUtil.FindHighestPropertyUnitInSphereRange = FindHighestPropertyUnitInSphereRange

PveUtil.CheckCannonLookAt = CheckCannonLookAt
PveUtil.GetTargetLayer = GetTargetLayer
PveUtil.TryEnterBattle = TryEnterBattle

return ConstClass("PveUtil", PveUtil)